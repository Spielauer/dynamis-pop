/**
 * @file   om_definitions.cpp
 * Definitions for model 'Dynamis-Pop-3-06-ABC' - Generated by openM++ compiler
 *  
 *  Model version = 1.0.1.0
 *  Model created = 2021-03-17 14:19:34.883
 *  Model digest = 6eccce191106d267b262a54392186270
 */

#include "omc/omPch.h"
#include "omc/omSimulation.h"
#include <typeinfo>

const bool BaseEvent::just_in_time = true;


using namespace openm;

const bool BaseEvent::trace_event_enabled = false;
thread_local bool BaseEvent::trace_event_on = false;
const bool BaseEvent::event_checksum_enabled = false;
thread_local double BaseEvent::event_checksum_value = 0.0;
const bool BaseEvent::allow_time_travel = false;

// fundamental types
const Time_t time_infinite = std::numeric_limits<double>::infinity();
const Time_t TIME_INFINITE = std::numeric_limits<double>::infinity(); // for Modgen compatibility
const Time_t time_undef = std::numeric_limits<double>::quiet_NaN();
const Time_t TIME_UNDEF = std::numeric_limits<double>::quiet_NaN(); // for Modgen compatibility


// templated types
/** CHILD_AGEGR_PART */
// lower bounds of intervals in partition
const std::array<real, 7> om_CHILD_AGEGR_PART_lower = {
    -REAL_MAX,
    1,
    3,
    6,
    9,
    12,
    15,
};
// upper bounds of intervals in partition
const std::array<real, 7> om_CHILD_AGEGR_PART_upper = {
    1,
    3,
    6,
    9,
    12,
    15,
    REAL_MAX
};
// splitter map for partition
const std::map<real, char> om_CHILD_AGEGR_PART_splitter = {
    { 1, 0 },
    { 3, 1 },
    { 6, 2 },
    { 9, 3 },
    { 12, 4 },
    { 15, 5 },
};
/** MOTH_AGEGR_PART */
// lower bounds of intervals in partition
const std::array<real, 6> om_MOTH_AGEGR_PART_lower = {
    -REAL_MAX,
    20,
    25,
    30,
    35,
    40,
};
// upper bounds of intervals in partition
const std::array<real, 6> om_MOTH_AGEGR_PART_upper = {
    20,
    25,
    30,
    35,
    40,
    REAL_MAX
};
// splitter map for partition
const std::map<real, char> om_MOTH_AGEGR_PART_splitter = {
    { 20, 0 },
    { 25, 1 },
    { 30, 2 },
    { 35, 3 },
    { 40, 4 },
};
/** BIRTH_AGE_PART */
// lower bounds of intervals in partition
const std::array<real, 4> om_BIRTH_AGE_PART_lower = {
    -REAL_MAX,
    35,
    40,
    45,
};
// upper bounds of intervals in partition
const std::array<real, 4> om_BIRTH_AGE_PART_upper = {
    35,
    40,
    45,
    REAL_MAX
};
// splitter map for partition
const std::map<real, char> om_BIRTH_AGE_PART_splitter = {
    { 35, 0 },
    { 40, 1 },
    { 45, 2 },
};
/** DUR_TIME_IN_PARITY */
// lower bounds of intervals in partition
const std::array<real, 6> om_DUR_TIME_IN_PARITY_lower = {
    -REAL_MAX,
    1,
    3,
    6,
    9,
    12,
};
// upper bounds of intervals in partition
const std::array<real, 6> om_DUR_TIME_IN_PARITY_upper = {
    1,
    3,
    6,
    9,
    12,
    REAL_MAX
};
// splitter map for partition
const std::map<real, char> om_DUR_TIME_IN_PARITY_splitter = {
    { 1, 0 },
    { 3, 1 },
    { 6, 2 },
    { 9, 3 },
    { 12, 4 },
};
/** AGE_MIG_PART */
// lower bounds of intervals in partition
const std::array<real, 13> om_AGE_MIG_PART_lower = {
    -REAL_MAX,
    5,
    10,
    15,
    20,
    25,
    30,
    35,
    40,
    45,
    50,
    55,
    60,
};
// upper bounds of intervals in partition
const std::array<real, 13> om_AGE_MIG_PART_upper = {
    5,
    10,
    15,
    20,
    25,
    30,
    35,
    40,
    45,
    50,
    55,
    60,
    REAL_MAX
};
// splitter map for partition
const std::map<real, char> om_AGE_MIG_PART_splitter = {
    { 5, 0 },
    { 10, 1 },
    { 15, 2 },
    { 20, 3 },
    { 25, 4 },
    { 30, 5 },
    { 35, 6 },
    { 40, 7 },
    { 45, 8 },
    { 50, 9 },
    { 55, 10 },
    { 60, 11 },
};
/** TAB_AGEC5 */
// lower bounds of intervals in partition
const std::array<real, 21> om_TAB_AGEC5_lower = {
    -REAL_MAX,
    1,
    5,
    10,
    15,
    20,
    25,
    30,
    35,
    40,
    45,
    50,
    55,
    60,
    65,
    70,
    75,
    80,
    85,
    90,
    95,
};
// upper bounds of intervals in partition
const std::array<real, 21> om_TAB_AGEC5_upper = {
    1,
    5,
    10,
    15,
    20,
    25,
    30,
    35,
    40,
    45,
    50,
    55,
    60,
    65,
    70,
    75,
    80,
    85,
    90,
    95,
    REAL_MAX
};
// splitter map for partition
const std::map<real, char> om_TAB_AGEC5_splitter = {
    { 1, 0 },
    { 5, 1 },
    { 10, 2 },
    { 15, 3 },
    { 20, 4 },
    { 25, 5 },
    { 30, 6 },
    { 35, 7 },
    { 40, 8 },
    { 45, 9 },
    { 50, 10 },
    { 55, 11 },
    { 60, 12 },
    { 65, 13 },
    { 70, 14 },
    { 75, 15 },
    { 80, 16 },
    { 85, 17 },
    { 90, 18 },
    { 95, 19 },
};
/** tab_age15 */
// lower bounds of intervals in partition
const std::array<real, 4> om_tab_age15_lower = {
    -REAL_MAX,
    15,
    30,
    60,
};
// upper bounds of intervals in partition
const std::array<real, 4> om_tab_age15_upper = {
    15,
    30,
    60,
    REAL_MAX
};
// splitter map for partition
const std::map<real, char> om_tab_age15_splitter = {
    { 15, 0 },
    { 30, 1 },
    { 60, 2 },
};
/** IMMU_YOB_PART */
// lower bounds of intervals in partition
const std::array<real, 4> om_IMMU_YOB_PART_lower = {
    -REAL_MAX,
    1971,
    1976,
    1981,
};
// upper bounds of intervals in partition
const std::array<real, 4> om_IMMU_YOB_PART_upper = {
    1971,
    1976,
    1981,
    REAL_MAX
};
// splitter map for partition
const std::map<real, char> om_IMMU_YOB_PART_splitter = {
    { 1971, 0 },
    { 1976, 1 },
    { 1981, 2 },
};

// model aggregations

const std::map<ETHNICITY, ETHNICITY_SHORT> om_aggregation_ETHNICITY_om_ETHNICITY_SHORT = {
    { ETHNO_00, ES_00 },
    { ETHNO_01, ES_04 },
    { ETHNO_02, ES_02 },
    { ETHNO_03, ES_00 },
    { ETHNO_04, ES_01 },
    { ETHNO_05, ES_03 },
    { ETHNO_06, ES_04 },
    { ETHNO_07, ES_05 },
    { ETHNO_08, ES_06 },
    { ETHNO_09, ES_06 },
};

const std::map<GEO, BIRTH1_LOC> om_aggregation_GEO_om_BIRTH1_LOC = {
    { GEO_00, B1L_00 },
    { GEO_01, B1L_00 },
    { GEO_02, B1L_00 },
    { GEO_03, B1L_01 },
    { GEO_04, B1L_01 },
    { GEO_05, B1L_01 },
    { GEO_06, B1L_02 },
    { GEO_07, B1L_02 },
    { GEO_08, B1L_02 },
    { GEO_09, B1L_04 },
    { GEO_10, B1L_03 },
    { GEO_11, B1L_04 },
    { GEO_ABROAD, B1L_04 },
};
BIRTH1_LOC GEO_To_BIRTH1_LOC(GEO level)
{
    return om_aggregation_GEO_om_BIRTH1_LOC.find(level)->second;
}

const std::map<GEO, GEO_NAT> om_aggregation_GEO_om_GEO_NAT = {
    { GEO_00, GEON_00 },
    { GEO_01, GEON_01 },
    { GEO_02, GEON_02 },
    { GEO_03, GEON_03 },
    { GEO_04, GEON_04 },
    { GEO_05, GEON_05 },
    { GEO_06, GEON_06 },
    { GEO_07, GEON_07 },
    { GEO_08, GEON_08 },
    { GEO_09, GEON_09 },
    { GEO_10, GEON_10 },
    { GEO_11, GEON_11 },
    { GEO_ABROAD, GEON_11 },
};

const std::map<GEO, REGION_INT> om_aggregation_GEO_om_REGION_INT = {
    { GEO_00, REGI_00 },
    { GEO_01, REGI_00 },
    { GEO_02, REGI_00 },
    { GEO_03, REGI_01 },
    { GEO_04, REGI_01 },
    { GEO_05, REGI_01 },
    { GEO_06, REGI_02 },
    { GEO_07, REGI_02 },
    { GEO_08, REGI_02 },
    { GEO_09, REGI_04 },
    { GEO_10, REGI_03 },
    { GEO_11, REGI_04 },
    { GEO_ABROAD, REGI_ABROAD },
};

const std::map<REGION_INT, REGION_NAT> om_aggregation_REGION_INT_om_REGION_NAT = {
    { REGI_00, REGN_00 },
    { REGI_01, REGN_01 },
    { REGI_02, REGN_02 },
    { REGI_03, REGN_03 },
    { REGI_04, REGN_04 },
    { REGI_ABROAD, REGN_04 },
};

// model scenario parameters

#ifdef OM_DEBUG_PARAMETERS

static std::vector<double> om_param_AgeImmiSearchMother;
static thread_local double om_value_AgeImmiSearchMother;
thread_local const double & AgeImmiSearchMother = om_value_AgeImmiSearchMother;

static std::vector<std::unique_ptr<double[]>> om_param_AgeImmigrantsScratch;
static thread_local double om_value_AgeImmigrantsScratch[2][101];
thread_local const double (& AgeImmigrantsScratch)[2][101] = om_value_AgeImmigrantsScratch;

static std::vector<double> om_param_AgeLeavingHome;
static thread_local double om_value_AgeLeavingHome;
thread_local const double & AgeLeavingHome = om_value_AgeLeavingHome;

static std::vector<std::unique_ptr<double[]>> om_param_AgeOfImmigrantMother;
static thread_local double om_value_AgeOfImmigrantMother[38];
thread_local const double (& AgeOfImmigrantMother)[38] = om_value_AgeOfImmigrantMother;

static std::vector<std::unique_ptr<double[]>> om_param_AgeSpecificFertility;
static thread_local double om_value_AgeSpecificFertility[38][151];
thread_local const double (& AgeSpecificFertility)[38][151] = om_value_AgeSpecificFertility;

static std::vector<double> om_param_BackMigrationHazard;
static thread_local double om_value_BackMigrationHazard;
thread_local const double & BackMigrationHazard = om_value_BackMigrationHazard;

static std::vector<std::unique_ptr<double[]>> om_param_BirthTrends;
static thread_local double om_value_BirthTrends[15][151];
thread_local const double (& BirthTrends)[15][151] = om_value_BirthTrends;

static std::vector<std::unique_ptr<double[]>> om_param_ChildMortalityBaseRisk;
static thread_local double om_value_ChildMortalityBaseRisk[5][2];
thread_local const double (& ChildMortalityBaseRisk)[5][2] = om_value_ChildMortalityBaseRisk;

static std::vector<std::unique_ptr<double[]>> om_param_ChildMortalityRelativeRisks;
static thread_local double om_value_ChildMortalityRelativeRisks[5][9];
thread_local const double (& ChildMortalityRelativeRisks)[5][9] = om_value_ChildMortalityRelativeRisks;

static std::vector<std::unique_ptr<double[]>> om_param_ChildMortalityTrend;
static thread_local double om_value_ChildMortalityTrend[5][146];
thread_local const double (& ChildMortalityTrend)[5][146] = om_value_ChildMortalityTrend;

static std::vector<std::unique_ptr<double[]>> om_param_ChildVaccinationOdds;
static thread_local double om_value_ChildVaccinationOdds[2][151][18];
thread_local const double (& ChildVaccinationOdds)[2][151][18] = om_value_ChildVaccinationOdds;

static std::vector<int> om_param_Educ1FirstCohortRefinedModel;
static thread_local int om_value_Educ1FirstCohortRefinedModel;
thread_local const int & Educ1FirstCohortRefinedModel = om_value_Educ1FirstCohortRefinedModel;

static std::vector<std::unique_ptr<double[]>> om_param_Educ1GradOdds;
static thread_local double om_value_Educ1GradOdds[3][2];
thread_local const double (& Educ1GradOdds)[3][2] = om_value_Educ1GradOdds;

static std::vector<std::unique_ptr<double[]>> om_param_Educ1Infrastructure;
static thread_local double om_value_Educ1Infrastructure[2][12][151];
thread_local const double (& Educ1Infrastructure)[2][12][151] = om_value_Educ1Infrastructure;

static std::vector<char> om_param_Educ1Model;
static thread_local char om_value_Educ1Model;
thread_local const char & Educ1Model = om_value_Educ1Model;

static std::vector<std::unique_ptr<double[]>> om_param_Educ1StartOdds;
static thread_local double om_value_Educ1StartOdds[3][2];
thread_local const double (& Educ1StartOdds)[3][2] = om_value_Educ1StartOdds;

static std::vector<int> om_param_Educ2AllowedDelays;
static thread_local int om_value_Educ2AllowedDelays;
thread_local const int & Educ2AllowedDelays = om_value_Educ2AllowedDelays;

static std::vector<std::unique_ptr<double[]>> om_param_Educ2DelayedProgressionIntake;
static thread_local double om_value_Educ2DelayedProgressionIntake[1][1][6][151];
thread_local const double (& Educ2DelayedProgressionIntake)[1][1][6][151] = om_value_Educ2DelayedProgressionIntake;

static std::vector<std::unique_ptr<double[]>> om_param_Educ2DelayedRepetitionIntake;
static thread_local double om_value_Educ2DelayedRepetitionIntake[1][1][6][151];
thread_local const double (& Educ2DelayedRepetitionIntake)[1][1][6][151] = om_value_Educ2DelayedRepetitionIntake;

static std::vector<std::unique_ptr<double[]>> om_param_Educ2DirectProgressionIntake;
static thread_local double om_value_Educ2DirectProgressionIntake[1][1][6][151];
thread_local const double (& Educ2DirectProgressionIntake)[1][1][6][151] = om_value_Educ2DirectProgressionIntake;

static std::vector<std::unique_ptr<double[]>> om_param_Educ2DirectRepetitionIntake;
static thread_local double om_value_Educ2DirectRepetitionIntake[1][1][6][151];
thread_local const double (& Educ2DirectRepetitionIntake)[1][1][6][151] = om_value_Educ2DirectRepetitionIntake;

static std::vector<std::unique_ptr<double[]>> om_param_Educ2PeriodSuccess;
static thread_local double om_value_Educ2PeriodSuccess[1][1][6][151];
thread_local const double (& Educ2PeriodSuccess)[1][1][6][151] = om_value_Educ2PeriodSuccess;

static std::vector<std::unique_ptr<double[]>> om_param_EducOneDropoutGrade;
static thread_local double om_value_EducOneDropoutGrade[1][1][67][6];
thread_local const double (& EducOneDropoutGrade)[1][1][67][6] = om_value_EducOneDropoutGrade;

static std::vector<std::unique_ptr<double[]>> om_param_EducOneEntryAge;
static thread_local double om_value_EducOneEntryAge[1][1][67][4];
thread_local const double (& EducOneEntryAge)[1][1][67][4] = om_value_EducOneEntryAge;

static std::vector<std::unique_ptr<double[]>> om_param_EducTrans1;
static thread_local double om_value_EducTrans1[2][63][13];
thread_local const double (& EducTrans1)[2][63][13] = om_value_EducTrans1;

static std::vector<std::unique_ptr<double[]>> om_param_EducTrans2;
static thread_local double om_value_EducTrans2[2][67][13];
thread_local const double (& EducTrans2)[2][67][13] = om_value_EducTrans2;

static std::vector<std::unique_ptr<double[]>> om_param_EmigrationDestination;
static thread_local double om_value_EmigrationDestination[1];
thread_local const double (& EmigrationDestination)[1] = om_value_EmigrationDestination;

static std::vector<std::unique_ptr<double[]>> om_param_EmigrationRatesDistrict;
static thread_local double om_value_EmigrationRatesDistrict[2][13][12];
thread_local const double (& EmigrationRatesDistrict)[2][13][12] = om_value_EmigrationRatesDistrict;

static std::vector<double> om_param_EndSchoolOneYear;
static thread_local double om_value_EndSchoolOneYear;
thread_local const double & EndSchoolOneYear = om_value_EndSchoolOneYear;

static std::vector<std::unique_ptr<double[]>> om_param_EthnicTransmission;
static thread_local double om_value_EthnicTransmission[2][10][10];
thread_local const double (& EthnicTransmission)[2][10][10] = om_value_EthnicTransmission;

static std::vector<std::unique_ptr<double[]>> om_param_EthnicityImmigrantsScratch;
static thread_local double om_value_EthnicityImmigrantsScratch[2][12][10];
thread_local const double (& EthnicityImmigrantsScratch)[2][12][10] = om_value_EthnicityImmigrantsScratch;

static std::vector<char> om_param_FertilityModel;
static thread_local char om_value_FertilityModel;
thread_local const char & FertilityModel = om_value_FertilityModel;

static std::vector<std::unique_ptr<double[]>> om_param_FirstBirthRates;
static thread_local double om_value_FirstBirthRates[3][2][38][5];
thread_local const double (& FirstBirthRates)[3][2][38][5] = om_value_FirstBirthRates;

static std::vector<std::unique_ptr<double[]>> om_param_HCICoefficients;
static thread_local double om_value_HCICoefficients[3];
thread_local const double (& HCICoefficients)[3] = om_value_HCICoefficients;

static std::vector<std::unique_ptr<double[]>> om_param_HigherOrderBirthsPara;
static thread_local double om_value_HigherOrderBirthsPara[11][14];
thread_local const double (& HigherOrderBirthsPara)[11][14] = om_value_HigherOrderBirthsPara;

static std::vector<std::unique_ptr<double[]>> om_param_ImmiPoolDestination;
static thread_local double om_value_ImmiPoolDestination[3][151][12];
thread_local const double (& ImmiPoolDestination)[3][151][12] = om_value_ImmiPoolDestination;

static std::vector<std::unique_ptr<double[]>> om_param_ImmiPoolSize;
static thread_local double om_value_ImmiPoolSize[3][151];
thread_local const double (& ImmiPoolSize)[3][151] = om_value_ImmiPoolSize;

static std::vector<std::unique_ptr<double[]>> om_param_ImmiScratchDestination;
static thread_local double om_value_ImmiScratchDestination[2][13][12];
thread_local const double (& ImmiScratchDestination)[2][13][12] = om_value_ImmiScratchDestination;

static std::vector<std::unique_ptr<double[]>> om_param_InUnionProbNoChildren;
static thread_local double om_value_InUnionProbNoChildren[51][3];
thread_local const double (& InUnionProbNoChildren)[51][3] = om_value_InUnionProbNoChildren;

static std::vector<std::unique_ptr<double[]>> om_param_InUnionProbWithChildren;
static thread_local double om_value_InUnionProbWithChildren[3][7][6];
thread_local const double (& InUnionProbWithChildren)[3][7][6] = om_value_InUnionProbWithChildren;

static std::vector<std::unique_ptr<double[]>> om_param_LifeExpectancy;
static thread_local double om_value_LifeExpectancy[151][2];
thread_local const double (& LifeExpectancy)[151][2] = om_value_LifeExpectancy;

static std::vector<std::string> om_param_MicroDataInputFile;
static thread_local std::string om_value_MicroDataInputFile;
thread_local const std::string & MicroDataInputFile = om_value_MicroDataInputFile;

static std::vector<std::unique_ptr<double[]>> om_param_MigrationDestination;
static thread_local double om_value_MigrationDestination[2][12][13][12];
thread_local const double (& MigrationDestination)[2][12][13][12] = om_value_MigrationDestination;

static std::vector<std::unique_ptr<double[]>> om_param_MigrationProbability;
static thread_local double om_value_MigrationProbability[2][13][12];
thread_local const double (& MigrationProbability)[2][13][12] = om_value_MigrationProbability;

static std::vector<bool> om_param_MigrationTryKeepingFamiliesTogether;
static thread_local bool om_value_MigrationTryKeepingFamiliesTogether;
thread_local const bool & MigrationTryKeepingFamiliesTogether = om_value_MigrationTryKeepingFamiliesTogether;

static std::vector<bool> om_param_ModelBackmigration;
static thread_local bool om_value_ModelBackmigration;
thread_local const bool & ModelBackmigration = om_value_ModelBackmigration;

static std::vector<bool> om_param_ModelEmigration;
static thread_local bool om_value_ModelEmigration;
thread_local const bool & ModelEmigration = om_value_ModelEmigration;

static std::vector<bool> om_param_ModelImmigrationFromPools;
static thread_local bool om_value_ModelImmigrationFromPools;
thread_local const bool & ModelImmigrationFromPools = om_value_ModelImmigrationFromPools;

static std::vector<bool> om_param_ModelImmigrationFromScratch;
static thread_local bool om_value_ModelImmigrationFromScratch;
thread_local const bool & ModelImmigrationFromScratch = om_value_ModelImmigrationFromScratch;

static std::vector<bool> om_param_ModelMigration;
static thread_local bool om_value_ModelMigration;
thread_local const bool & ModelMigration = om_value_ModelMigration;

static std::vector<char> om_param_MortalityModel;
static thread_local char om_value_MortalityModel;
thread_local const char & MortalityModel = om_value_MortalityModel;

static std::vector<std::unique_ptr<double[]>> om_param_MortalityTable;
static thread_local double om_value_MortalityTable[101][2];
thread_local const double (& MortalityTable)[101][2] = om_value_MortalityTable;

static std::vector<std::unique_ptr<double[]>> om_param_NumberImmigrantsFromScratch;
static thread_local double om_value_NumberImmigrantsFromScratch[151][2];
thread_local const double (& NumberImmigrantsFromScratch)[151][2] = om_value_NumberImmigrantsFromScratch;

static std::vector<std::unique_ptr<double[]>> om_param_PartnerAgeDistribution;
static thread_local double om_value_PartnerAgeDistribution[51][86];
thread_local const double (& PartnerAgeDistribution)[51][86] = om_value_PartnerAgeDistribution;

static std::vector<std::unique_ptr<double[]>> om_param_PartnerCharacteristicDistribution;
static thread_local double om_value_PartnerCharacteristicDistribution[3][3];
thread_local const double (& PartnerCharacteristicDistribution)[3][3] = om_value_PartnerCharacteristicDistribution;

static std::vector<std::unique_ptr<double[]>> om_param_PreNatalCareOdds;
static thread_local double om_value_PreNatalCareOdds[151][11];
thread_local const double (& PreNatalCareOdds)[151][11] = om_value_PreNatalCareOdds;

static std::vector<std::unique_ptr<double[]>> om_param_PreSchoolAttendance;
static thread_local double om_value_PreSchoolAttendance[2][5][151][2];
thread_local const double (& PreSchoolAttendance)[2][5][151][2] = om_value_PreSchoolAttendance;

static std::vector<double> om_param_ProbStayWithMother;
static thread_local double om_value_ProbStayWithMother;
thread_local const double & ProbStayWithMother = om_value_ProbStayWithMother;

static std::vector<std::unique_ptr<double[]>> om_param_ProportionStunting;
static thread_local double om_value_ProportionStunting[2][5][3];
thread_local const double (& ProportionStunting)[2][5][3] = om_value_ProportionStunting;

static std::vector<std::unique_ptr<double[]>> om_param_SchoolOneInterruptionRate;
static thread_local double om_value_SchoolOneInterruptionRate[1][1][151];
thread_local const double (& SchoolOneInterruptionRate)[1][1][151] = om_value_SchoolOneInterruptionRate;

static std::vector<std::unique_ptr<double[]>> om_param_SchoolOneRepetitionRate;
static thread_local double om_value_SchoolOneRepetitionRate[1][1][151];
thread_local const double (& SchoolOneRepetitionRate)[1][1][151] = om_value_SchoolOneRepetitionRate;

static std::vector<std::unique_ptr<double[]>> om_param_SchoolQuality;
static thread_local double om_value_SchoolQuality[5][2];
thread_local const double (& SchoolQuality)[5][2] = om_value_SchoolQuality;

static std::vector<std::unique_ptr<double[]>> om_param_SexRatio;
static thread_local double om_value_SexRatio[151];
thread_local const double (& SexRatio)[151] = om_value_SexRatio;

static std::vector<double> om_param_SimulationEnd;
static thread_local double om_value_SimulationEnd;
thread_local const double & SimulationEnd = om_value_SimulationEnd;

static std::vector<int> om_param_SimulationSeed;
static thread_local int om_value_SimulationSeed;
thread_local const int & SimulationSeed = om_value_SimulationSeed;

static std::vector<double> om_param_StartPopSampleSize;
static thread_local double om_value_StartPopSampleSize;
thread_local const double & StartPopSampleSize = om_value_StartPopSampleSize;

static std::vector<double> om_param_StartSchoolOneYear;
static thread_local double om_value_StartSchoolOneYear;
thread_local const double & StartSchoolOneYear = om_value_StartSchoolOneYear;

static std::vector<std::unique_ptr<double[]>> om_param_TotalFertilityRate;
static thread_local double om_value_TotalFertilityRate[151];
thread_local const double (& TotalFertilityRate)[151] = om_value_TotalFertilityRate;

static std::vector<char> om_param_Union1Choice;
static thread_local char om_value_Union1Choice;
thread_local const char & Union1Choice = om_value_Union1Choice;

static std::vector<std::unique_ptr<double[]>> om_param_Union1ParametersCMN;
static thread_local double om_value_Union1ParametersCMN[3][87][3];
thread_local const double (& Union1ParametersCMN)[3][87][3] = om_value_Union1ParametersCMN;

static std::vector<std::unique_ptr<double[]>> om_param_Union1ParametersHazards;
static thread_local double om_value_Union1ParametersHazards[3][51][252];
thread_local const double (& Union1ParametersHazards)[3][51][252] = om_value_Union1ParametersHazards;

#else // OM_DEBUG_PARAMETERS

static std::vector<double> om_param_AgeImmiSearchMother;
static thread_local double om_value_AgeImmiSearchMother;
thread_local const double & AgeImmiSearchMother = om_value_AgeImmiSearchMother;

static std::vector<std::unique_ptr<double[]>> om_param_AgeImmigrantsScratch;
thread_local double * om_value_AgeImmigrantsScratch = nullptr;

static std::vector<double> om_param_AgeLeavingHome;
static thread_local double om_value_AgeLeavingHome;
thread_local const double & AgeLeavingHome = om_value_AgeLeavingHome;

static std::vector<std::unique_ptr<double[]>> om_param_AgeOfImmigrantMother;
thread_local double * om_value_AgeOfImmigrantMother = nullptr;

static std::vector<std::unique_ptr<double[]>> om_param_AgeSpecificFertility;
thread_local double * om_value_AgeSpecificFertility = nullptr;

static std::vector<double> om_param_BackMigrationHazard;
static thread_local double om_value_BackMigrationHazard;
thread_local const double & BackMigrationHazard = om_value_BackMigrationHazard;

static std::vector<std::unique_ptr<double[]>> om_param_BirthTrends;
thread_local double * om_value_BirthTrends = nullptr;

static std::vector<std::unique_ptr<double[]>> om_param_ChildMortalityBaseRisk;
thread_local double * om_value_ChildMortalityBaseRisk = nullptr;

static std::vector<std::unique_ptr<double[]>> om_param_ChildMortalityRelativeRisks;
thread_local double * om_value_ChildMortalityRelativeRisks = nullptr;

static std::vector<std::unique_ptr<double[]>> om_param_ChildMortalityTrend;
thread_local double * om_value_ChildMortalityTrend = nullptr;

static std::vector<std::unique_ptr<double[]>> om_param_ChildVaccinationOdds;
thread_local double * om_value_ChildVaccinationOdds = nullptr;

static std::vector<int> om_param_Educ1FirstCohortRefinedModel;
static thread_local int om_value_Educ1FirstCohortRefinedModel;
thread_local const int & Educ1FirstCohortRefinedModel = om_value_Educ1FirstCohortRefinedModel;

static std::vector<std::unique_ptr<double[]>> om_param_Educ1GradOdds;
thread_local double * om_value_Educ1GradOdds = nullptr;

static std::vector<std::unique_ptr<double[]>> om_param_Educ1Infrastructure;
thread_local double * om_value_Educ1Infrastructure = nullptr;

static std::vector<char> om_param_Educ1Model;
static thread_local char om_value_Educ1Model;
thread_local const char & Educ1Model = om_value_Educ1Model;

static std::vector<std::unique_ptr<double[]>> om_param_Educ1StartOdds;
thread_local double * om_value_Educ1StartOdds = nullptr;

static std::vector<int> om_param_Educ2AllowedDelays;
static thread_local int om_value_Educ2AllowedDelays;
thread_local const int & Educ2AllowedDelays = om_value_Educ2AllowedDelays;

static std::vector<std::unique_ptr<double[]>> om_param_Educ2DelayedProgressionIntake;
thread_local double * om_value_Educ2DelayedProgressionIntake = nullptr;

static std::vector<std::unique_ptr<double[]>> om_param_Educ2DelayedRepetitionIntake;
thread_local double * om_value_Educ2DelayedRepetitionIntake = nullptr;

static std::vector<std::unique_ptr<double[]>> om_param_Educ2DirectProgressionIntake;
thread_local double * om_value_Educ2DirectProgressionIntake = nullptr;

static std::vector<std::unique_ptr<double[]>> om_param_Educ2DirectRepetitionIntake;
thread_local double * om_value_Educ2DirectRepetitionIntake = nullptr;

static std::vector<std::unique_ptr<double[]>> om_param_Educ2PeriodSuccess;
thread_local double * om_value_Educ2PeriodSuccess = nullptr;

static std::vector<std::unique_ptr<double[]>> om_param_EducOneDropoutGrade;
thread_local double * om_value_EducOneDropoutGrade = nullptr;

static std::vector<std::unique_ptr<double[]>> om_param_EducOneEntryAge;
thread_local double * om_value_EducOneEntryAge = nullptr;

static std::vector<std::unique_ptr<double[]>> om_param_EducTrans1;
thread_local double * om_value_EducTrans1 = nullptr;

static std::vector<std::unique_ptr<double[]>> om_param_EducTrans2;
thread_local double * om_value_EducTrans2 = nullptr;

static std::vector<std::unique_ptr<double[]>> om_param_EmigrationDestination;
thread_local double * om_value_EmigrationDestination = nullptr;

static std::vector<std::unique_ptr<double[]>> om_param_EmigrationRatesDistrict;
thread_local double * om_value_EmigrationRatesDistrict = nullptr;

static std::vector<double> om_param_EndSchoolOneYear;
static thread_local double om_value_EndSchoolOneYear;
thread_local const double & EndSchoolOneYear = om_value_EndSchoolOneYear;

static std::vector<std::unique_ptr<double[]>> om_param_EthnicTransmission;
thread_local double * om_value_EthnicTransmission = nullptr;

static std::vector<std::unique_ptr<double[]>> om_param_EthnicityImmigrantsScratch;
thread_local double * om_value_EthnicityImmigrantsScratch = nullptr;

static std::vector<char> om_param_FertilityModel;
static thread_local char om_value_FertilityModel;
thread_local const char & FertilityModel = om_value_FertilityModel;

static std::vector<std::unique_ptr<double[]>> om_param_FirstBirthRates;
thread_local double * om_value_FirstBirthRates = nullptr;

static std::vector<std::unique_ptr<double[]>> om_param_HCICoefficients;
thread_local double * om_value_HCICoefficients = nullptr;

static std::vector<std::unique_ptr<double[]>> om_param_HigherOrderBirthsPara;
thread_local double * om_value_HigherOrderBirthsPara = nullptr;

static std::vector<std::unique_ptr<double[]>> om_param_ImmiPoolDestination;
thread_local double * om_value_ImmiPoolDestination = nullptr;

static std::vector<std::unique_ptr<double[]>> om_param_ImmiPoolSize;
thread_local double * om_value_ImmiPoolSize = nullptr;

static std::vector<std::unique_ptr<double[]>> om_param_ImmiScratchDestination;
thread_local double * om_value_ImmiScratchDestination = nullptr;

static std::vector<std::unique_ptr<double[]>> om_param_InUnionProbNoChildren;
thread_local double * om_value_InUnionProbNoChildren = nullptr;

static std::vector<std::unique_ptr<double[]>> om_param_InUnionProbWithChildren;
thread_local double * om_value_InUnionProbWithChildren = nullptr;

static std::vector<std::unique_ptr<double[]>> om_param_LifeExpectancy;
thread_local double * om_value_LifeExpectancy = nullptr;

static std::vector<std::string> om_param_MicroDataInputFile;
static thread_local std::string om_value_MicroDataInputFile;
thread_local const std::string & MicroDataInputFile = om_value_MicroDataInputFile;

static std::vector<std::unique_ptr<double[]>> om_param_MigrationDestination;
thread_local double * om_value_MigrationDestination = nullptr;

static std::vector<std::unique_ptr<double[]>> om_param_MigrationProbability;
thread_local double * om_value_MigrationProbability = nullptr;

static std::vector<bool> om_param_MigrationTryKeepingFamiliesTogether;
static thread_local bool om_value_MigrationTryKeepingFamiliesTogether;
thread_local const bool & MigrationTryKeepingFamiliesTogether = om_value_MigrationTryKeepingFamiliesTogether;

static std::vector<bool> om_param_ModelBackmigration;
static thread_local bool om_value_ModelBackmigration;
thread_local const bool & ModelBackmigration = om_value_ModelBackmigration;

static std::vector<bool> om_param_ModelEmigration;
static thread_local bool om_value_ModelEmigration;
thread_local const bool & ModelEmigration = om_value_ModelEmigration;

static std::vector<bool> om_param_ModelImmigrationFromPools;
static thread_local bool om_value_ModelImmigrationFromPools;
thread_local const bool & ModelImmigrationFromPools = om_value_ModelImmigrationFromPools;

static std::vector<bool> om_param_ModelImmigrationFromScratch;
static thread_local bool om_value_ModelImmigrationFromScratch;
thread_local const bool & ModelImmigrationFromScratch = om_value_ModelImmigrationFromScratch;

static std::vector<bool> om_param_ModelMigration;
static thread_local bool om_value_ModelMigration;
thread_local const bool & ModelMigration = om_value_ModelMigration;

static std::vector<char> om_param_MortalityModel;
static thread_local char om_value_MortalityModel;
thread_local const char & MortalityModel = om_value_MortalityModel;

static std::vector<std::unique_ptr<double[]>> om_param_MortalityTable;
thread_local double * om_value_MortalityTable = nullptr;

static std::vector<std::unique_ptr<double[]>> om_param_NumberImmigrantsFromScratch;
thread_local double * om_value_NumberImmigrantsFromScratch = nullptr;

static std::vector<std::unique_ptr<double[]>> om_param_PartnerAgeDistribution;
thread_local double * om_value_PartnerAgeDistribution = nullptr;

static std::vector<std::unique_ptr<double[]>> om_param_PartnerCharacteristicDistribution;
thread_local double * om_value_PartnerCharacteristicDistribution = nullptr;

static std::vector<std::unique_ptr<double[]>> om_param_PreNatalCareOdds;
thread_local double * om_value_PreNatalCareOdds = nullptr;

static std::vector<std::unique_ptr<double[]>> om_param_PreSchoolAttendance;
thread_local double * om_value_PreSchoolAttendance = nullptr;

static std::vector<double> om_param_ProbStayWithMother;
static thread_local double om_value_ProbStayWithMother;
thread_local const double & ProbStayWithMother = om_value_ProbStayWithMother;

static std::vector<std::unique_ptr<double[]>> om_param_ProportionStunting;
thread_local double * om_value_ProportionStunting = nullptr;

static std::vector<std::unique_ptr<double[]>> om_param_SchoolOneInterruptionRate;
thread_local double * om_value_SchoolOneInterruptionRate = nullptr;

static std::vector<std::unique_ptr<double[]>> om_param_SchoolOneRepetitionRate;
thread_local double * om_value_SchoolOneRepetitionRate = nullptr;

static std::vector<std::unique_ptr<double[]>> om_param_SchoolQuality;
thread_local double * om_value_SchoolQuality = nullptr;

static std::vector<std::unique_ptr<double[]>> om_param_SexRatio;
thread_local double * om_value_SexRatio = nullptr;

static std::vector<double> om_param_SimulationEnd;
static thread_local double om_value_SimulationEnd;
thread_local const double & SimulationEnd = om_value_SimulationEnd;

static std::vector<int> om_param_SimulationSeed;
static thread_local int om_value_SimulationSeed;
thread_local const int & SimulationSeed = om_value_SimulationSeed;

static std::vector<double> om_param_StartPopSampleSize;
static thread_local double om_value_StartPopSampleSize;
thread_local const double & StartPopSampleSize = om_value_StartPopSampleSize;

static std::vector<double> om_param_StartSchoolOneYear;
static thread_local double om_value_StartSchoolOneYear;
thread_local const double & StartSchoolOneYear = om_value_StartSchoolOneYear;

static std::vector<std::unique_ptr<double[]>> om_param_TotalFertilityRate;
thread_local double * om_value_TotalFertilityRate = nullptr;

static std::vector<char> om_param_Union1Choice;
static thread_local char om_value_Union1Choice;
thread_local const char & Union1Choice = om_value_Union1Choice;

static std::vector<std::unique_ptr<double[]>> om_param_Union1ParametersCMN;
thread_local double * om_value_Union1ParametersCMN = nullptr;

static std::vector<std::unique_ptr<double[]>> om_param_Union1ParametersHazards;
thread_local double * om_value_Union1ParametersHazards = nullptr;

#endif // OM_DEBUG_PARAMETERS

// model parameters (derived, missing)

thread_local double AgeSpecificFertilityRate[38][151];

thread_local double EndSchoolTwoYear;

thread_local long MicroDataInputFileSize;

thread_local double MortalityTrend[151][2];

thread_local double ScalingFactor;

thread_local double StartSchoolTwoYear;

thread_local double Union1FormationHazard[3][252][51];

static thread_local cumrate<2,101> om_cumrate_AgeImmigrantsScratch;
bool Lookup_AgeImmigrantsScratch(double uniform, int cond0, int * draw0)
{
    // Calculate conditioning index
    size_t conditioning_index = 0;
    conditioning_index += cond0;
    // Determine if distribution is empty
    bool is_empty = om_cumrate_AgeImmigrantsScratch.is_degenerate(conditioning_index);
    size_t distribution_index = 0;
    if (!is_empty) {
        // Obtain value from distribution
        distribution_index = om_cumrate_AgeImmigrantsScratch.draw(conditioning_index, uniform);
    }
    // Calculate values of distribution dimensions
    *draw0 = distribution_index;
    return !is_empty;
}
static thread_local cumrate<1,38> om_cumrate_AgeOfImmigrantMother;
bool Lookup_AgeOfImmigrantMother(double uniform, int * draw0)
{
    // Calculate conditioning index
    size_t conditioning_index = 0;
    // Determine if distribution is empty
    bool is_empty = om_cumrate_AgeOfImmigrantMother.is_degenerate(conditioning_index);
    size_t distribution_index = 0;
    if (!is_empty) {
        // Obtain value from distribution
        distribution_index = om_cumrate_AgeOfImmigrantMother.draw(conditioning_index, uniform);
    }
    // Calculate values of distribution dimensions
    *draw0 = distribution_index;
    return !is_empty;
}
static thread_local cumrate<67,6> om_cumrate_EducOneDropoutGrade;
bool Lookup_EducOneDropoutGrade(double uniform, int cond0, int cond1, int cond2, int * draw0)
{
    // Calculate conditioning index
    size_t conditioning_index = 0;
    conditioning_index += cond0;
    conditioning_index *= 1;
    conditioning_index += cond1;
    conditioning_index *= 67;
    conditioning_index += cond2;
    // Determine if distribution is empty
    bool is_empty = om_cumrate_EducOneDropoutGrade.is_degenerate(conditioning_index);
    size_t distribution_index = 0;
    if (!is_empty) {
        // Obtain value from distribution
        distribution_index = om_cumrate_EducOneDropoutGrade.draw(conditioning_index, uniform);
    }
    // Calculate values of distribution dimensions
    *draw0 = distribution_index;
    return !is_empty;
}
static thread_local cumrate<67,4> om_cumrate_EducOneEntryAge;
bool Lookup_EducOneEntryAge(double uniform, int cond0, int cond1, int cond2, int * draw0)
{
    // Calculate conditioning index
    size_t conditioning_index = 0;
    conditioning_index += cond0;
    conditioning_index *= 1;
    conditioning_index += cond1;
    conditioning_index *= 67;
    conditioning_index += cond2;
    // Determine if distribution is empty
    bool is_empty = om_cumrate_EducOneEntryAge.is_degenerate(conditioning_index);
    size_t distribution_index = 0;
    if (!is_empty) {
        // Obtain value from distribution
        distribution_index = om_cumrate_EducOneEntryAge.draw(conditioning_index, uniform);
    }
    // Calculate values of distribution dimensions
    *draw0 = distribution_index;
    return !is_empty;
}
static thread_local cumrate<1,1> om_cumrate_EmigrationDestination;
bool Lookup_EmigrationDestination(double uniform, int * draw0)
{
    // Calculate conditioning index
    size_t conditioning_index = 0;
    // Determine if distribution is empty
    bool is_empty = om_cumrate_EmigrationDestination.is_degenerate(conditioning_index);
    size_t distribution_index = 0;
    if (!is_empty) {
        // Obtain value from distribution
        distribution_index = om_cumrate_EmigrationDestination.draw(conditioning_index, uniform);
    }
    // Calculate values of distribution dimensions
    *draw0 = distribution_index;
    return !is_empty;
}
static thread_local cumrate<20,10> om_cumrate_EthnicTransmission;
bool Lookup_EthnicTransmission(double uniform, int cond0, int cond1, int * draw0)
{
    // Calculate conditioning index
    size_t conditioning_index = 0;
    conditioning_index += cond0;
    conditioning_index *= 10;
    conditioning_index += cond1;
    // Determine if distribution is empty
    bool is_empty = om_cumrate_EthnicTransmission.is_degenerate(conditioning_index);
    size_t distribution_index = 0;
    if (!is_empty) {
        // Obtain value from distribution
        distribution_index = om_cumrate_EthnicTransmission.draw(conditioning_index, uniform);
    }
    // Calculate values of distribution dimensions
    *draw0 = distribution_index;
    return !is_empty;
}
static thread_local cumrate<24,10> om_cumrate_EthnicityImmigrantsScratch;
bool Lookup_EthnicityImmigrantsScratch(double uniform, int cond0, int cond1, int * draw0)
{
    // Calculate conditioning index
    size_t conditioning_index = 0;
    conditioning_index += cond0;
    conditioning_index *= 12;
    conditioning_index += cond1;
    // Determine if distribution is empty
    bool is_empty = om_cumrate_EthnicityImmigrantsScratch.is_degenerate(conditioning_index);
    size_t distribution_index = 0;
    if (!is_empty) {
        // Obtain value from distribution
        distribution_index = om_cumrate_EthnicityImmigrantsScratch.draw(conditioning_index, uniform);
    }
    // Calculate values of distribution dimensions
    *draw0 = distribution_index;
    return !is_empty;
}
static thread_local cumrate<453,12> om_cumrate_ImmiPoolDestination;
bool Lookup_ImmiPoolDestination(double uniform, int cond0, int cond1, int * draw0)
{
    // Calculate conditioning index
    size_t conditioning_index = 0;
    conditioning_index += cond0;
    conditioning_index *= 151;
    conditioning_index += cond1;
    // Determine if distribution is empty
    bool is_empty = om_cumrate_ImmiPoolDestination.is_degenerate(conditioning_index);
    size_t distribution_index = 0;
    if (!is_empty) {
        // Obtain value from distribution
        distribution_index = om_cumrate_ImmiPoolDestination.draw(conditioning_index, uniform);
    }
    // Calculate values of distribution dimensions
    *draw0 = distribution_index;
    return !is_empty;
}
static thread_local cumrate<26,12> om_cumrate_ImmiScratchDestination;
bool Lookup_ImmiScratchDestination(double uniform, int cond0, int cond1, int * draw0)
{
    // Calculate conditioning index
    size_t conditioning_index = 0;
    conditioning_index += cond0;
    conditioning_index *= 13;
    conditioning_index += cond1;
    // Determine if distribution is empty
    bool is_empty = om_cumrate_ImmiScratchDestination.is_degenerate(conditioning_index);
    size_t distribution_index = 0;
    if (!is_empty) {
        // Obtain value from distribution
        distribution_index = om_cumrate_ImmiScratchDestination.draw(conditioning_index, uniform);
    }
    // Calculate values of distribution dimensions
    *draw0 = distribution_index;
    return !is_empty;
}
static thread_local cumrate<312,12> om_cumrate_MigrationDestination;
bool Lookup_MigrationDestination(double uniform, int cond0, int cond1, int cond2, int * draw0)
{
    // Calculate conditioning index
    size_t conditioning_index = 0;
    conditioning_index += cond0;
    conditioning_index *= 12;
    conditioning_index += cond1;
    conditioning_index *= 13;
    conditioning_index += cond2;
    // Determine if distribution is empty
    bool is_empty = om_cumrate_MigrationDestination.is_degenerate(conditioning_index);
    size_t distribution_index = 0;
    if (!is_empty) {
        // Obtain value from distribution
        distribution_index = om_cumrate_MigrationDestination.draw(conditioning_index, uniform);
    }
    // Calculate values of distribution dimensions
    *draw0 = distribution_index;
    return !is_empty;
}
static thread_local cumrate<3,3> om_cumrate_PartnerCharacteristicDistribution;
bool Lookup_PartnerCharacteristicDistribution(double uniform, int cond0, int * draw0)
{
    // Calculate conditioning index
    size_t conditioning_index = 0;
    conditioning_index += cond0;
    // Determine if distribution is empty
    bool is_empty = om_cumrate_PartnerCharacteristicDistribution.is_degenerate(conditioning_index);
    size_t distribution_index = 0;
    if (!is_empty) {
        // Obtain value from distribution
        distribution_index = om_cumrate_PartnerCharacteristicDistribution.draw(conditioning_index, uniform);
    }
    // Calculate values of distribution dimensions
    *draw0 = distribution_index;
    return !is_empty;
}

// entity tables

thread_local PopPyramidByEduc * thePopPyramidByEduc = nullptr;

void PopPyramidByEduc::initialize_accumulators()
{
    assert(thePopPyramidByEduc); // unitary table must be instantiated

    // sum(delta(om_duration_FOR_educ_one_level_X_EOL_LOW))
    for ( int cell = 0; cell < n_cells; cell++ ) acc[0][cell] =   0.0;

    // sum(delta(om_duration_FOR_educ_one_level_X_EOL_MEDIUM))
    for ( int cell = 0; cell < n_cells; cell++ ) acc[1][cell] =   0.0;

    // sum(delta(om_duration_FOR_educ_one_level_X_EOL_HIGH))
    for ( int cell = 0; cell < n_cells; cell++ ) acc[2][cell] =   0.0;

}

void PopPyramidByEduc::extract_accumulators()
{
    assert(thePopPyramidByEduc); // unitary table must be instantiated

}

void PopPyramidByEduc::scale_accumulators()
{
    assert(thePopPyramidByEduc); // unitary table must be instantiated

    double scale_factor = population_scaling_factor();
    if (scale_factor != 1.0) {
        // sum(delta(om_duration_FOR_educ_one_level_X_EOL_LOW))
        for (int cell = 0; cell < n_cells; cell++) acc[0][cell] *= scale_factor;
        // sum(delta(om_duration_FOR_educ_one_level_X_EOL_MEDIUM))
        for (int cell = 0; cell < n_cells; cell++) acc[1][cell] *= scale_factor;
        // sum(delta(om_duration_FOR_educ_one_level_X_EOL_HIGH))
        for (int cell = 0; cell < n_cells; cell++) acc[2][cell] *= scale_factor;
    }
}

void PopPyramidByEduc::compute_expressions()
{
    assert(thePopPyramidByEduc); // unitary table must be instantiated

    for (int cell = 0; cell < n_cells; cell++ ) measure[0][cell] = acc[0][cell] ;

    for (int cell = 0; cell < n_cells; cell++ ) measure[1][cell] = acc[1][cell] ;

    for (int cell = 0; cell < n_cells; cell++ ) measure[2][cell] = acc[2][cell] ;

}


thread_local TabChildVaccination * theTabChildVaccination = nullptr;

void TabChildVaccination::initialize_accumulators()
{
    assert(theTabChildVaccination); // unitary table must be instantiated

    // sum(delta(om_duration_FOR_is_immunized_X_true))
    for ( int cell = 0; cell < n_cells; cell++ ) acc[0][cell] =   0.0;

    // sum(delta(om_duration))
    for ( int cell = 0; cell < n_cells; cell++ ) acc[1][cell] =   0.0;

}

void TabChildVaccination::extract_accumulators()
{
    assert(theTabChildVaccination); // unitary table must be instantiated

}

void TabChildVaccination::scale_accumulators()
{
    assert(theTabChildVaccination); // unitary table must be instantiated

    double scale_factor = population_scaling_factor();
    if (scale_factor != 1.0) {
        // sum(delta(om_duration_FOR_is_immunized_X_true))
        for (int cell = 0; cell < n_cells; cell++) acc[0][cell] *= scale_factor;
        // sum(delta(om_duration))
        for (int cell = 0; cell < n_cells; cell++) acc[1][cell] *= scale_factor;
    }
}

void TabChildVaccination::compute_expressions()
{
    assert(theTabChildVaccination); // unitary table must be instantiated

    for (int cell = 0; cell < n_cells; cell++ ) measure[0][cell] = ( acc[0][cell] / acc[1][cell] ) ;

}


thread_local TabEduc15ByDistrict * theTabEduc15ByDistrict = nullptr;

void TabEduc15ByDistrict::initialize_accumulators()
{
    assert(theTabEduc15ByDistrict); // unitary table must be instantiated

    // sum(delta(om_duration_FOR_educ_one_fate_X_EOL_LOW))
    for ( int cell = 0; cell < n_cells; cell++ ) acc[0][cell] =   0.0;

    // sum(delta(om_duration))
    for ( int cell = 0; cell < n_cells; cell++ ) acc[1][cell] =   0.0;

    // sum(delta(om_duration_FOR_educ_one_fate_X_EOL_MEDIUM))
    for ( int cell = 0; cell < n_cells; cell++ ) acc[2][cell] =   0.0;

    // sum(delta(om_duration_FOR_educ_one_fate_X_EOL_HIGH))
    for ( int cell = 0; cell < n_cells; cell++ ) acc[3][cell] =   0.0;

}

void TabEduc15ByDistrict::extract_accumulators()
{
    assert(theTabEduc15ByDistrict); // unitary table must be instantiated

}

void TabEduc15ByDistrict::scale_accumulators()
{
    assert(theTabEduc15ByDistrict); // unitary table must be instantiated

    double scale_factor = population_scaling_factor();
    if (scale_factor != 1.0) {
        // sum(delta(om_duration_FOR_educ_one_fate_X_EOL_LOW))
        for (int cell = 0; cell < n_cells; cell++) acc[0][cell] *= scale_factor;
        // sum(delta(om_duration))
        for (int cell = 0; cell < n_cells; cell++) acc[1][cell] *= scale_factor;
        // sum(delta(om_duration_FOR_educ_one_fate_X_EOL_MEDIUM))
        for (int cell = 0; cell < n_cells; cell++) acc[2][cell] *= scale_factor;
        // sum(delta(om_duration_FOR_educ_one_fate_X_EOL_HIGH))
        for (int cell = 0; cell < n_cells; cell++) acc[3][cell] *= scale_factor;
    }
}

void TabEduc15ByDistrict::compute_expressions()
{
    assert(theTabEduc15ByDistrict); // unitary table must be instantiated

    for (int cell = 0; cell < n_cells; cell++ ) measure[0][cell] = ( acc[0][cell] / acc[1][cell] ) ;

    for (int cell = 0; cell < n_cells; cell++ ) measure[1][cell] = ( acc[2][cell] / acc[1][cell] ) ;

    for (int cell = 0; cell < n_cells; cell++ ) measure[2][cell] = ( acc[3][cell] / acc[1][cell] ) ;

}


thread_local TabEduc15ByDistrictBirth * theTabEduc15ByDistrictBirth = nullptr;

void TabEduc15ByDistrictBirth::initialize_accumulators()
{
    assert(theTabEduc15ByDistrictBirth); // unitary table must be instantiated

    // sum(delta(om_duration_FOR_educ_one_fate_X_EOL_LOW))
    for ( int cell = 0; cell < n_cells; cell++ ) acc[0][cell] =   0.0;

    // sum(delta(om_duration))
    for ( int cell = 0; cell < n_cells; cell++ ) acc[1][cell] =   0.0;

    // sum(delta(om_duration_FOR_educ_one_fate_X_EOL_MEDIUM))
    for ( int cell = 0; cell < n_cells; cell++ ) acc[2][cell] =   0.0;

    // sum(delta(om_duration_FOR_educ_one_fate_X_EOL_HIGH))
    for ( int cell = 0; cell < n_cells; cell++ ) acc[3][cell] =   0.0;

}

void TabEduc15ByDistrictBirth::extract_accumulators()
{
    assert(theTabEduc15ByDistrictBirth); // unitary table must be instantiated

}

void TabEduc15ByDistrictBirth::scale_accumulators()
{
    assert(theTabEduc15ByDistrictBirth); // unitary table must be instantiated

    double scale_factor = population_scaling_factor();
    if (scale_factor != 1.0) {
        // sum(delta(om_duration_FOR_educ_one_fate_X_EOL_LOW))
        for (int cell = 0; cell < n_cells; cell++) acc[0][cell] *= scale_factor;
        // sum(delta(om_duration))
        for (int cell = 0; cell < n_cells; cell++) acc[1][cell] *= scale_factor;
        // sum(delta(om_duration_FOR_educ_one_fate_X_EOL_MEDIUM))
        for (int cell = 0; cell < n_cells; cell++) acc[2][cell] *= scale_factor;
        // sum(delta(om_duration_FOR_educ_one_fate_X_EOL_HIGH))
        for (int cell = 0; cell < n_cells; cell++) acc[3][cell] *= scale_factor;
    }
}

void TabEduc15ByDistrictBirth::compute_expressions()
{
    assert(theTabEduc15ByDistrictBirth); // unitary table must be instantiated

    for (int cell = 0; cell < n_cells; cell++ ) measure[0][cell] = ( acc[0][cell] / acc[1][cell] ) ;

    for (int cell = 0; cell < n_cells; cell++ ) measure[1][cell] = ( acc[2][cell] / acc[1][cell] ) ;

    for (int cell = 0; cell < n_cells; cell++ ) measure[2][cell] = ( acc[3][cell] / acc[1][cell] ) ;

}


thread_local TabEducFateByGroup * theTabEducFateByGroup = nullptr;

void TabEducFateByGroup::initialize_accumulators()
{
    assert(theTabEducFateByGroup); // unitary table must be instantiated

    // unit
    for ( int cell = 0; cell < n_cells; cell++ ) acc[0][cell] =   0.0;

}

void TabEducFateByGroup::extract_accumulators()
{
    assert(theTabEducFateByGroup); // unitary table must be instantiated

}

void TabEducFateByGroup::scale_accumulators()
{
    assert(theTabEducFateByGroup); // unitary table must be instantiated

    double scale_factor = population_scaling_factor();
    if (scale_factor != 1.0) {
        // unit
        for (int cell = 0; cell < n_cells; cell++) acc[0][cell] *= scale_factor;
    }
}

void TabEducFateByGroup::compute_expressions()
{
    assert(theTabEducFateByGroup); // unitary table must be instantiated

    for (int cell = 0; cell < n_cells; cell++ ) measure[0][cell] = acc[0][cell] ;

}


thread_local TabEducFateDistrYob * theTabEducFateDistrYob = nullptr;

void TabEducFateDistrYob::initialize_accumulators()
{
    assert(theTabEducFateDistrYob); // unitary table must be instantiated

    // unit
    for ( int cell = 0; cell < n_cells; cell++ ) acc[0][cell] =   0.0;

}

void TabEducFateDistrYob::extract_accumulators()
{
    assert(theTabEducFateDistrYob); // unitary table must be instantiated

}

void TabEducFateDistrYob::scale_accumulators()
{
    assert(theTabEducFateDistrYob); // unitary table must be instantiated

    double scale_factor = population_scaling_factor();
    if (scale_factor != 1.0) {
        // unit
        for (int cell = 0; cell < n_cells; cell++) acc[0][cell] *= scale_factor;
    }
}

void TabEducFateDistrYob::compute_expressions()
{
    assert(theTabEducFateDistrYob); // unitary table must be instantiated

    for (int cell = 0; cell < n_cells; cell++ ) measure[0][cell] = acc[0][cell] ;

}


thread_local TabHCIDistrict * theTabHCIDistrict = nullptr;

void TabHCIDistrict::initialize_accumulators()
{
    assert(theTabHCIDistrict); // unitary table must be instantiated

    // sum(delta(om_value_at_transitions_FOR_is_alive_X_true_X_is_stunted_X_false))
    for ( int cell = 0; cell < n_cells; cell++ ) acc[0][cell] =   0.0;

    // sum(delta(om_transitions_FOR_is_alive_X_true_X_false))
    for ( int cell = 0; cell < n_cells; cell++ ) acc[1][cell] =   0.0;

    // sum(delta(om_value_at_transitions_FOR_is_alive_X_true_X_survived_early_years_X_false))
    for ( int cell = 0; cell < n_cells; cell++ ) acc[2][cell] =   0.0;

    // sum(delta(om_value_at_transitions_FOR_is_alive_X_true_X_adult_survival_X_false))
    for ( int cell = 0; cell < n_cells; cell++ ) acc[3][cell] =   0.0;

    // sum(delta(om_transitions_FOR_integer_age_X_14_X_15))
    for ( int cell = 0; cell < n_cells; cell++ ) acc[4][cell] =   0.0;

    // sum(delta(om_value_at_transitions_FOR_is_alive_X_true_X_quality_of_schooling_X_false))
    for ( int cell = 0; cell < n_cells; cell++ ) acc[5][cell] =   0.0;

    // sum(delta(om_transitions_FOR_survived_early_years_X_false_X_true))
    for ( int cell = 0; cell < n_cells; cell++ ) acc[6][cell] =   0.0;

    // sum(delta(om_value_at_transitions_FOR_is_alive_X_true_X_years_of_schooling_X_false))
    for ( int cell = 0; cell < n_cells; cell++ ) acc[7][cell] =   0.0;

    // sum(delta(om_value_at_transitions_FOR_is_alive_X_true_X_ind_hci_X_false))
    for ( int cell = 0; cell < n_cells; cell++ ) acc[8][cell] =   0.0;

}

void TabHCIDistrict::extract_accumulators()
{
    assert(theTabHCIDistrict); // unitary table must be instantiated

}

void TabHCIDistrict::scale_accumulators()
{
    assert(theTabHCIDistrict); // unitary table must be instantiated

    double scale_factor = population_scaling_factor();
    if (scale_factor != 1.0) {
        // sum(delta(om_value_at_transitions_FOR_is_alive_X_true_X_is_stunted_X_false))
        for (int cell = 0; cell < n_cells; cell++) acc[0][cell] *= scale_factor;
        // sum(delta(om_transitions_FOR_is_alive_X_true_X_false))
        for (int cell = 0; cell < n_cells; cell++) acc[1][cell] *= scale_factor;
        // sum(delta(om_value_at_transitions_FOR_is_alive_X_true_X_survived_early_years_X_false))
        for (int cell = 0; cell < n_cells; cell++) acc[2][cell] *= scale_factor;
        // sum(delta(om_value_at_transitions_FOR_is_alive_X_true_X_adult_survival_X_false))
        for (int cell = 0; cell < n_cells; cell++) acc[3][cell] *= scale_factor;
        // sum(delta(om_transitions_FOR_integer_age_X_14_X_15))
        for (int cell = 0; cell < n_cells; cell++) acc[4][cell] *= scale_factor;
        // sum(delta(om_value_at_transitions_FOR_is_alive_X_true_X_quality_of_schooling_X_false))
        for (int cell = 0; cell < n_cells; cell++) acc[5][cell] *= scale_factor;
        // sum(delta(om_transitions_FOR_survived_early_years_X_false_X_true))
        for (int cell = 0; cell < n_cells; cell++) acc[6][cell] *= scale_factor;
        // sum(delta(om_value_at_transitions_FOR_is_alive_X_true_X_years_of_schooling_X_false))
        for (int cell = 0; cell < n_cells; cell++) acc[7][cell] *= scale_factor;
        // sum(delta(om_value_at_transitions_FOR_is_alive_X_true_X_ind_hci_X_false))
        for (int cell = 0; cell < n_cells; cell++) acc[8][cell] *= scale_factor;
    }
}

void TabHCIDistrict::compute_expressions()
{
    assert(theTabHCIDistrict); // unitary table must be instantiated

    for (int cell = 0; cell < n_cells; cell++ ) measure[0][cell] = ( acc[0][cell] / acc[1][cell] ) ;

    for (int cell = 0; cell < n_cells; cell++ ) measure[1][cell] = ( acc[2][cell] / acc[1][cell] ) ;

    for (int cell = 0; cell < n_cells; cell++ ) measure[2][cell] = ( acc[3][cell] / acc[4][cell] ) ;

    for (int cell = 0; cell < n_cells; cell++ ) measure[3][cell] = ( acc[5][cell] / acc[6][cell] ) ;

    for (int cell = 0; cell < n_cells; cell++ ) measure[4][cell] = ( acc[7][cell] / acc[6][cell] ) ;

    for (int cell = 0; cell < n_cells; cell++ ) measure[5][cell] = ( acc[8][cell] / acc[1][cell] ) ;

}


thread_local TabImmunizationChildren * theTabImmunizationChildren = nullptr;

void TabImmunizationChildren::initialize_accumulators()
{
    assert(theTabImmunizationChildren); // unitary table must be instantiated

    // sum(delta(om_duration_FOR_is_immunized_X_true))
    for ( int cell = 0; cell < n_cells; cell++ ) acc[0][cell] =   0.0;

    // sum(delta(om_duration))
    for ( int cell = 0; cell < n_cells; cell++ ) acc[1][cell] =   0.0;

}

void TabImmunizationChildren::extract_accumulators()
{
    assert(theTabImmunizationChildren); // unitary table must be instantiated

}

void TabImmunizationChildren::scale_accumulators()
{
    assert(theTabImmunizationChildren); // unitary table must be instantiated

    double scale_factor = population_scaling_factor();
    if (scale_factor != 1.0) {
        // sum(delta(om_duration_FOR_is_immunized_X_true))
        for (int cell = 0; cell < n_cells; cell++) acc[0][cell] *= scale_factor;
        // sum(delta(om_duration))
        for (int cell = 0; cell < n_cells; cell++) acc[1][cell] *= scale_factor;
    }
}

void TabImmunizationChildren::compute_expressions()
{
    assert(theTabImmunizationChildren); // unitary table must be instantiated

    for (int cell = 0; cell < n_cells; cell++ ) measure[0][cell] = ( acc[0][cell] / acc[1][cell] ) ;

}


thread_local TabPopProvAgeEducSex * theTabPopProvAgeEducSex = nullptr;

void TabPopProvAgeEducSex::initialize_accumulators()
{
    assert(theTabPopProvAgeEducSex); // unitary table must be instantiated

    // sum(delta(om_duration_FOR_is_child_X_true))
    for ( int cell = 0; cell < n_cells; cell++ ) acc[0][cell] =   0.0;

    // sum(delta(om_duration_FOR_is_aded0_X_true))
    for ( int cell = 0; cell < n_cells; cell++ ) acc[1][cell] =   0.0;

    // sum(delta(om_duration_FOR_is_aded1_X_true))
    for ( int cell = 0; cell < n_cells; cell++ ) acc[2][cell] =   0.0;

    // sum(delta(om_duration_FOR_is_aded2_X_true))
    for ( int cell = 0; cell < n_cells; cell++ ) acc[3][cell] =   0.0;

    // sum(delta(om_duration_FOR_is_old_X_true))
    for ( int cell = 0; cell < n_cells; cell++ ) acc[4][cell] =   0.0;

}

void TabPopProvAgeEducSex::extract_accumulators()
{
    assert(theTabPopProvAgeEducSex); // unitary table must be instantiated

}

void TabPopProvAgeEducSex::scale_accumulators()
{
    assert(theTabPopProvAgeEducSex); // unitary table must be instantiated

    double scale_factor = population_scaling_factor();
    if (scale_factor != 1.0) {
        // sum(delta(om_duration_FOR_is_child_X_true))
        for (int cell = 0; cell < n_cells; cell++) acc[0][cell] *= scale_factor;
        // sum(delta(om_duration_FOR_is_aded0_X_true))
        for (int cell = 0; cell < n_cells; cell++) acc[1][cell] *= scale_factor;
        // sum(delta(om_duration_FOR_is_aded1_X_true))
        for (int cell = 0; cell < n_cells; cell++) acc[2][cell] *= scale_factor;
        // sum(delta(om_duration_FOR_is_aded2_X_true))
        for (int cell = 0; cell < n_cells; cell++) acc[3][cell] *= scale_factor;
        // sum(delta(om_duration_FOR_is_old_X_true))
        for (int cell = 0; cell < n_cells; cell++) acc[4][cell] *= scale_factor;
    }
}

void TabPopProvAgeEducSex::compute_expressions()
{
    assert(theTabPopProvAgeEducSex); // unitary table must be instantiated

    for (int cell = 0; cell < n_cells; cell++ ) measure[0][cell] = acc[0][cell] ;

    for (int cell = 0; cell < n_cells; cell++ ) measure[1][cell] = acc[1][cell] ;

    for (int cell = 0; cell < n_cells; cell++ ) measure[2][cell] = acc[2][cell] ;

    for (int cell = 0; cell < n_cells; cell++ ) measure[3][cell] = acc[3][cell] ;

    for (int cell = 0; cell < n_cells; cell++ ) measure[4][cell] = acc[4][cell] ;

}


thread_local TabPrenatCare * theTabPrenatCare = nullptr;

void TabPrenatCare::initialize_accumulators()
{
    assert(theTabPrenatCare); // unitary table must be instantiated

    // sum(delta(om_duration_FOR_got_prenat_care_X_GPC_YES))
    for ( int cell = 0; cell < n_cells; cell++ ) acc[0][cell] =   0.0;

    // sum(delta(om_duration))
    for ( int cell = 0; cell < n_cells; cell++ ) acc[1][cell] =   0.0;

}

void TabPrenatCare::extract_accumulators()
{
    assert(theTabPrenatCare); // unitary table must be instantiated

}

void TabPrenatCare::scale_accumulators()
{
    assert(theTabPrenatCare); // unitary table must be instantiated

    double scale_factor = population_scaling_factor();
    if (scale_factor != 1.0) {
        // sum(delta(om_duration_FOR_got_prenat_care_X_GPC_YES))
        for (int cell = 0; cell < n_cells; cell++) acc[0][cell] *= scale_factor;
        // sum(delta(om_duration))
        for (int cell = 0; cell < n_cells; cell++) acc[1][cell] *= scale_factor;
    }
}

void TabPrenatCare::compute_expressions()
{
    assert(theTabPrenatCare); // unitary table must be instantiated

    for (int cell = 0; cell < n_cells; cell++ ) measure[0][cell] = ( acc[0][cell] / acc[1][cell] ) ;

}


thread_local TabPrimSchoolEntries * theTabPrimSchoolEntries = nullptr;

void TabPrimSchoolEntries::initialize_accumulators()
{
    assert(theTabPrimSchoolEntries); // unitary table must be instantiated

    // sum(delta(om_entrances_FOR_educ_one_grade_attended_X_1))
    for ( int cell = 0; cell < n_cells; cell++ ) acc[0][cell] =   0.0;

}

void TabPrimSchoolEntries::extract_accumulators()
{
    assert(theTabPrimSchoolEntries); // unitary table must be instantiated

}

void TabPrimSchoolEntries::scale_accumulators()
{
    assert(theTabPrimSchoolEntries); // unitary table must be instantiated

    double scale_factor = population_scaling_factor();
    if (scale_factor != 1.0) {
        // sum(delta(om_entrances_FOR_educ_one_grade_attended_X_1))
        for (int cell = 0; cell < n_cells; cell++) acc[0][cell] *= scale_factor;
    }
}

void TabPrimSchoolEntries::compute_expressions()
{
    assert(theTabPrimSchoolEntries); // unitary table must be instantiated

    for (int cell = 0; cell < n_cells; cell++ ) measure[0][cell] = acc[0][cell] ;

}


thread_local TabPrimSchoolGraduations * theTabPrimSchoolGraduations = nullptr;

void TabPrimSchoolGraduations::initialize_accumulators()
{
    assert(theTabPrimSchoolGraduations); // unitary table must be instantiated

    // sum(delta(om_entrances_FOR_has_passed_primary_X_true))
    for ( int cell = 0; cell < n_cells; cell++ ) acc[0][cell] =   0.0;

}

void TabPrimSchoolGraduations::extract_accumulators()
{
    assert(theTabPrimSchoolGraduations); // unitary table must be instantiated

}

void TabPrimSchoolGraduations::scale_accumulators()
{
    assert(theTabPrimSchoolGraduations); // unitary table must be instantiated

    double scale_factor = population_scaling_factor();
    if (scale_factor != 1.0) {
        // sum(delta(om_entrances_FOR_has_passed_primary_X_true))
        for (int cell = 0; cell < n_cells; cell++) acc[0][cell] *= scale_factor;
    }
}

void TabPrimSchoolGraduations::compute_expressions()
{
    assert(theTabPrimSchoolGraduations); // unitary table must be instantiated

    for (int cell = 0; cell < n_cells; cell++ ) measure[0][cell] = acc[0][cell] ;

}


thread_local TabPrimSchoolOutOfSchool9to11 * theTabPrimSchoolOutOfSchool9to11 = nullptr;

void TabPrimSchoolOutOfSchool9to11::initialize_accumulators()
{
    assert(theTabPrimSchoolOutOfSchool9to11); // unitary table must be instantiated

    // sum(delta(om_duration_FOR_tab_out_of_primary_X_true))
    for ( int cell = 0; cell < n_cells; cell++ ) acc[0][cell] =   0.0;

    // sum(delta(om_duration))
    for ( int cell = 0; cell < n_cells; cell++ ) acc[1][cell] =   0.0;

}

void TabPrimSchoolOutOfSchool9to11::extract_accumulators()
{
    assert(theTabPrimSchoolOutOfSchool9to11); // unitary table must be instantiated

}

void TabPrimSchoolOutOfSchool9to11::scale_accumulators()
{
    assert(theTabPrimSchoolOutOfSchool9to11); // unitary table must be instantiated

    double scale_factor = population_scaling_factor();
    if (scale_factor != 1.0) {
        // sum(delta(om_duration_FOR_tab_out_of_primary_X_true))
        for (int cell = 0; cell < n_cells; cell++) acc[0][cell] *= scale_factor;
        // sum(delta(om_duration))
        for (int cell = 0; cell < n_cells; cell++) acc[1][cell] *= scale_factor;
    }
}

void TabPrimSchoolOutOfSchool9to11::compute_expressions()
{
    assert(theTabPrimSchoolOutOfSchool9to11); // unitary table must be instantiated

    for (int cell = 0; cell < n_cells; cell++ ) measure[0][cell] = ( acc[0][cell] / acc[1][cell] ) ;

}


thread_local TabPrimarySchoolPlanning * theTabPrimarySchoolPlanning = nullptr;

void TabPrimarySchoolPlanning::initialize_accumulators()
{
    assert(theTabPrimarySchoolPlanning); // unitary table must be instantiated

    // unit
    for ( int cell = 0; cell < n_cells; cell++ ) acc[0][cell] =   0.0;

    // sum(value_out(educ_one_required_teachers))
    for ( int cell = 0; cell < n_cells; cell++ ) acc[1][cell] =   0.0;

    // sum(value_out(educ_one_required_rooms))
    for ( int cell = 0; cell < n_cells; cell++ ) acc[2][cell] =   0.0;

}

void TabPrimarySchoolPlanning::extract_accumulators()
{
    assert(theTabPrimarySchoolPlanning); // unitary table must be instantiated

}

void TabPrimarySchoolPlanning::scale_accumulators()
{
    assert(theTabPrimarySchoolPlanning); // unitary table must be instantiated

    double scale_factor = population_scaling_factor();
    if (scale_factor != 1.0) {
        // unit
        for (int cell = 0; cell < n_cells; cell++) acc[0][cell] *= scale_factor;
        // sum(value_out(educ_one_required_teachers))
        for (int cell = 0; cell < n_cells; cell++) acc[1][cell] *= scale_factor;
        // sum(value_out(educ_one_required_rooms))
        for (int cell = 0; cell < n_cells; cell++) acc[2][cell] *= scale_factor;
    }
}

void TabPrimarySchoolPlanning::compute_expressions()
{
    assert(theTabPrimarySchoolPlanning); // unitary table must be instantiated

    for (int cell = 0; cell < n_cells; cell++ ) measure[0][cell] = acc[0][cell] ;

    for (int cell = 0; cell < n_cells; cell++ ) measure[1][cell] = acc[1][cell] ;

    for (int cell = 0; cell < n_cells; cell++ ) measure[2][cell] = acc[2][cell] ;

}


thread_local TabSchool2AttainmentsTab * theTabSchool2AttainmentsTab = nullptr;

void TabSchool2AttainmentsTab::initialize_accumulators()
{
    assert(theTabSchool2AttainmentsTab); // unitary table must be instantiated

    // sum(delta(om_duration_FOR_educ_two_level_X_ETL_NEVER))
    for ( int cell = 0; cell < n_cells; cell++ ) acc[0][cell] =   0.0;

    // sum(delta(om_duration))
    for ( int cell = 0; cell < n_cells; cell++ ) acc[1][cell] =   0.0;

    // sum(delta(om_duration_FOR_educ_two_level_X_ETL_INCOMPLETE))
    for ( int cell = 0; cell < n_cells; cell++ ) acc[2][cell] =   0.0;

    // sum(delta(om_duration_FOR_educ_two_level_X_ETL_GRADUATE))
    for ( int cell = 0; cell < n_cells; cell++ ) acc[3][cell] =   0.0;

}

void TabSchool2AttainmentsTab::extract_accumulators()
{
    assert(theTabSchool2AttainmentsTab); // unitary table must be instantiated

}

void TabSchool2AttainmentsTab::scale_accumulators()
{
    assert(theTabSchool2AttainmentsTab); // unitary table must be instantiated

    double scale_factor = population_scaling_factor();
    if (scale_factor != 1.0) {
        // sum(delta(om_duration_FOR_educ_two_level_X_ETL_NEVER))
        for (int cell = 0; cell < n_cells; cell++) acc[0][cell] *= scale_factor;
        // sum(delta(om_duration))
        for (int cell = 0; cell < n_cells; cell++) acc[1][cell] *= scale_factor;
        // sum(delta(om_duration_FOR_educ_two_level_X_ETL_INCOMPLETE))
        for (int cell = 0; cell < n_cells; cell++) acc[2][cell] *= scale_factor;
        // sum(delta(om_duration_FOR_educ_two_level_X_ETL_GRADUATE))
        for (int cell = 0; cell < n_cells; cell++) acc[3][cell] *= scale_factor;
    }
}

void TabSchool2AttainmentsTab::compute_expressions()
{
    assert(theTabSchool2AttainmentsTab); // unitary table must be instantiated

    for (int cell = 0; cell < n_cells; cell++ ) measure[0][cell] = ( acc[0][cell] / acc[1][cell] ) ;

    for (int cell = 0; cell < n_cells; cell++ ) measure[1][cell] = ( acc[2][cell] / acc[1][cell] ) ;

    for (int cell = 0; cell < n_cells; cell++ ) measure[2][cell] = ( acc[3][cell] / acc[1][cell] ) ;

}


thread_local TabSchool2TrackTab * theTabSchool2TrackTab = nullptr;

void TabSchool2TrackTab::initialize_accumulators()
{
    assert(theTabSchool2TrackTab); // unitary table must be instantiated

    // unit
    for ( int cell = 0; cell < n_cells; cell++ ) acc[0][cell] =   0.0;

}

void TabSchool2TrackTab::extract_accumulators()
{
    assert(theTabSchool2TrackTab); // unitary table must be instantiated

}

void TabSchool2TrackTab::scale_accumulators()
{
    assert(theTabSchool2TrackTab); // unitary table must be instantiated

    double scale_factor = population_scaling_factor();
    if (scale_factor != 1.0) {
        // unit
        for (int cell = 0; cell < n_cells; cell++) acc[0][cell] *= scale_factor;
    }
}

void TabSchool2TrackTab::compute_expressions()
{
    assert(theTabSchool2TrackTab); // unitary table must be instantiated

    for (int cell = 0; cell < n_cells; cell++ ) measure[0][cell] = acc[0][cell] ;

}


thread_local tabBirthsYearPlace * thetabBirthsYearPlace = nullptr;

void tabBirthsYearPlace::initialize_accumulators()
{
    assert(thetabBirthsYearPlace); // unitary table must be instantiated

    // sum(delta(om_transitions_FOR_is_alive_X_false_X_true))
    for ( int cell = 0; cell < n_cells; cell++ ) acc[0][cell] =   0.0;

}

void tabBirthsYearPlace::extract_accumulators()
{
    assert(thetabBirthsYearPlace); // unitary table must be instantiated

}

void tabBirthsYearPlace::scale_accumulators()
{
    assert(thetabBirthsYearPlace); // unitary table must be instantiated

    double scale_factor = population_scaling_factor();
    if (scale_factor != 1.0) {
        // sum(delta(om_transitions_FOR_is_alive_X_false_X_true))
        for (int cell = 0; cell < n_cells; cell++) acc[0][cell] *= scale_factor;
    }
}

void tabBirthsYearPlace::compute_expressions()
{
    assert(thetabBirthsYearPlace); // unitary table must be instantiated

    for (int cell = 0; cell < n_cells; cell++ ) measure[0][cell] = acc[0][cell] ;

}


thread_local tabEducationFateGeobirYob * thetabEducationFateGeobirYob = nullptr;

void tabEducationFateGeobirYob::initialize_accumulators()
{
    assert(thetabEducationFateGeobirYob); // unitary table must be instantiated

    // sum(delta(om_duration_FOR_educ_one_fate_X_EOL_LOW))
    for ( int cell = 0; cell < n_cells; cell++ ) acc[0][cell] =   0.0;

    // sum(delta(om_duration))
    for ( int cell = 0; cell < n_cells; cell++ ) acc[1][cell] =   0.0;

    // sum(delta(om_duration_FOR_educ_one_fate_X_EOL_MEDIUM))
    for ( int cell = 0; cell < n_cells; cell++ ) acc[2][cell] =   0.0;

    // sum(delta(om_duration_FOR_educ_one_fate_X_EOL_HIGH))
    for ( int cell = 0; cell < n_cells; cell++ ) acc[3][cell] =   0.0;

}

void tabEducationFateGeobirYob::extract_accumulators()
{
    assert(thetabEducationFateGeobirYob); // unitary table must be instantiated

}

void tabEducationFateGeobirYob::scale_accumulators()
{
    assert(thetabEducationFateGeobirYob); // unitary table must be instantiated

    double scale_factor = population_scaling_factor();
    if (scale_factor != 1.0) {
        // sum(delta(om_duration_FOR_educ_one_fate_X_EOL_LOW))
        for (int cell = 0; cell < n_cells; cell++) acc[0][cell] *= scale_factor;
        // sum(delta(om_duration))
        for (int cell = 0; cell < n_cells; cell++) acc[1][cell] *= scale_factor;
        // sum(delta(om_duration_FOR_educ_one_fate_X_EOL_MEDIUM))
        for (int cell = 0; cell < n_cells; cell++) acc[2][cell] *= scale_factor;
        // sum(delta(om_duration_FOR_educ_one_fate_X_EOL_HIGH))
        for (int cell = 0; cell < n_cells; cell++) acc[3][cell] *= scale_factor;
    }
}

void tabEducationFateGeobirYob::compute_expressions()
{
    assert(thetabEducationFateGeobirYob); // unitary table must be instantiated

    for (int cell = 0; cell < n_cells; cell++ ) measure[0][cell] = ( acc[0][cell] / acc[1][cell] ) ;

    for (int cell = 0; cell < n_cells; cell++ ) measure[1][cell] = ( acc[2][cell] / acc[1][cell] ) ;

    for (int cell = 0; cell < n_cells; cell++ ) measure[2][cell] = ( acc[3][cell] / acc[1][cell] ) ;

}


thread_local tabHCI * thetabHCI = nullptr;

void tabHCI::initialize_accumulators()
{
    assert(thetabHCI); // unitary table must be instantiated

    // sum(delta(om_value_at_transitions_FOR_is_alive_X_true_X_is_stunted_X_false))
    for ( int cell = 0; cell < n_cells; cell++ ) acc[0][cell] =   0.0;

    // sum(delta(om_transitions_FOR_is_alive_X_true_X_false))
    for ( int cell = 0; cell < n_cells; cell++ ) acc[1][cell] =   0.0;

    // sum(delta(om_value_at_transitions_FOR_is_alive_X_true_X_survived_early_years_X_false))
    for ( int cell = 0; cell < n_cells; cell++ ) acc[2][cell] =   0.0;

    // sum(delta(om_value_at_transitions_FOR_is_alive_X_true_X_adult_survival_X_false))
    for ( int cell = 0; cell < n_cells; cell++ ) acc[3][cell] =   0.0;

    // sum(delta(om_transitions_FOR_integer_age_X_14_X_15))
    for ( int cell = 0; cell < n_cells; cell++ ) acc[4][cell] =   0.0;

    // sum(delta(om_value_at_transitions_FOR_is_alive_X_true_X_quality_of_schooling_X_false))
    for ( int cell = 0; cell < n_cells; cell++ ) acc[5][cell] =   0.0;

    // sum(delta(om_transitions_FOR_survived_early_years_X_false_X_true))
    for ( int cell = 0; cell < n_cells; cell++ ) acc[6][cell] =   0.0;

    // sum(delta(om_value_at_transitions_FOR_is_alive_X_true_X_years_of_schooling_X_false))
    for ( int cell = 0; cell < n_cells; cell++ ) acc[7][cell] =   0.0;

    // sum(delta(om_value_at_transitions_FOR_is_alive_X_true_X_ind_hci_X_false))
    for ( int cell = 0; cell < n_cells; cell++ ) acc[8][cell] =   0.0;

}

void tabHCI::extract_accumulators()
{
    assert(thetabHCI); // unitary table must be instantiated

}

void tabHCI::scale_accumulators()
{
    assert(thetabHCI); // unitary table must be instantiated

    double scale_factor = population_scaling_factor();
    if (scale_factor != 1.0) {
        // sum(delta(om_value_at_transitions_FOR_is_alive_X_true_X_is_stunted_X_false))
        for (int cell = 0; cell < n_cells; cell++) acc[0][cell] *= scale_factor;
        // sum(delta(om_transitions_FOR_is_alive_X_true_X_false))
        for (int cell = 0; cell < n_cells; cell++) acc[1][cell] *= scale_factor;
        // sum(delta(om_value_at_transitions_FOR_is_alive_X_true_X_survived_early_years_X_false))
        for (int cell = 0; cell < n_cells; cell++) acc[2][cell] *= scale_factor;
        // sum(delta(om_value_at_transitions_FOR_is_alive_X_true_X_adult_survival_X_false))
        for (int cell = 0; cell < n_cells; cell++) acc[3][cell] *= scale_factor;
        // sum(delta(om_transitions_FOR_integer_age_X_14_X_15))
        for (int cell = 0; cell < n_cells; cell++) acc[4][cell] *= scale_factor;
        // sum(delta(om_value_at_transitions_FOR_is_alive_X_true_X_quality_of_schooling_X_false))
        for (int cell = 0; cell < n_cells; cell++) acc[5][cell] *= scale_factor;
        // sum(delta(om_transitions_FOR_survived_early_years_X_false_X_true))
        for (int cell = 0; cell < n_cells; cell++) acc[6][cell] *= scale_factor;
        // sum(delta(om_value_at_transitions_FOR_is_alive_X_true_X_years_of_schooling_X_false))
        for (int cell = 0; cell < n_cells; cell++) acc[7][cell] *= scale_factor;
        // sum(delta(om_value_at_transitions_FOR_is_alive_X_true_X_ind_hci_X_false))
        for (int cell = 0; cell < n_cells; cell++) acc[8][cell] *= scale_factor;
    }
}

void tabHCI::compute_expressions()
{
    assert(thetabHCI); // unitary table must be instantiated

    for (int cell = 0; cell < n_cells; cell++ ) measure[0][cell] = ( acc[0][cell] / acc[1][cell] ) ;

    for (int cell = 0; cell < n_cells; cell++ ) measure[1][cell] = ( acc[2][cell] / acc[1][cell] ) ;

    for (int cell = 0; cell < n_cells; cell++ ) measure[2][cell] = ( acc[3][cell] / acc[4][cell] ) ;

    for (int cell = 0; cell < n_cells; cell++ ) measure[3][cell] = ( acc[5][cell] / acc[6][cell] ) ;

    for (int cell = 0; cell < n_cells; cell++ ) measure[4][cell] = ( acc[7][cell] / acc[6][cell] ) ;

    for (int cell = 0; cell < n_cells; cell++ ) measure[5][cell] = ( acc[8][cell] / acc[1][cell] ) ;

}


thread_local tabHavingSpouse * thetabHavingSpouse = nullptr;

void tabHavingSpouse::initialize_accumulators()
{
    assert(thetabHavingSpouse); // unitary table must be instantiated

    // sum(delta(om_duration_FOR_has_spouse_X_true))
    for ( int cell = 0; cell < n_cells; cell++ ) acc[0][cell] =   0.0;

    // sum(delta(om_duration))
    for ( int cell = 0; cell < n_cells; cell++ ) acc[1][cell] =   0.0;

    // sum(delta(om_duration_FOR_ever_union_X_true))
    for ( int cell = 0; cell < n_cells; cell++ ) acc[2][cell] =   0.0;

}

void tabHavingSpouse::extract_accumulators()
{
    assert(thetabHavingSpouse); // unitary table must be instantiated

}

void tabHavingSpouse::scale_accumulators()
{
    assert(thetabHavingSpouse); // unitary table must be instantiated

    double scale_factor = population_scaling_factor();
    if (scale_factor != 1.0) {
        // sum(delta(om_duration_FOR_has_spouse_X_true))
        for (int cell = 0; cell < n_cells; cell++) acc[0][cell] *= scale_factor;
        // sum(delta(om_duration))
        for (int cell = 0; cell < n_cells; cell++) acc[1][cell] *= scale_factor;
        // sum(delta(om_duration_FOR_ever_union_X_true))
        for (int cell = 0; cell < n_cells; cell++) acc[2][cell] *= scale_factor;
    }
}

void tabHavingSpouse::compute_expressions()
{
    assert(thetabHavingSpouse); // unitary table must be instantiated

    for (int cell = 0; cell < n_cells; cell++ ) measure[0][cell] = ( acc[0][cell] / acc[1][cell] ) ;

    for (int cell = 0; cell < n_cells; cell++ ) measure[1][cell] = ( acc[2][cell] / acc[1][cell] ) ;

}


thread_local tabMigrationOriginDestination * thetabMigrationOriginDestination = nullptr;

void tabMigrationOriginDestination::initialize_accumulators()
{
    assert(thetabMigrationOriginDestination); // unitary table must be instantiated

    // sum(value_in(is_alive))
    for ( int cell = 0; cell < n_cells; cell++ ) acc[0][cell] =   0.0;

}

void tabMigrationOriginDestination::extract_accumulators()
{
    assert(thetabMigrationOriginDestination); // unitary table must be instantiated

}

void tabMigrationOriginDestination::scale_accumulators()
{
    assert(thetabMigrationOriginDestination); // unitary table must be instantiated

    double scale_factor = population_scaling_factor();
    if (scale_factor != 1.0) {
        // sum(value_in(is_alive))
        for (int cell = 0; cell < n_cells; cell++) acc[0][cell] *= scale_factor;
    }
}

void tabMigrationOriginDestination::compute_expressions()
{
    assert(thetabMigrationOriginDestination); // unitary table must be instantiated

    for (int cell = 0; cell < n_cells; cell++ ) measure[0][cell] = acc[0][cell] ;

}


thread_local tabPopulationYearPlace * thetabPopulationYearPlace = nullptr;

void tabPopulationYearPlace::initialize_accumulators()
{
    assert(thetabPopulationYearPlace); // unitary table must be instantiated

    // sum(delta(om_duration))
    for ( int cell = 0; cell < n_cells; cell++ ) acc[0][cell] =   0.0;

}

void tabPopulationYearPlace::extract_accumulators()
{
    assert(thetabPopulationYearPlace); // unitary table must be instantiated

}

void tabPopulationYearPlace::scale_accumulators()
{
    assert(thetabPopulationYearPlace); // unitary table must be instantiated

    double scale_factor = population_scaling_factor();
    if (scale_factor != 1.0) {
        // sum(delta(om_duration))
        for (int cell = 0; cell < n_cells; cell++) acc[0][cell] *= scale_factor;
    }
}

void tabPopulationYearPlace::compute_expressions()
{
    assert(thetabPopulationYearPlace); // unitary table must be instantiated

    for (int cell = 0; cell < n_cells; cell++ ) measure[0][cell] = acc[0][cell] ;

}


thread_local tabPreSchool * thetabPreSchool = nullptr;

void tabPreSchool::initialize_accumulators()
{
    assert(thetabPreSchool); // unitary table must be instantiated

    // sum(delta(om_duration_FOR_years_preschool_X_0))
    for ( int cell = 0; cell < n_cells; cell++ ) acc[0][cell] =   0.0;

    // sum(delta(om_duration))
    for ( int cell = 0; cell < n_cells; cell++ ) acc[1][cell] =   0.0;

    // sum(delta(om_duration_FOR_years_preschool_X_1))
    for ( int cell = 0; cell < n_cells; cell++ ) acc[2][cell] =   0.0;

    // sum(delta(om_duration_FOR_years_preschool_X_2))
    for ( int cell = 0; cell < n_cells; cell++ ) acc[3][cell] =   0.0;

}

void tabPreSchool::extract_accumulators()
{
    assert(thetabPreSchool); // unitary table must be instantiated

}

void tabPreSchool::scale_accumulators()
{
    assert(thetabPreSchool); // unitary table must be instantiated

    double scale_factor = population_scaling_factor();
    if (scale_factor != 1.0) {
        // sum(delta(om_duration_FOR_years_preschool_X_0))
        for (int cell = 0; cell < n_cells; cell++) acc[0][cell] *= scale_factor;
        // sum(delta(om_duration))
        for (int cell = 0; cell < n_cells; cell++) acc[1][cell] *= scale_factor;
        // sum(delta(om_duration_FOR_years_preschool_X_1))
        for (int cell = 0; cell < n_cells; cell++) acc[2][cell] *= scale_factor;
        // sum(delta(om_duration_FOR_years_preschool_X_2))
        for (int cell = 0; cell < n_cells; cell++) acc[3][cell] *= scale_factor;
    }
}

void tabPreSchool::compute_expressions()
{
    assert(thetabPreSchool); // unitary table must be instantiated

    for (int cell = 0; cell < n_cells; cell++ ) measure[0][cell] = ( acc[0][cell] / acc[1][cell] ) ;

    for (int cell = 0; cell < n_cells; cell++ ) measure[1][cell] = ( acc[2][cell] / acc[1][cell] ) ;

    for (int cell = 0; cell < n_cells; cell++ ) measure[2][cell] = ( acc[3][cell] / acc[1][cell] ) ;

}


thread_local tabStuntingSexRegMotherYob * thetabStuntingSexRegMotherYob = nullptr;

void tabStuntingSexRegMotherYob::initialize_accumulators()
{
    assert(thetabStuntingSexRegMotherYob); // unitary table must be instantiated

    // sum(value_in(is_stunted))
    for ( int cell = 0; cell < n_cells; cell++ ) acc[0][cell] =   0.0;

    // unit
    for ( int cell = 0; cell < n_cells; cell++ ) acc[1][cell] =   0.0;

}

void tabStuntingSexRegMotherYob::extract_accumulators()
{
    assert(thetabStuntingSexRegMotherYob); // unitary table must be instantiated

}

void tabStuntingSexRegMotherYob::scale_accumulators()
{
    assert(thetabStuntingSexRegMotherYob); // unitary table must be instantiated

    double scale_factor = population_scaling_factor();
    if (scale_factor != 1.0) {
        // sum(value_in(is_stunted))
        for (int cell = 0; cell < n_cells; cell++) acc[0][cell] *= scale_factor;
        // unit
        for (int cell = 0; cell < n_cells; cell++) acc[1][cell] *= scale_factor;
    }
}

void tabStuntingSexRegMotherYob::compute_expressions()
{
    assert(thetabStuntingSexRegMotherYob); // unitary table must be instantiated

    for (int cell = 0; cell < n_cells; cell++ ) measure[0][cell] = ( acc[0][cell] / acc[1][cell] ) ;

}


thread_local tabStuntingSexRegYob * thetabStuntingSexRegYob = nullptr;

void tabStuntingSexRegYob::initialize_accumulators()
{
    assert(thetabStuntingSexRegYob); // unitary table must be instantiated

    // sum(value_in(is_stunted))
    for ( int cell = 0; cell < n_cells; cell++ ) acc[0][cell] =   0.0;

    // unit
    for ( int cell = 0; cell < n_cells; cell++ ) acc[1][cell] =   0.0;

}

void tabStuntingSexRegYob::extract_accumulators()
{
    assert(thetabStuntingSexRegYob); // unitary table must be instantiated

}

void tabStuntingSexRegYob::scale_accumulators()
{
    assert(thetabStuntingSexRegYob); // unitary table must be instantiated

    double scale_factor = population_scaling_factor();
    if (scale_factor != 1.0) {
        // sum(value_in(is_stunted))
        for (int cell = 0; cell < n_cells; cell++) acc[0][cell] *= scale_factor;
        // unit
        for (int cell = 0; cell < n_cells; cell++) acc[1][cell] *= scale_factor;
    }
}

void tabStuntingSexRegYob::compute_expressions()
{
    assert(thetabStuntingSexRegYob); // unitary table must be instantiated

    for (int cell = 0; cell < n_cells; cell++ ) measure[0][cell] = ( acc[0][cell] / acc[1][cell] ) ;

}

// derived tables

const std::map<std::string, std::pair<int, int>> om_table_measure = {
    {"PopPyramidByEduc.Expr0", {0, 0} },
    {"PopPyramidByEduc.Expr1", {0, 1} },
    {"PopPyramidByEduc.Expr2", {0, 2} },
    {"TabChildVaccination.Expr0", {1, 0} },
    {"TabEduc15ByDistrict.Expr0", {2, 0} },
    {"TabEduc15ByDistrict.Expr1", {2, 1} },
    {"TabEduc15ByDistrict.Expr2", {2, 2} },
    {"TabEduc15ByDistrictBirth.Expr0", {3, 0} },
    {"TabEduc15ByDistrictBirth.Expr1", {3, 1} },
    {"TabEduc15ByDistrictBirth.Expr2", {3, 2} },
    {"TabEducFateByGroup.Expr0", {4, 0} },
    {"TabEducFateDistrYob.Expr0", {5, 0} },
    {"TabHCIDistrict.Expr0", {6, 0} },
    {"TabHCIDistrict.Expr1", {6, 1} },
    {"TabHCIDistrict.Expr2", {6, 2} },
    {"TabHCIDistrict.Expr3", {6, 3} },
    {"TabHCIDistrict.Expr4", {6, 4} },
    {"TabHCIDistrict.Expr5", {6, 5} },
    {"TabImmunizationChildren.Expr0", {7, 0} },
    {"TabPopProvAgeEducSex.Expr0", {8, 0} },
    {"TabPopProvAgeEducSex.Expr1", {8, 1} },
    {"TabPopProvAgeEducSex.Expr2", {8, 2} },
    {"TabPopProvAgeEducSex.Expr3", {8, 3} },
    {"TabPopProvAgeEducSex.Expr4", {8, 4} },
    {"TabPrenatCare.Expr0", {9, 0} },
    {"TabPrimSchoolEntries.Expr0", {10, 0} },
    {"TabPrimSchoolGraduations.Expr0", {11, 0} },
    {"TabPrimSchoolOutOfSchool9to11.Expr0", {12, 0} },
    {"TabPrimarySchoolPlanning.Expr0", {13, 0} },
    {"TabPrimarySchoolPlanning.Expr1", {13, 1} },
    {"TabPrimarySchoolPlanning.Expr2", {13, 2} },
    {"TabSchool2AttainmentsTab.Expr0", {14, 0} },
    {"TabSchool2AttainmentsTab.Expr1", {14, 1} },
    {"TabSchool2AttainmentsTab.Expr2", {14, 2} },
    {"TabSchool2TrackTab.Expr0", {15, 0} },
    {"tabBirthsYearPlace.Expr0", {16, 0} },
    {"tabEducationFateGeobirYob.Expr0", {17, 0} },
    {"tabEducationFateGeobirYob.Expr1", {17, 1} },
    {"tabEducationFateGeobirYob.Expr2", {17, 2} },
    {"tabHCI.Expr0", {18, 0} },
    {"tabHCI.Expr1", {18, 1} },
    {"tabHCI.Expr2", {18, 2} },
    {"tabHCI.Expr3", {18, 3} },
    {"tabHCI.Expr4", {18, 4} },
    {"tabHCI.Expr5", {18, 5} },
    {"tabHavingSpouse.Expr0", {19, 0} },
    {"tabHavingSpouse.Expr1", {19, 1} },
    {"tabMigrationOriginDestination.Expr0", {20, 0} },
    {"tabPopulationYearPlace.Expr0", {21, 0} },
    {"tabPreSchool.Expr0", {22, 0} },
    {"tabPreSchool.Expr1", {22, 1} },
    {"tabPreSchool.Expr2", {22, 2} },
    {"tabStuntingSexRegMotherYob.Expr0", {23, 0} },
    {"tabStuntingSexRegYob.Expr0", {24, 0} },
};

double * om_get_table_measure_address(int table_id, int measure_id, std::vector<int> indices)
{
    switch (table_id) {
        case 0: return thePopPyramidByEduc ? thePopPyramidByEduc->get_measure_address(measure_id, indices) : nullptr;
        case 1: return theTabChildVaccination ? theTabChildVaccination->get_measure_address(measure_id, indices) : nullptr;
        case 2: return theTabEduc15ByDistrict ? theTabEduc15ByDistrict->get_measure_address(measure_id, indices) : nullptr;
        case 3: return theTabEduc15ByDistrictBirth ? theTabEduc15ByDistrictBirth->get_measure_address(measure_id, indices) : nullptr;
        case 4: return theTabEducFateByGroup ? theTabEducFateByGroup->get_measure_address(measure_id, indices) : nullptr;
        case 5: return theTabEducFateDistrYob ? theTabEducFateDistrYob->get_measure_address(measure_id, indices) : nullptr;
        case 6: return theTabHCIDistrict ? theTabHCIDistrict->get_measure_address(measure_id, indices) : nullptr;
        case 7: return theTabImmunizationChildren ? theTabImmunizationChildren->get_measure_address(measure_id, indices) : nullptr;
        case 8: return theTabPopProvAgeEducSex ? theTabPopProvAgeEducSex->get_measure_address(measure_id, indices) : nullptr;
        case 9: return theTabPrenatCare ? theTabPrenatCare->get_measure_address(measure_id, indices) : nullptr;
        case 10: return theTabPrimSchoolEntries ? theTabPrimSchoolEntries->get_measure_address(measure_id, indices) : nullptr;
        case 11: return theTabPrimSchoolGraduations ? theTabPrimSchoolGraduations->get_measure_address(measure_id, indices) : nullptr;
        case 12: return theTabPrimSchoolOutOfSchool9to11 ? theTabPrimSchoolOutOfSchool9to11->get_measure_address(measure_id, indices) : nullptr;
        case 13: return theTabPrimarySchoolPlanning ? theTabPrimarySchoolPlanning->get_measure_address(measure_id, indices) : nullptr;
        case 14: return theTabSchool2AttainmentsTab ? theTabSchool2AttainmentsTab->get_measure_address(measure_id, indices) : nullptr;
        case 15: return theTabSchool2TrackTab ? theTabSchool2TrackTab->get_measure_address(measure_id, indices) : nullptr;
        case 16: return thetabBirthsYearPlace ? thetabBirthsYearPlace->get_measure_address(measure_id, indices) : nullptr;
        case 17: return thetabEducationFateGeobirYob ? thetabEducationFateGeobirYob->get_measure_address(measure_id, indices) : nullptr;
        case 18: return thetabHCI ? thetabHCI->get_measure_address(measure_id, indices) : nullptr;
        case 19: return thetabHavingSpouse ? thetabHavingSpouse->get_measure_address(measure_id, indices) : nullptr;
        case 20: return thetabMigrationOriginDestination ? thetabMigrationOriginDestination->get_measure_address(measure_id, indices) : nullptr;
        case 21: return thetabPopulationYearPlace ? thetabPopulationYearPlace->get_measure_address(measure_id, indices) : nullptr;
        case 22: return thetabPreSchool ? thetabPreSchool->get_measure_address(measure_id, indices) : nullptr;
        case 23: return thetabStuntingSexRegMotherYob ? thetabStuntingSexRegMotherYob->get_measure_address(measure_id, indices) : nullptr;
        case 24: return thetabStuntingSexRegYob ? thetabStuntingSexRegYob->get_measure_address(measure_id, indices) : nullptr;
        default: assert(false); // logic guarantee
    }
    return nullptr;
}


// table dependencies
const std::map<std::string, std::set<std::string>> om_tables_required =
{
};

bool is_suppressed_compute(std::string table_name, IModel* const i_model)
{
    bool is_suppressed = i_model->isSuppressed(table_name.c_str()); 
    if (is_suppressed) {
        auto search = om_tables_required.find(table_name);
        if (search == om_tables_required.end()) {
            return true;  // no other tables require this table
        }
        else {
            for (auto tbl_requiring : search->second) {
                if (!i_model->isSuppressed(tbl_requiring.c_str())) { 
                    return false; // a non-suppressed table requires this table
                }
            }
            return true; // no non-suppressed table requires this table
        }
    }
    else {
        return false; // this table is not suppressed
    }
}

bool is_suppressed_write(std::string table_name, IModel* const i_model)
{
    return i_model->isSuppressed(table_name.c_str()); 
}

void Calibrator::age_agent(Time t)
{
    if (time < t) {
        // Age the entity forward to the given time.
        time.set(t);
    }
    else {
        // The entity is already older than the given time.
        // This is normal if another entity is 'catching up' to this entity in its own events.
        // It is a model error if the current event is in this entity,
        // since that implies that an event is trying to make time run backwards for this entity.
        // This condition is detected and handled outside of this function.
    }
}
void Calibrator::calibrator_year_update_identity()
{
    #line 34 "../code/ActorCalibrator.mpp"
    calibrator_year.set(COERCE(ALL_YEAR_RANGE, lCalibratorToClock->clock_year));
}
#line 2490 "C:/Users/Martin/Dropbox/openM++/models/Dynamis-Pop-3-06-ABC/ompp/src/om_definitions.cpp"
Time Calibrator::check_time(Time t)
{
    if (t < time) {
        std::stringstream ss;
        ss << std::setprecision(std::numeric_limits<long double>::digits10 + 1) // maximum precision
           << LT("error : time ") << std::showpoint << t
           << LT(" is earlier than current time ") << (double)time
           << LT(" in entity_id ") << entity_id
           << LT(" in simulation member ") << get_simulation_member()
           << LT(" with combined seed ") << get_combined_seed()
            ;
        throw openm::SimulationException(ss.str().c_str());
    }
    return t;
}
void Calibrator::om_asCalibrator_erase()
{
    asCalibrator->erase(this);
}
void Calibrator::om_asCalibrator_insert()
{
    asCalibrator->insert(this);
}
void Calibrator::om_asCalibrator_update_cell()
{
    // only a single cell if rank 0
    om_asCalibrator_cell = 0;
}
void Calibrator::om_assign_member_offsets()
{
    age.offset_in_agent = (char *)&(this->age) - (char *)this;
    calibrator_year.offset_in_agent = (char *)&(this->calibrator_year) - (char *)this;
    case_seed.offset_in_agent = (char *)&(this->case_seed) - (char *)this;
    emigration_counter.offset_in_agent = (char *)&(this->emigration_counter) - (char *)this;
    entity_id.offset_in_agent = (char *)&(this->entity_id) - (char *)this;
    events.offset_in_agent = (char *)&(this->events) - (char *)this;
    immigration_counter.offset_in_agent = (char *)&(this->immigration_counter) - (char *)this;
    is_calibrated_child_mortality.offset_in_agent = (char *)&(this->is_calibrated_child_mortality) - (char *)this;
    lCalibratorToClock.offset_in_agent = (char *)&(this->lCalibratorToClock) - (char *)this;
    migration_counter.offset_in_agent = (char *)&(this->migration_counter) - (char *)this;
    mlCalibratorToPerson.offset_in_agent = (char *)&(this->mlCalibratorToPerson) - (char *)this;
    mort_female_0.offset_in_agent = (char *)&(this->mort_female_0) - (char *)this;
    mort_female_1.offset_in_agent = (char *)&(this->mort_female_1) - (char *)this;
    mort_female_2.offset_in_agent = (char *)&(this->mort_female_2) - (char *)this;
    mort_female_3.offset_in_agent = (char *)&(this->mort_female_3) - (char *)this;
    mort_female_4.offset_in_agent = (char *)&(this->mort_female_4) - (char *)this;
    mort_male_0.offset_in_agent = (char *)&(this->mort_male_0) - (char *)this;
    mort_male_1.offset_in_agent = (char *)&(this->mort_male_1) - (char *)this;
    mort_male_2.offset_in_agent = (char *)&(this->mort_male_2) - (char *)this;
    mort_male_3.offset_in_agent = (char *)&(this->mort_male_3) - (char *)this;
    mort_male_4.offset_in_agent = (char *)&(this->mort_male_4) - (char *)this;
    om_ChildMortalityCalibration_om_event.offset_in_agent = (char *)&(this->om_ChildMortalityCalibration_om_event) - (char *)this;
    time.offset_in_agent = (char *)&(this->time) - (char *)this;
}
void Calibrator::om_check_starting_time()
{
    if (!std::isfinite((double)time)) {
        std::stringstream ss;
        ss << std::setprecision(std::numeric_limits<long double>::digits10 + 1) // maximum precision
           << std::showpoint // show decimal point
           << LT("error : invalid starting time ") << (double)time
           << LT(" in new ") << "Calibrator"
           << LT(" with entity_id ") << entity_id
           << LT(" at global time ") << (double)BaseEvent::get_global_time()
           << LT(" in simulation member ") << get_simulation_member()
           << LT(" with combined seed ") << get_combined_seed()
            ;
        throw openm::SimulationException(ss.str().c_str());
    }
}
void Calibrator::om_finalize_entity_sets()
{
    // asCalibrator
    om_asCalibrator_erase();

}
void Calibrator::om_finalize_events()
{
    om_ChildMortalityCalibration_om_event.make_zombie();
}
void Calibrator::om_finalize_links()
{
    lCalibratorToClock.set(nullptr);
}
void Calibrator::om_finalize_multilinks()
{
    mlCalibratorToPerson.clear();
}
void Calibrator::om_finalize_tables()
{
}
int Calibrator::om_get_entity_id()
{
    return entity_id;
}
Time Calibrator::om_get_time()
{
    return time.get();
}
void Calibrator::om_initialize_data_members()
{
    age.initialize( 0 );
     // TODO EntityArrayMemberSymbol alignment_educ1_high
     // TODO EntityArrayMemberSymbol alignment_educ1_medium
    #line 34 "../code/ActorCalibrator.mpp"
    calibrator_year.initialize( 1899 );
    case_seed.initialize( 0.0 );
    #line 80 "../code/MigrationGeneral.mpp"
    emigration_counter.initialize( 0 );
    entity_id.initialize( 0 );
    events.initialize( 0 );
    #line 79 "../code/MigrationGeneral.mpp"
    immigration_counter.initialize( 0 );
    #line 99 "../code/MortalityDetailed.mpp"
    is_calibrated_child_mortality.initialize( false );
    #line 25 "../code/ActorCalibrator.mpp"
    lCalibratorToClock.initialize( nullptr );
    #line 78 "../code/MigrationGeneral.mpp"
    migration_counter.initialize( 0 );
    #line 22 "../code/ActorCalibrator.mpp"
    mlCalibratorToPerson.initialize( nullptr );
    #line 93 "../code/MortalityDetailed.mpp"
    mort_female_0.initialize( 1.0 );
    #line 94 "../code/MortalityDetailed.mpp"
    mort_female_1.initialize( 1.0 );
    #line 95 "../code/MortalityDetailed.mpp"
    mort_female_2.initialize( 1.0 );
    #line 96 "../code/MortalityDetailed.mpp"
    mort_female_3.initialize( 1.0 );
    #line 97 "../code/MortalityDetailed.mpp"
    mort_female_4.initialize( 1.0 );
    #line 87 "../code/MortalityDetailed.mpp"
    mort_male_0.initialize( 1.0 );
    #line 88 "../code/MortalityDetailed.mpp"
    mort_male_1.initialize( 1.0 );
    #line 89 "../code/MortalityDetailed.mpp"
    mort_male_2.initialize( 1.0 );
    #line 90 "../code/MortalityDetailed.mpp"
    mort_male_3.initialize( 1.0 );
    #line 91 "../code/MortalityDetailed.mpp"
    mort_male_4.initialize( 1.0 );
    #line 100 "../code/MortalityDetailed.mpp"
    om_ChildMortalityCalibration_om_event.initialize( time_infinite );
    om_asCalibrator_cell = 0;
    time.initialize( 0 );
}
#line 2637 "C:/Users/Martin/Dropbox/openM++/models/Dynamis-Pop-3-06-ABC/ompp/src/om_definitions.cpp"
void Calibrator::om_initialize_data_members0()
{
    age.initialize( 0 );
     // TODO EntityArrayMemberSymbol alignment_educ1_high
     // TODO EntityArrayMemberSymbol alignment_educ1_medium
    #line 34 "../code/ActorCalibrator.mpp"
    calibrator_year.initialize( 1899 );
    case_seed.initialize( 0.0 );
    #line 80 "../code/MigrationGeneral.mpp"
    emigration_counter.initialize( 0 );
    entity_id.initialize( 0 );
    events.initialize( 0 );
    #line 79 "../code/MigrationGeneral.mpp"
    immigration_counter.initialize( 0 );
    #line 99 "../code/MortalityDetailed.mpp"
    is_calibrated_child_mortality.initialize( false );
    #line 25 "../code/ActorCalibrator.mpp"
    lCalibratorToClock.initialize( nullptr );
    #line 78 "../code/MigrationGeneral.mpp"
    migration_counter.initialize( 0 );
    #line 22 "../code/ActorCalibrator.mpp"
    mlCalibratorToPerson.initialize( nullptr );
    #line 93 "../code/MortalityDetailed.mpp"
    mort_female_0.initialize( 0.0 );
    #line 94 "../code/MortalityDetailed.mpp"
    mort_female_1.initialize( 0.0 );
    #line 95 "../code/MortalityDetailed.mpp"
    mort_female_2.initialize( 0.0 );
    #line 96 "../code/MortalityDetailed.mpp"
    mort_female_3.initialize( 0.0 );
    #line 97 "../code/MortalityDetailed.mpp"
    mort_female_4.initialize( 0.0 );
    #line 87 "../code/MortalityDetailed.mpp"
    mort_male_0.initialize( 0.0 );
    #line 88 "../code/MortalityDetailed.mpp"
    mort_male_1.initialize( 0.0 );
    #line 89 "../code/MortalityDetailed.mpp"
    mort_male_2.initialize( 0.0 );
    #line 90 "../code/MortalityDetailed.mpp"
    mort_male_3.initialize( 0.0 );
    #line 91 "../code/MortalityDetailed.mpp"
    mort_male_4.initialize( 0.0 );
    #line 100 "../code/MortalityDetailed.mpp"
    om_ChildMortalityCalibration_om_event.initialize( time_infinite );
    om_asCalibrator_cell = 0;
    time.initialize( 0 );
}
#line 2685 "C:/Users/Martin/Dropbox/openM++/models/Dynamis-Pop-3-06-ABC/ompp/src/om_definitions.cpp"
void Calibrator::om_initialize_derived_attributes()
{
}
void Calibrator::om_initialize_entity_sets()
{
    // asCalibrator
    om_asCalibrator_update_cell();
    om_asCalibrator_insert();

}
void Calibrator::om_initialize_events()
{
    om_ChildMortalityCalibration_om_event.make_dirty();
}
void Calibrator::om_initialize_identity_attributes()
{

    // Code Injection: group=8, injector=calibrator_year
    // Initialize 'calibrator_year' to correct value based on expression.
    calibrator_year_update_identity();
}
void Calibrator::om_initialize_tables()
{
}
void Calibrator::om_initialize_time_and_age()
{
    // Calling initialize() to set the values of time and age to time_infinite
    // ensures that their associated side-effects functions will be invoked
    // when set() is called immediately after.  This ensures that identity attributes
    // and derived attributes which depend on time and age have correct values
    // if they are used by model developer code in the Start() function before the
    // entity enters the simulation.
    time.initialize(time_infinite);
    time.set(BaseEvent::get_global_time());
    age.initialize(time_infinite);
    age.set(0);
}
void Calibrator::om_mlCalibratorToPerson_erase(entity_ptr<Person> lnk)
{
    if (lnk->lCalibrator.get().get() == this) lnk->lCalibrator = nullptr;
}
void Calibrator::om_mlCalibratorToPerson_insert(entity_ptr<Person> lnk)
{
    if (lnk.get() != nullptr) lnk->lCalibrator = this;
}
void Calibrator::om_mlCalibratorToPerson_side_effects()
{
}
void Calibrator::om_notify_age()
{
}
void Calibrator::om_notify_calibrator_year()
{
}
void Calibrator::om_notify_case_seed()
{
}
void Calibrator::om_notify_emigration_counter()
{
}
void Calibrator::om_notify_entity_id()
{
}
void Calibrator::om_notify_events()
{
}
void Calibrator::om_notify_immigration_counter()
{
}
void Calibrator::om_notify_is_calibrated_child_mortality()
{
}
void Calibrator::om_notify_lCalibratorToClock()
{
}
void Calibrator::om_notify_migration_counter()
{
}
void Calibrator::om_notify_mort_female_0()
{
}
void Calibrator::om_notify_mort_female_1()
{
}
void Calibrator::om_notify_mort_female_2()
{
}
void Calibrator::om_notify_mort_female_3()
{
}
void Calibrator::om_notify_mort_female_4()
{
}
void Calibrator::om_notify_mort_male_0()
{
}
void Calibrator::om_notify_mort_male_1()
{
}
void Calibrator::om_notify_mort_male_2()
{
}
void Calibrator::om_notify_mort_male_3()
{
}
void Calibrator::om_notify_mort_male_4()
{
}
void Calibrator::om_notify_time()
{
}
void Calibrator::om_reset_derived_attributes()
{
}
void Calibrator::om_set_entity_id()
{
    entity_id.set(get_next_entity_id());
}
void Calibrator::om_side_effects_age(Time om_old, Time om_new)
{
}
void Calibrator::om_side_effects_calibrator_year(ALL_YEAR_RANGE om_old, ALL_YEAR_RANGE om_new)
{
}
void Calibrator::om_side_effects_case_seed(double om_old, double om_new)
{
}
void Calibrator::om_side_effects_emigration_counter(integer om_old, integer om_new)
{
}
void Calibrator::om_side_effects_entity_id(int om_old, int om_new)
{
}
void Calibrator::om_side_effects_events(counter om_old, counter om_new)
{
}
void Calibrator::om_side_effects_immigration_counter(integer om_old, integer om_new)
{
}
void Calibrator::om_side_effects_is_calibrated_child_mortality(bool om_old, bool om_new)
{

    // Code Injection: group=10, injector=om_ChildMortalityCalibration_om_event
    // Recalculate time to event ChildMortalityCalibration
    if (om_active) om_ChildMortalityCalibration_om_event.make_dirty();
}
void Calibrator::om_side_effects_lCalibratorToClock(entity_ptr<Clock> om_old, entity_ptr<Clock> om_new)
{

    // Code Injection: group=8, injector=calibrator_year
    // Maintain identity for 'Calibrator::calibrator_year' when link changed to different agent
    calibrator_year_update_identity();
    // Maintain reciprocal single link: lClockToCalibrator in Clock
    if (om_old.get() != nullptr && om_old->lClockToCalibrator.get().get() == this) {
        om_old->lClockToCalibrator = nullptr;
    }
    if (om_new.get() != nullptr && om_new->lClockToCalibrator.get().get() != this) {
        om_new->lClockToCalibrator = this;
    }

}
void Calibrator::om_side_effects_migration_counter(integer om_old, integer om_new)
{
}
void Calibrator::om_side_effects_mort_female_0(double om_old, double om_new)
{

    // Code Injection: group=8, injector=child_mortality
    // Maintain identity for 'Person::child_mortality' in all entities in reciprocal multilink
    for (auto &item : mlCalibratorToPerson.storage) {
        if (item.get() != nullptr) {
            item->child_mortality_update_identity();
        }
    }
}
void Calibrator::om_side_effects_mort_female_1(double om_old, double om_new)
{

    // Code Injection: group=8, injector=child_mortality
    // Maintain identity for 'Person::child_mortality' in all entities in reciprocal multilink
    for (auto &item : mlCalibratorToPerson.storage) {
        if (item.get() != nullptr) {
            item->child_mortality_update_identity();
        }
    }
}
void Calibrator::om_side_effects_mort_female_2(double om_old, double om_new)
{

    // Code Injection: group=8, injector=child_mortality
    // Maintain identity for 'Person::child_mortality' in all entities in reciprocal multilink
    for (auto &item : mlCalibratorToPerson.storage) {
        if (item.get() != nullptr) {
            item->child_mortality_update_identity();
        }
    }
}
void Calibrator::om_side_effects_mort_female_3(double om_old, double om_new)
{

    // Code Injection: group=8, injector=child_mortality
    // Maintain identity for 'Person::child_mortality' in all entities in reciprocal multilink
    for (auto &item : mlCalibratorToPerson.storage) {
        if (item.get() != nullptr) {
            item->child_mortality_update_identity();
        }
    }
}
void Calibrator::om_side_effects_mort_female_4(double om_old, double om_new)
{

    // Code Injection: group=8, injector=child_mortality
    // Maintain identity for 'Person::child_mortality' in all entities in reciprocal multilink
    for (auto &item : mlCalibratorToPerson.storage) {
        if (item.get() != nullptr) {
            item->child_mortality_update_identity();
        }
    }
}
void Calibrator::om_side_effects_mort_male_0(double om_old, double om_new)
{

    // Code Injection: group=8, injector=child_mortality
    // Maintain identity for 'Person::child_mortality' in all entities in reciprocal multilink
    for (auto &item : mlCalibratorToPerson.storage) {
        if (item.get() != nullptr) {
            item->child_mortality_update_identity();
        }
    }
}
void Calibrator::om_side_effects_mort_male_1(double om_old, double om_new)
{

    // Code Injection: group=8, injector=child_mortality
    // Maintain identity for 'Person::child_mortality' in all entities in reciprocal multilink
    for (auto &item : mlCalibratorToPerson.storage) {
        if (item.get() != nullptr) {
            item->child_mortality_update_identity();
        }
    }
}
void Calibrator::om_side_effects_mort_male_2(double om_old, double om_new)
{

    // Code Injection: group=8, injector=child_mortality
    // Maintain identity for 'Person::child_mortality' in all entities in reciprocal multilink
    for (auto &item : mlCalibratorToPerson.storage) {
        if (item.get() != nullptr) {
            item->child_mortality_update_identity();
        }
    }
}
void Calibrator::om_side_effects_mort_male_3(double om_old, double om_new)
{

    // Code Injection: group=8, injector=child_mortality
    // Maintain identity for 'Person::child_mortality' in all entities in reciprocal multilink
    for (auto &item : mlCalibratorToPerson.storage) {
        if (item.get() != nullptr) {
            item->child_mortality_update_identity();
        }
    }
}
void Calibrator::om_side_effects_mort_male_4(double om_old, double om_new)
{

    // Code Injection: group=8, injector=child_mortality
    // Maintain identity for 'Person::child_mortality' in all entities in reciprocal multilink
    for (auto &item : mlCalibratorToPerson.storage) {
        if (item.get() != nullptr) {
            item->child_mortality_update_identity();
        }
    }
}
void Calibrator::om_side_effects_time(Time om_old, Time om_new)
{
    // Amount of time increment
    Time om_delta = om_new - om_old;

    // Code Injection: group=2, injector=age
    if (om_active) {
        // Advance time for the attribute 'age'
        age.set(age.get() + om_delta);
    }
}

const std::string Calibrator::om_name_age = "age";
const std::string Calibrator::om_name_calibrator_year = "calibrator_year";
const std::string Calibrator::om_name_case_seed = "case_seed";
const std::string Calibrator::om_name_emigration_counter = "emigration_counter";
const std::string Calibrator::om_name_entity_id = "entity_id";
const std::string Calibrator::om_name_events = "events";
const std::string Calibrator::om_name_immigration_counter = "immigration_counter";
const std::string Calibrator::om_name_is_calibrated_child_mortality = "is_calibrated_child_mortality";
const std::string Calibrator::om_name_lCalibratorToClock = "lCalibratorToClock";
const std::string Calibrator::om_name_migration_counter = "migration_counter";
const std::string Calibrator::om_name_mort_female_0 = "mort_female_0";
const std::string Calibrator::om_name_mort_female_1 = "mort_female_1";
const std::string Calibrator::om_name_mort_female_2 = "mort_female_2";
const std::string Calibrator::om_name_mort_female_3 = "mort_female_3";
const std::string Calibrator::om_name_mort_female_4 = "mort_female_4";
const std::string Calibrator::om_name_mort_male_0 = "mort_male_0";
const std::string Calibrator::om_name_mort_male_1 = "mort_male_1";
const std::string Calibrator::om_name_mort_male_2 = "mort_male_2";
const std::string Calibrator::om_name_mort_male_3 = "mort_male_3";
const std::string Calibrator::om_name_mort_male_4 = "mort_male_4";
const std::string Calibrator::om_name_time = "time";

// The definition of the static member Calibrator
// used to retrieve (zero) values when dereferencing nullptr link attributes.
thread_local Calibrator Calibrator::om_null_agent;
void Clock::age_agent(Time t)
{
    if (time < t) {
        // Age the entity forward to the given time.
        time.set(t);
    }
    else {
        // The entity is already older than the given time.
        // This is normal if another entity is 'catching up' to this entity in its own events.
        // It is a model error if the current event is in this entity,
        // since that implies that an event is trying to make time run backwards for this entity.
        // This condition is detected and handled outside of this function.
    }
}
Time Clock::check_time(Time t)
{
    if (t < time) {
        std::stringstream ss;
        ss << std::setprecision(std::numeric_limits<long double>::digits10 + 1) // maximum precision
           << LT("error : time ") << std::showpoint << t
           << LT(" is earlier than current time ") << (double)time
           << LT(" in entity_id ") << entity_id
           << LT(" in simulation member ") << get_simulation_member()
           << LT(" with combined seed ") << get_combined_seed()
            ;
        throw openm::SimulationException(ss.str().c_str());
    }
    return t;
}
void Clock::om_asClock_erase()
{
    asClock->erase(this);
}
void Clock::om_asClock_insert()
{
    asClock->insert(this);
}
void Clock::om_asClock_update_cell()
{
    // only a single cell if rank 0
    om_asClock_cell = 0;
}
void Clock::om_assign_member_offsets()
{
    age.offset_in_agent = (char *)&(this->age) - (char *)this;
    case_seed.offset_in_agent = (char *)&(this->case_seed) - (char *)this;
    clock_year.offset_in_agent = (char *)&(this->clock_year) - (char *)this;
    entity_id.offset_in_agent = (char *)&(this->entity_id) - (char *)this;
    events.offset_in_agent = (char *)&(this->events) - (char *)this;
    lClockToCalibrator.offset_in_agent = (char *)&(this->lClockToCalibrator) - (char *)this;
    next_clock_year_end.offset_in_agent = (char *)&(this->next_clock_year_end) - (char *)this;
    next_clock_year_start.offset_in_agent = (char *)&(this->next_clock_year_start) - (char *)this;
    next_midyear_clock_event.offset_in_agent = (char *)&(this->next_midyear_clock_event) - (char *)this;
    om_ClockMidyearEvent_om_event.offset_in_agent = (char *)&(this->om_ClockMidyearEvent_om_event) - (char *)this;
    om_ClockYearEndEvent_om_event.offset_in_agent = (char *)&(this->om_ClockYearEndEvent_om_event) - (char *)this;
    om_ClockYearStartEvent_om_event.offset_in_agent = (char *)&(this->om_ClockYearStartEvent_om_event) - (char *)this;
    om_EndSchoolOneYearEvent_om_event.offset_in_agent = (char *)&(this->om_EndSchoolOneYearEvent_om_event) - (char *)this;
    om_EndSchoolTwoYearEvent_om_event.offset_in_agent = (char *)&(this->om_EndSchoolTwoYearEvent_om_event) - (char *)this;
    om_StartSchoolOneYearEvent_om_event.offset_in_agent = (char *)&(this->om_StartSchoolOneYearEvent_om_event) - (char *)this;
    om_StartSchoolTwoYearEvent_om_event.offset_in_agent = (char *)&(this->om_StartSchoolTwoYearEvent_om_event) - (char *)this;
    time.offset_in_agent = (char *)&(this->time) - (char *)this;
    time_end_school_one_year.offset_in_agent = (char *)&(this->time_end_school_one_year) - (char *)this;
    time_end_school_two_year.offset_in_agent = (char *)&(this->time_end_school_two_year) - (char *)this;
    time_start_school_one_year.offset_in_agent = (char *)&(this->time_start_school_one_year) - (char *)this;
    time_start_school_two_year.offset_in_agent = (char *)&(this->time_start_school_two_year) - (char *)this;
}
void Clock::om_check_starting_time()
{
    if (!std::isfinite((double)time)) {
        std::stringstream ss;
        ss << std::setprecision(std::numeric_limits<long double>::digits10 + 1) // maximum precision
           << std::showpoint // show decimal point
           << LT("error : invalid starting time ") << (double)time
           << LT(" in new ") << "Clock"
           << LT(" with entity_id ") << entity_id
           << LT(" at global time ") << (double)BaseEvent::get_global_time()
           << LT(" in simulation member ") << get_simulation_member()
           << LT(" with combined seed ") << get_combined_seed()
            ;
        throw openm::SimulationException(ss.str().c_str());
    }
}
void Clock::om_finalize_entity_sets()
{
    // asClock
    om_asClock_erase();

}
void Clock::om_finalize_events()
{
    om_ClockMidyearEvent_om_event.make_zombie();
    om_ClockYearEndEvent_om_event.make_zombie();
    om_ClockYearStartEvent_om_event.make_zombie();
    om_EndSchoolOneYearEvent_om_event.make_zombie();
    om_EndSchoolTwoYearEvent_om_event.make_zombie();
    om_StartSchoolOneYearEvent_om_event.make_zombie();
    om_StartSchoolTwoYearEvent_om_event.make_zombie();
}
void Clock::om_finalize_links()
{
    lClockToCalibrator.set(nullptr);
}
void Clock::om_finalize_multilinks()
{
}
void Clock::om_finalize_tables()
{
}
int Clock::om_get_entity_id()
{
    return entity_id;
}
Time Clock::om_get_time()
{
    return time.get();
}
void Clock::om_initialize_data_members()
{
    age.initialize( 0 );
    case_seed.initialize( 0.0 );
    #line 28 "../code/ActorClock.mpp"
    clock_year.initialize( 1900 );
    entity_id.initialize( 0 );
    events.initialize( 0 );
    #line 25 "../code/ActorCalibrator.mpp"
    lClockToCalibrator.initialize( nullptr );
    #line 30 "../code/ActorClock.mpp"
    next_clock_year_end.initialize( 1900 );
    #line 33 "../code/ActorClock.mpp"
    next_clock_year_start.initialize( 1900 );
    #line 36 "../code/ActorClock.mpp"
    next_midyear_clock_event.initialize( time_infinite );
    #line 37 "../code/ActorClock.mpp"
    om_ClockMidyearEvent_om_event.initialize( time_infinite );
    #line 31 "../code/ActorClock.mpp"
    om_ClockYearEndEvent_om_event.initialize( time_infinite );
    #line 34 "../code/ActorClock.mpp"
    om_ClockYearStartEvent_om_event.initialize( time_infinite );
    #line 121 "../code/EducationPrimaryTracking.mpp"
    om_EndSchoolOneYearEvent_om_event.initialize( time_infinite );
    #line 128 "../code/EducationSecondaryBase.mpp"
    om_EndSchoolTwoYearEvent_om_event.initialize( time_infinite );
    #line 120 "../code/EducationPrimaryTracking.mpp"
    om_StartSchoolOneYearEvent_om_event.initialize( time_infinite );
    #line 127 "../code/EducationSecondaryBase.mpp"
    om_StartSchoolTwoYearEvent_om_event.initialize( time_infinite );
    om_asClock_cell = 0;
    time.initialize( 0 );
    #line 118 "../code/EducationPrimaryTracking.mpp"
    time_end_school_one_year.initialize( time_infinite );
    #line 125 "../code/EducationSecondaryBase.mpp"
    time_end_school_two_year.initialize( time_infinite );
    #line 117 "../code/EducationPrimaryTracking.mpp"
    time_start_school_one_year.initialize( time_infinite );
    #line 124 "../code/EducationSecondaryBase.mpp"
    time_start_school_two_year.initialize( time_infinite );
}
#line 3154 "C:/Users/Martin/Dropbox/openM++/models/Dynamis-Pop-3-06-ABC/ompp/src/om_definitions.cpp"
void Clock::om_initialize_data_members0()
{
    age.initialize( 0 );
    case_seed.initialize( 0.0 );
    #line 28 "../code/ActorClock.mpp"
    clock_year.initialize( 0 );
    entity_id.initialize( 0 );
    events.initialize( 0 );
    #line 25 "../code/ActorCalibrator.mpp"
    lClockToCalibrator.initialize( nullptr );
    #line 30 "../code/ActorClock.mpp"
    next_clock_year_end.initialize( 0 );
    #line 33 "../code/ActorClock.mpp"
    next_clock_year_start.initialize( 0 );
    #line 36 "../code/ActorClock.mpp"
    next_midyear_clock_event.initialize( 0 );
    #line 37 "../code/ActorClock.mpp"
    om_ClockMidyearEvent_om_event.initialize( time_infinite );
    #line 31 "../code/ActorClock.mpp"
    om_ClockYearEndEvent_om_event.initialize( time_infinite );
    #line 34 "../code/ActorClock.mpp"
    om_ClockYearStartEvent_om_event.initialize( time_infinite );
    #line 121 "../code/EducationPrimaryTracking.mpp"
    om_EndSchoolOneYearEvent_om_event.initialize( time_infinite );
    #line 128 "../code/EducationSecondaryBase.mpp"
    om_EndSchoolTwoYearEvent_om_event.initialize( time_infinite );
    #line 120 "../code/EducationPrimaryTracking.mpp"
    om_StartSchoolOneYearEvent_om_event.initialize( time_infinite );
    #line 127 "../code/EducationSecondaryBase.mpp"
    om_StartSchoolTwoYearEvent_om_event.initialize( time_infinite );
    om_asClock_cell = 0;
    time.initialize( 0 );
    #line 118 "../code/EducationPrimaryTracking.mpp"
    time_end_school_one_year.initialize( 0 );
    #line 125 "../code/EducationSecondaryBase.mpp"
    time_end_school_two_year.initialize( 0 );
    #line 117 "../code/EducationPrimaryTracking.mpp"
    time_start_school_one_year.initialize( 0 );
    #line 124 "../code/EducationSecondaryBase.mpp"
    time_start_school_two_year.initialize( 0 );
}
#line 3196 "C:/Users/Martin/Dropbox/openM++/models/Dynamis-Pop-3-06-ABC/ompp/src/om_definitions.cpp"
void Clock::om_initialize_derived_attributes()
{
}
void Clock::om_initialize_entity_sets()
{
    // asClock
    om_asClock_update_cell();
    om_asClock_insert();

}
void Clock::om_initialize_events()
{
    om_ClockMidyearEvent_om_event.make_dirty();
    om_ClockYearEndEvent_om_event.make_dirty();
    om_ClockYearStartEvent_om_event.make_dirty();
    om_EndSchoolOneYearEvent_om_event.make_dirty();
    om_EndSchoolTwoYearEvent_om_event.make_dirty();
    om_StartSchoolOneYearEvent_om_event.make_dirty();
    om_StartSchoolTwoYearEvent_om_event.make_dirty();
}
void Clock::om_initialize_identity_attributes()
{
}
void Clock::om_initialize_tables()
{
}
void Clock::om_initialize_time_and_age()
{
    // Calling initialize() to set the values of time and age to time_infinite
    // ensures that their associated side-effects functions will be invoked
    // when set() is called immediately after.  This ensures that identity attributes
    // and derived attributes which depend on time and age have correct values
    // if they are used by model developer code in the Start() function before the
    // entity enters the simulation.
    time.initialize(time_infinite);
    time.set(BaseEvent::get_global_time());
    age.initialize(time_infinite);
    age.set(0);
}
void Clock::om_notify_age()
{
}
void Clock::om_notify_case_seed()
{
}
void Clock::om_notify_clock_year()
{
}
void Clock::om_notify_entity_id()
{
}
void Clock::om_notify_events()
{
}
void Clock::om_notify_lClockToCalibrator()
{
}
void Clock::om_notify_next_clock_year_end()
{
}
void Clock::om_notify_next_clock_year_start()
{
}
void Clock::om_notify_next_midyear_clock_event()
{
}
void Clock::om_notify_time()
{
}
void Clock::om_notify_time_end_school_one_year()
{
}
void Clock::om_notify_time_end_school_two_year()
{
}
void Clock::om_notify_time_start_school_one_year()
{
}
void Clock::om_notify_time_start_school_two_year()
{
}
void Clock::om_reset_derived_attributes()
{
}
void Clock::om_set_entity_id()
{
    entity_id.set(get_next_entity_id());
}
void Clock::om_side_effects_age(Time om_old, Time om_new)
{
}
void Clock::om_side_effects_case_seed(double om_old, double om_new)
{
}
void Clock::om_side_effects_clock_year(int om_old, int om_new)
{

    // Code Injection: group=8, injector=calibrator_year
    // Maintain identity for 'Calibrator::calibrator_year' using reciprocal link
    if (!lClockToCalibrator.is_nullptr()) lClockToCalibrator->calibrator_year_update_identity();
}
void Clock::om_side_effects_entity_id(int om_old, int om_new)
{
}
void Clock::om_side_effects_events(counter om_old, counter om_new)
{
}
void Clock::om_side_effects_lClockToCalibrator(entity_ptr<Calibrator> om_old, entity_ptr<Calibrator> om_new)
{
    // Maintain reciprocal single link: lCalibratorToClock in Calibrator
    if (om_old.get() != nullptr && om_old->lCalibratorToClock.get().get() == this) {
        om_old->lCalibratorToClock = nullptr;
    }
    if (om_new.get() != nullptr && om_new->lCalibratorToClock.get().get() != this) {
        om_new->lCalibratorToClock = this;
    }

}
void Clock::om_side_effects_next_clock_year_end(Time om_old, Time om_new)
{

    // Code Injection: group=10, injector=om_ClockYearEndEvent_om_event
    // Recalculate time to event ClockYearEndEvent
    if (om_active) om_ClockYearEndEvent_om_event.make_dirty();
}
void Clock::om_side_effects_next_clock_year_start(Time om_old, Time om_new)
{

    // Code Injection: group=10, injector=om_ClockYearStartEvent_om_event
    // Recalculate time to event ClockYearStartEvent
    if (om_active) om_ClockYearStartEvent_om_event.make_dirty();
}
void Clock::om_side_effects_next_midyear_clock_event(Time om_old, Time om_new)
{

    // Code Injection: group=10, injector=om_ClockMidyearEvent_om_event
    // Recalculate time to event ClockMidyearEvent
    if (om_active) om_ClockMidyearEvent_om_event.make_dirty();
}
void Clock::om_side_effects_time(Time om_old, Time om_new)
{
    // Amount of time increment
    Time om_delta = om_new - om_old;

    // Code Injection: group=2, injector=age
    if (om_active) {
        // Advance time for the attribute 'age'
        age.set(age.get() + om_delta);
    }
}
void Clock::om_side_effects_time_end_school_one_year(Time om_old, Time om_new)
{

    // Code Injection: group=10, injector=om_EndSchoolOneYearEvent_om_event
    // Recalculate time to event EndSchoolOneYearEvent
    if (om_active) om_EndSchoolOneYearEvent_om_event.make_dirty();
}
void Clock::om_side_effects_time_end_school_two_year(Time om_old, Time om_new)
{

    // Code Injection: group=10, injector=om_EndSchoolTwoYearEvent_om_event
    // Recalculate time to event EndSchoolTwoYearEvent
    if (om_active) om_EndSchoolTwoYearEvent_om_event.make_dirty();
}
void Clock::om_side_effects_time_start_school_one_year(Time om_old, Time om_new)
{

    // Code Injection: group=10, injector=om_StartSchoolOneYearEvent_om_event
    // Recalculate time to event StartSchoolOneYearEvent
    if (om_active) om_StartSchoolOneYearEvent_om_event.make_dirty();
}
void Clock::om_side_effects_time_start_school_two_year(Time om_old, Time om_new)
{

    // Code Injection: group=10, injector=om_StartSchoolTwoYearEvent_om_event
    // Recalculate time to event StartSchoolTwoYearEvent
    if (om_active) om_StartSchoolTwoYearEvent_om_event.make_dirty();
}

const std::string Clock::om_name_age = "age";
const std::string Clock::om_name_case_seed = "case_seed";
const std::string Clock::om_name_clock_year = "clock_year";
const std::string Clock::om_name_entity_id = "entity_id";
const std::string Clock::om_name_events = "events";
const std::string Clock::om_name_lClockToCalibrator = "lClockToCalibrator";
const std::string Clock::om_name_next_clock_year_end = "next_clock_year_end";
const std::string Clock::om_name_next_clock_year_start = "next_clock_year_start";
const std::string Clock::om_name_next_midyear_clock_event = "next_midyear_clock_event";
const std::string Clock::om_name_time = "time";
const std::string Clock::om_name_time_end_school_one_year = "time_end_school_one_year";
const std::string Clock::om_name_time_end_school_two_year = "time_end_school_two_year";
const std::string Clock::om_name_time_start_school_one_year = "time_start_school_one_year";
const std::string Clock::om_name_time_start_school_two_year = "time_start_school_two_year";

// The definition of the static member Clock
// used to retrieve (zero) values when dereferencing nullptr link attributes.
thread_local Clock Clock::om_null_agent;
void Observation::age_agent(Time t)
{
    if (time < t) {
        // Age the entity forward to the given time.
        time.set(t);
    }
    else {
        // The entity is already older than the given time.
        // This is normal if another entity is 'catching up' to this entity in its own events.
        // It is a model error if the current event is in this entity,
        // since that implies that an event is trying to make time run backwards for this entity.
        // This condition is detected and handled outside of this function.
    }
}
Time Observation::check_time(Time t)
{
    if (t < time) {
        std::stringstream ss;
        ss << std::setprecision(std::numeric_limits<long double>::digits10 + 1) // maximum precision
           << LT("error : time ") << std::showpoint << t
           << LT(" is earlier than current time ") << (double)time
           << LT(" in entity_id ") << entity_id
           << LT(" in simulation member ") << get_simulation_member()
           << LT(" with combined seed ") << get_combined_seed()
            ;
        throw openm::SimulationException(ss.str().c_str());
    }
    return t;
}
void Observation::om_asObservationAll_erase()
{
    int cell = om_asObservationAll_cell;
    EntitySet<Observation> ** flattened_array = reinterpret_cast<EntitySet<Observation> **>(asObservationAll);
    assert(flattened_array[cell]);
    flattened_array[cell]->erase(this);
}
void Observation::om_asObservationAll_insert()
{
    int cell = om_asObservationAll_cell;
    EntitySet<Observation> ** flattened_array = reinterpret_cast<EntitySet<Observation> **>(asObservationAll);
    assert(flattened_array[cell]);
    flattened_array[cell]->insert(this);
}
void Observation::om_asObservationAll_update_cell()
{
    int cell = 0;
    int index = 0;

    // dimension=0 agentvar=pop_pool type=POP_POOL size=4
    index = pop_pool;
    cell += index;

    assert(cell >= 0 && cell < 4); // logic guarantee

    om_asObservationAll_cell = cell;
}
void Observation::om_asObservationByFamOldest_erase()
{
    int cell = om_asObservationByFamOldest_cell;
    EntitySet<Observation> ** flattened_array = reinterpret_cast<EntitySet<Observation> **>(asObservationByFamOldest);
    assert(flattened_array[cell]);
    flattened_array[cell]->erase(this);
}
void Observation::om_asObservationByFamOldest_filter_update_identity()
{
    #line 43 "../code/ActorObservation.mpp"
    om_asObservationByFamOldest_filter.set(obs_oldest);
}
#line 3462 "C:/Users/Martin/Dropbox/openM++/models/Dynamis-Pop-3-06-ABC/ompp/src/om_definitions.cpp"
void Observation::om_asObservationByFamOldest_insert()
{
    int cell = om_asObservationByFamOldest_cell;
    EntitySet<Observation> ** flattened_array = reinterpret_cast<EntitySet<Observation> **>(asObservationByFamOldest);
    assert(flattened_array[cell]);
    flattened_array[cell]->insert(this);
}
void Observation::om_asObservationByFamOldest_update_cell()
{
    int cell = 0;
    int index = 0;

    // dimension=0 agentvar=fam_id type=FAM_ID size=2000001
    index = fam_id;
    // adjust range to zero-based
    index -= 0;
    cell += index;

    assert(cell >= 0 && cell < 2000001); // logic guarantee

    om_asObservationByFamOldest_cell = cell;
}
void Observation::om_asObservationByFam_erase()
{
    int cell = om_asObservationByFam_cell;
    EntitySet<Observation> ** flattened_array = reinterpret_cast<EntitySet<Observation> **>(asObservationByFam);
    assert(flattened_array[cell]);
    flattened_array[cell]->erase(this);
}
void Observation::om_asObservationByFam_insert()
{
    int cell = om_asObservationByFam_cell;
    EntitySet<Observation> ** flattened_array = reinterpret_cast<EntitySet<Observation> **>(asObservationByFam);
    assert(flattened_array[cell]);
    flattened_array[cell]->insert(this);
}
void Observation::om_asObservationByFam_update_cell()
{
    int cell = 0;
    int index = 0;

    // dimension=0 agentvar=fam_id type=FAM_ID size=2000001
    index = fam_id;
    // adjust range to zero-based
    index -= 0;
    cell += index;

    assert(cell >= 0 && cell < 2000001); // logic guarantee

    om_asObservationByFam_cell = cell;
}
void Observation::om_asObservationHeads_erase()
{
    int cell = om_asObservationHeads_cell;
    EntitySet<Observation> ** flattened_array = reinterpret_cast<EntitySet<Observation> **>(asObservationHeads);
    assert(flattened_array[cell]);
    flattened_array[cell]->erase(this);
}
void Observation::om_asObservationHeads_filter_update_identity()
{
    #line 24 "../code/ActorObservation.mpp"
    om_asObservationHeads_filter.set(obs_oldest);
}
#line 3526 "C:/Users/Martin/Dropbox/openM++/models/Dynamis-Pop-3-06-ABC/ompp/src/om_definitions.cpp"
void Observation::om_asObservationHeads_insert()
{
    int cell = om_asObservationHeads_cell;
    EntitySet<Observation> ** flattened_array = reinterpret_cast<EntitySet<Observation> **>(asObservationHeads);
    assert(flattened_array[cell]);
    flattened_array[cell]->insert(this);
}
void Observation::om_asObservationHeads_update_cell()
{
    int cell = 0;
    int index = 0;

    // dimension=0 agentvar=pop_pool type=POP_POOL size=4
    index = pop_pool;
    cell += index;

    assert(cell >= 0 && cell < 4); // logic guarantee

    om_asObservationHeads_cell = cell;
}
void Observation::om_asObservationNonHeads_erase()
{
    int cell = om_asObservationNonHeads_cell;
    EntitySet<Observation> ** flattened_array = reinterpret_cast<EntitySet<Observation> **>(asObservationNonHeads);
    assert(flattened_array[cell]);
    flattened_array[cell]->erase(this);
}
void Observation::om_asObservationNonHeads_filter_update_identity()
{
    #line 31 "../code/ActorObservation.mpp"
    om_asObservationNonHeads_filter.set(!obs_oldest);
}
#line 3559 "C:/Users/Martin/Dropbox/openM++/models/Dynamis-Pop-3-06-ABC/ompp/src/om_definitions.cpp"
void Observation::om_asObservationNonHeads_insert()
{
    int cell = om_asObservationNonHeads_cell;
    EntitySet<Observation> ** flattened_array = reinterpret_cast<EntitySet<Observation> **>(asObservationNonHeads);
    assert(flattened_array[cell]);
    flattened_array[cell]->insert(this);
}
void Observation::om_asObservationNonHeads_update_cell()
{
    int cell = 0;
    int index = 0;

    // dimension=0 agentvar=fam_id type=FAM_ID size=2000001
    index = fam_id;
    // adjust range to zero-based
    index -= 0;
    cell += index;

    // dimension=1 agentvar=pop_pool type=POP_POOL size=4
    cell *= 4;
    index = pop_pool;
    cell += index;

    assert(cell >= 0 && cell < 8000004); // logic guarantee

    om_asObservationNonHeads_cell = cell;
}
void Observation::om_asObservations_erase()
{
    asObservations->erase(this);
}
void Observation::om_asObservations_insert()
{
    asObservations->insert(this);
}
void Observation::om_asObservations_update_cell()
{
    // only a single cell if rank 0
    om_asObservations_cell = 0;
}
void Observation::om_asSimulatedObservationHeads_erase()
{
    int cell = om_asSimulatedObservationHeads_cell;
    EntitySet<Observation> ** flattened_array = reinterpret_cast<EntitySet<Observation> **>(asSimulatedObservationHeads);
    assert(flattened_array[cell]);
    flattened_array[cell]->erase(this);
}
void Observation::om_asSimulatedObservationHeads_filter_update_identity()
{
    #line 28 "../code/ActorObservation.mpp"
    om_asSimulatedObservationHeads_filter.set((obs_oldest && (obs_weight > 0)));
}
#line 3612 "C:/Users/Martin/Dropbox/openM++/models/Dynamis-Pop-3-06-ABC/ompp/src/om_definitions.cpp"
void Observation::om_asSimulatedObservationHeads_insert()
{
    int cell = om_asSimulatedObservationHeads_cell;
    EntitySet<Observation> ** flattened_array = reinterpret_cast<EntitySet<Observation> **>(asSimulatedObservationHeads);
    assert(flattened_array[cell]);
    flattened_array[cell]->insert(this);
}
void Observation::om_asSimulatedObservationHeads_update_cell()
{
    int cell = 0;
    int index = 0;

    // dimension=0 agentvar=pop_pool type=POP_POOL size=4
    index = pop_pool;
    cell += index;

    assert(cell >= 0 && cell < 4); // logic guarantee

    om_asSimulatedObservationHeads_cell = cell;
}
void Observation::om_assign_member_offsets()
{
    age.offset_in_agent = (char *)&(this->age) - (char *)this;
    case_seed.offset_in_agent = (char *)&(this->case_seed) - (char *)this;
    entity_id.offset_in_agent = (char *)&(this->entity_id) - (char *)this;
    events.offset_in_agent = (char *)&(this->events) - (char *)this;
    fam_id.offset_in_agent = (char *)&(this->fam_id) - (char *)this;
    obs_birth.offset_in_agent = (char *)&(this->obs_birth) - (char *)this;
    obs_oldest.offset_in_agent = (char *)&(this->obs_oldest) - (char *)this;
    obs_weight.offset_in_agent = (char *)&(this->obs_weight) - (char *)this;
    om_asObservationByFamOldest_filter.offset_in_agent = (char *)&(this->om_asObservationByFamOldest_filter) - (char *)this;
    om_asObservationHeads_filter.offset_in_agent = (char *)&(this->om_asObservationHeads_filter) - (char *)this;
    om_asObservationNonHeads_filter.offset_in_agent = (char *)&(this->om_asObservationNonHeads_filter) - (char *)this;
    om_asSimulatedObservationHeads_filter.offset_in_agent = (char *)&(this->om_asSimulatedObservationHeads_filter) - (char *)this;
    pop_pool.offset_in_agent = (char *)&(this->pop_pool) - (char *)this;
    time.offset_in_agent = (char *)&(this->time) - (char *)this;
}
void Observation::om_check_starting_time()
{
    if (!std::isfinite((double)time)) {
        std::stringstream ss;
        ss << std::setprecision(std::numeric_limits<long double>::digits10 + 1) // maximum precision
           << std::showpoint // show decimal point
           << LT("error : invalid starting time ") << (double)time
           << LT(" in new ") << "Observation"
           << LT(" with entity_id ") << entity_id
           << LT(" at global time ") << (double)BaseEvent::get_global_time()
           << LT(" in simulation member ") << get_simulation_member()
           << LT(" with combined seed ") << get_combined_seed()
            ;
        throw openm::SimulationException(ss.str().c_str());
    }
}
void Observation::om_finalize_entity_sets()
{
    // asObservationAll
    om_asObservationAll_erase();

    // asObservationByFam
    om_asObservationByFam_erase();

    // asObservationByFamOldest
    if (om_asObservationByFamOldest_filter) {
        om_asObservationByFamOldest_erase();
    }

    // asObservationHeads
    if (om_asObservationHeads_filter) {
        om_asObservationHeads_erase();
    }

    // asObservationNonHeads
    if (om_asObservationNonHeads_filter) {
        om_asObservationNonHeads_erase();
    }

    // asObservations
    om_asObservations_erase();

    // asSimulatedObservationHeads
    if (om_asSimulatedObservationHeads_filter) {
        om_asSimulatedObservationHeads_erase();
    }

}
void Observation::om_finalize_events()
{
}
void Observation::om_finalize_links()
{
}
void Observation::om_finalize_multilinks()
{
}
void Observation::om_finalize_tables()
{
}
int Observation::om_get_entity_id()
{
    return entity_id;
}
Time Observation::om_get_time()
{
    return time.get();
}
void Observation::om_initialize_data_members()
{
    age.initialize( 0 );
    case_seed.initialize( 0.0 );
    entity_id.initialize( 0 );
    events.initialize( 0 );
    #line 80 "../code/ActorObservation.mpp"
    fam_id.initialize( 0 );
    #line 82 "../code/ActorObservation.mpp"
    obs_birth.initialize( time_infinite );
    #line 83 "../code/ActorObservation.mpp"
    obs_oldest.initialize( false );
    #line 78 "../code/ActorObservation.mpp"
    obs_weight.initialize( 0 );
    om_asObservationAll_cell = 0;
    om_asObservationByFamOldest_cell = 0;
    #line 43 "../code/ActorObservation.mpp"
    om_asObservationByFamOldest_filter.initialize( false );
    om_asObservationByFam_cell = 0;
    om_asObservationHeads_cell = 0;
    #line 24 "../code/ActorObservation.mpp"
    om_asObservationHeads_filter.initialize( false );
    om_asObservationNonHeads_cell = 0;
    #line 31 "../code/ActorObservation.mpp"
    om_asObservationNonHeads_filter.initialize( false );
    om_asObservations_cell = 0;
    om_asSimulatedObservationHeads_cell = 0;
    #line 28 "../code/ActorObservation.mpp"
    om_asSimulatedObservationHeads_filter.initialize( false );
     // TODO EntityArrayMemberSymbol pmc
    #line 81 "../code/ActorObservation.mpp"
    pop_pool.initialize( PP_NON );
    time.initialize( 0 );
}
#line 3752 "C:/Users/Martin/Dropbox/openM++/models/Dynamis-Pop-3-06-ABC/ompp/src/om_definitions.cpp"
void Observation::om_initialize_data_members0()
{
    age.initialize( 0 );
    case_seed.initialize( 0.0 );
    entity_id.initialize( 0 );
    events.initialize( 0 );
    #line 80 "../code/ActorObservation.mpp"
    fam_id.initialize( 0 );
    #line 82 "../code/ActorObservation.mpp"
    obs_birth.initialize( 0 );
    #line 83 "../code/ActorObservation.mpp"
    obs_oldest.initialize( false );
    #line 78 "../code/ActorObservation.mpp"
    obs_weight.initialize( 0 );
    om_asObservationAll_cell = 0;
    om_asObservationByFamOldest_cell = 0;
    #line 43 "../code/ActorObservation.mpp"
    om_asObservationByFamOldest_filter.initialize( false );
    om_asObservationByFam_cell = 0;
    om_asObservationHeads_cell = 0;
    #line 24 "../code/ActorObservation.mpp"
    om_asObservationHeads_filter.initialize( false );
    om_asObservationNonHeads_cell = 0;
    #line 31 "../code/ActorObservation.mpp"
    om_asObservationNonHeads_filter.initialize( false );
    om_asObservations_cell = 0;
    om_asSimulatedObservationHeads_cell = 0;
    #line 28 "../code/ActorObservation.mpp"
    om_asSimulatedObservationHeads_filter.initialize( false );
     // TODO EntityArrayMemberSymbol pmc
    #line 81 "../code/ActorObservation.mpp"
    pop_pool.initialize( PP_NON );
    time.initialize( 0 );
}
#line 3787 "C:/Users/Martin/Dropbox/openM++/models/Dynamis-Pop-3-06-ABC/ompp/src/om_definitions.cpp"
void Observation::om_initialize_derived_attributes()
{
}
void Observation::om_initialize_entity_sets()
{
    // asObservationAll
    om_asObservationAll_update_cell();
    om_asObservationAll_insert();

    // asObservationByFam
    om_asObservationByFam_update_cell();
    om_asObservationByFam_insert();

    // asObservationByFamOldest
    if (om_asObservationByFamOldest_filter) {
        om_asObservationByFamOldest_update_cell();
        om_asObservationByFamOldest_insert();
    }

    // asObservationHeads
    if (om_asObservationHeads_filter) {
        om_asObservationHeads_update_cell();
        om_asObservationHeads_insert();
    }

    // asObservationNonHeads
    if (om_asObservationNonHeads_filter) {
        om_asObservationNonHeads_update_cell();
        om_asObservationNonHeads_insert();
    }

    // asObservations
    om_asObservations_update_cell();
    om_asObservations_insert();

    // asSimulatedObservationHeads
    if (om_asSimulatedObservationHeads_filter) {
        om_asSimulatedObservationHeads_update_cell();
        om_asSimulatedObservationHeads_insert();
    }

}
void Observation::om_initialize_events()
{
}
void Observation::om_initialize_identity_attributes()
{

    // Code Injection: group=8, injector=om_asObservationByFamOldest_filter
    // Initialize 'om_asObservationByFamOldest_filter' to correct value based on expression.
    om_asObservationByFamOldest_filter_update_identity();

    // Code Injection: group=8, injector=om_asObservationHeads_filter
    // Initialize 'om_asObservationHeads_filter' to correct value based on expression.
    om_asObservationHeads_filter_update_identity();

    // Code Injection: group=8, injector=om_asObservationNonHeads_filter
    // Initialize 'om_asObservationNonHeads_filter' to correct value based on expression.
    om_asObservationNonHeads_filter_update_identity();

    // Code Injection: group=8, injector=om_asSimulatedObservationHeads_filter
    // Initialize 'om_asSimulatedObservationHeads_filter' to correct value based on expression.
    om_asSimulatedObservationHeads_filter_update_identity();
}
void Observation::om_initialize_tables()
{
}
void Observation::om_initialize_time_and_age()
{
    // Calling initialize() to set the values of time and age to time_infinite
    // ensures that their associated side-effects functions will be invoked
    // when set() is called immediately after.  This ensures that identity attributes
    // and derived attributes which depend on time and age have correct values
    // if they are used by model developer code in the Start() function before the
    // entity enters the simulation.
    time.initialize(time_infinite);
    time.set(BaseEvent::get_global_time());
    age.initialize(time_infinite);
    age.set(0);
}
void Observation::om_notify_age()
{
}
void Observation::om_notify_case_seed()
{
}
void Observation::om_notify_entity_id()
{
}
void Observation::om_notify_events()
{
}
void Observation::om_notify_fam_id()
{
}
void Observation::om_notify_obs_birth()
{
}
void Observation::om_notify_obs_oldest()
{
}
void Observation::om_notify_obs_weight()
{
}
void Observation::om_notify_om_asObservationByFamOldest_filter()
{
}
void Observation::om_notify_om_asObservationHeads_filter()
{
}
void Observation::om_notify_om_asObservationNonHeads_filter()
{
}
void Observation::om_notify_om_asSimulatedObservationHeads_filter()
{
}
void Observation::om_notify_pop_pool()
{
}
void Observation::om_notify_time()
{
}
void Observation::om_reset_derived_attributes()
{
}
void Observation::om_set_entity_id()
{
    entity_id.set(get_next_entity_id());
}
void Observation::om_side_effects_age(Time om_old, Time om_new)
{
}
void Observation::om_side_effects_case_seed(double om_old, double om_new)
{
}
void Observation::om_side_effects_entity_id(int om_old, int om_new)
{
}
void Observation::om_side_effects_events(counter om_old, counter om_new)
{
}
void Observation::om_side_effects_fam_id(FAM_ID om_old, FAM_ID om_new)
{

    // Code Injection: group=10, injector=asObservationByFam
    // cell change in asObservationByFam
    if (om_active) {
        om_asObservationByFam_erase();
        om_asObservationByFam_update_cell();
        om_asObservationByFam_insert();
    }

    // Code Injection: group=10, injector=asObservationByFamOldest
    // cell change in asObservationByFamOldest
    if (om_active) {
        if (om_asObservationByFamOldest_filter) {
            om_asObservationByFamOldest_erase();
            om_asObservationByFamOldest_update_cell();
            om_asObservationByFamOldest_insert();
        }
    }

    // Code Injection: group=10, injector=asObservationNonHeads
    // cell change in asObservationNonHeads
    if (om_active) {
        if (om_asObservationNonHeads_filter) {
            om_asObservationNonHeads_erase();
            om_asObservationNonHeads_update_cell();
            om_asObservationNonHeads_insert();
        }
    }
}
void Observation::om_side_effects_obs_birth(Time om_old, Time om_new)
{
}
void Observation::om_side_effects_obs_oldest(bool om_old, bool om_new)
{

    // Code Injection: group=8, injector=om_asObservationByFamOldest_filter
    // Maintain identity for 'om_asObservationByFamOldest_filter'
    om_asObservationByFamOldest_filter_update_identity();

    // Code Injection: group=8, injector=om_asObservationHeads_filter
    // Maintain identity for 'om_asObservationHeads_filter'
    om_asObservationHeads_filter_update_identity();

    // Code Injection: group=8, injector=om_asObservationNonHeads_filter
    // Maintain identity for 'om_asObservationNonHeads_filter'
    om_asObservationNonHeads_filter_update_identity();

    // Code Injection: group=8, injector=om_asSimulatedObservationHeads_filter
    // Maintain identity for 'om_asSimulatedObservationHeads_filter'
    om_asSimulatedObservationHeads_filter_update_identity();
}
void Observation::om_side_effects_obs_weight(integer om_old, integer om_new)
{

    // Code Injection: group=8, injector=om_asSimulatedObservationHeads_filter
    // Maintain identity for 'om_asSimulatedObservationHeads_filter'
    om_asSimulatedObservationHeads_filter_update_identity();
}
void Observation::om_side_effects_om_asObservationByFamOldest_filter(bool om_old, bool om_new)
{

    // Code Injection: group=10, injector=asObservationByFamOldest
    // filter change in asObservationByFamOldest
    if (om_active) {
        if (om_new) {
            // filter changed from false to true
            om_asObservationByFamOldest_update_cell();
            om_asObservationByFamOldest_insert();
        }
        else {
            // filter changed from true to false
            om_asObservationByFamOldest_erase();
        }
    }
}
void Observation::om_side_effects_om_asObservationHeads_filter(bool om_old, bool om_new)
{

    // Code Injection: group=10, injector=asObservationHeads
    // filter change in asObservationHeads
    if (om_active) {
        if (om_new) {
            // filter changed from false to true
            om_asObservationHeads_update_cell();
            om_asObservationHeads_insert();
        }
        else {
            // filter changed from true to false
            om_asObservationHeads_erase();
        }
    }
}
void Observation::om_side_effects_om_asObservationNonHeads_filter(bool om_old, bool om_new)
{

    // Code Injection: group=10, injector=asObservationNonHeads
    // filter change in asObservationNonHeads
    if (om_active) {
        if (om_new) {
            // filter changed from false to true
            om_asObservationNonHeads_update_cell();
            om_asObservationNonHeads_insert();
        }
        else {
            // filter changed from true to false
            om_asObservationNonHeads_erase();
        }
    }
}
void Observation::om_side_effects_om_asSimulatedObservationHeads_filter(bool om_old, bool om_new)
{

    // Code Injection: group=10, injector=asSimulatedObservationHeads
    // filter change in asSimulatedObservationHeads
    if (om_active) {
        if (om_new) {
            // filter changed from false to true
            om_asSimulatedObservationHeads_update_cell();
            om_asSimulatedObservationHeads_insert();
        }
        else {
            // filter changed from true to false
            om_asSimulatedObservationHeads_erase();
        }
    }
}
void Observation::om_side_effects_pop_pool(POP_POOL om_old, POP_POOL om_new)
{

    // Code Injection: group=10, injector=asObservationAll
    // cell change in asObservationAll
    if (om_active) {
        om_asObservationAll_erase();
        om_asObservationAll_update_cell();
        om_asObservationAll_insert();
    }

    // Code Injection: group=10, injector=asObservationHeads
    // cell change in asObservationHeads
    if (om_active) {
        if (om_asObservationHeads_filter) {
            om_asObservationHeads_erase();
            om_asObservationHeads_update_cell();
            om_asObservationHeads_insert();
        }
    }

    // Code Injection: group=10, injector=asObservationNonHeads
    // cell change in asObservationNonHeads
    if (om_active) {
        if (om_asObservationNonHeads_filter) {
            om_asObservationNonHeads_erase();
            om_asObservationNonHeads_update_cell();
            om_asObservationNonHeads_insert();
        }
    }

    // Code Injection: group=10, injector=asSimulatedObservationHeads
    // cell change in asSimulatedObservationHeads
    if (om_active) {
        if (om_asSimulatedObservationHeads_filter) {
            om_asSimulatedObservationHeads_erase();
            om_asSimulatedObservationHeads_update_cell();
            om_asSimulatedObservationHeads_insert();
        }
    }
}
void Observation::om_side_effects_time(Time om_old, Time om_new)
{
    // Amount of time increment
    Time om_delta = om_new - om_old;

    // Code Injection: group=2, injector=age
    if (om_active) {
        // Advance time for the attribute 'age'
        age.set(age.get() + om_delta);
    }
}

const std::string Observation::om_name_age = "age";
const std::string Observation::om_name_case_seed = "case_seed";
const std::string Observation::om_name_entity_id = "entity_id";
const std::string Observation::om_name_events = "events";
const std::string Observation::om_name_fam_id = "fam_id";
const std::string Observation::om_name_obs_birth = "obs_birth";
const std::string Observation::om_name_obs_oldest = "obs_oldest";
const std::string Observation::om_name_obs_weight = "obs_weight";
const std::string Observation::om_name_om_asObservationByFamOldest_filter = "om_asObservationByFamOldest_filter";
const std::string Observation::om_name_om_asObservationHeads_filter = "om_asObservationHeads_filter";
const std::string Observation::om_name_om_asObservationNonHeads_filter = "om_asObservationNonHeads_filter";
const std::string Observation::om_name_om_asSimulatedObservationHeads_filter = "om_asSimulatedObservationHeads_filter";
const std::string Observation::om_name_pop_pool = "pop_pool";
const std::string Observation::om_name_time = "time";

// The definition of the static member Observation
// used to retrieve (zero) values when dereferencing nullptr link attributes.
thread_local Observation Observation::om_null_agent;
void Person::age_agent(Time t)
{
    if (time < t) {
        // Age the entity forward to the given time.
        time.set(t);
    }
    else {
        // The entity is already older than the given time.
        // This is normal if another entity is 'catching up' to this entity in its own events.
        // It is a model error if the current event is in this entity,
        // since that implies that an event is trying to make time run backwards for this entity.
        // This condition is detected and handled outside of this function.
    }
}
void Person::age_last_birth_update_identity()
{
    #line 95 "../code/FamilyFemalePartnershipStatus.mpp"
    age_last_birth.set((lives_with_dependent_child ? (integer_age - age_youngest_child) : time_infinite));
}
#line 4147 "C:/Users/Martin/Dropbox/openM++/models/Dynamis-Pop-3-06-ABC/ompp/src/om_definitions.cpp"
void Person::age_mig_update_identity()
{
    #line 43 "../code/MigrationGeneral.mpp"
    age_mig.set(COERCE(AGE_MIG, om_self_scheduling_split_FOR_age_X_AGE_MIG_PART));
}
#line 4153 "C:/Users/Martin/Dropbox/openM++/models/Dynamis-Pop-3-06-ABC/ompp/src/om_definitions.cpp"
void Person::age_youngest_child_update_identity()
{
    #line 84 "../code/FamilyFemalePartnershipStatus.mpp"
    age_youngest_child.set((((sex == FEMALE) && (om_mlHHMotherChildren_count > 0)) ? double(om_mlHHMotherChildren_min_over_integer_age) : time_infinite));
}
#line 4159 "C:/Users/Martin/Dropbox/openM++/models/Dynamis-Pop-3-06-ABC/ompp/src/om_definitions.cpp"
void Person::all_year_update_identity()
{
    #line 23 "../code/TablesPopulation.mpp"
    all_year.set(COERCE(ALL_YEAR_RANGE, calendar_year));
}
#line 4165 "C:/Users/Martin/Dropbox/openM++/models/Dynamis-Pop-3-06-ABC/ompp/src/om_definitions.cpp"
Time Person::check_time(Time t)
{
    if (t < time) {
        std::stringstream ss;
        ss << std::setprecision(std::numeric_limits<long double>::digits10 + 1) // maximum precision
           << LT("error : time ") << std::showpoint << t
           << LT(" is earlier than current time ") << (double)time
           << LT(" in entity_id ") << entity_id
           << LT(" in simulation member ") << get_simulation_member()
           << LT(" with combined seed ") << get_combined_seed()
            ;
        throw openm::SimulationException(ss.str().c_str());
    }
    return t;
}
void Person::child_agegr_part_update_identity()
{
    #line 88 "../code/FamilyFemalePartnershipStatus.mpp"
    child_agegr_part.set(om_split_FOR_age_youngest_child_X_CHILD_AGEGR_PART);
}
#line 4186 "C:/Users/Martin/Dropbox/openM++/models/Dynamis-Pop-3-06-ABC/ompp/src/om_definitions.cpp"
void Person::child_agegr_update_identity()
{
    #line 109 "../code/FamilyFemalePartnershipStatus.mpp"
    child_agegr.set(((child_agegr_part == 0) ? CA00 : ((child_agegr_part == 1) ? CA01 : ((child_agegr_part == 2) ? CA03 : ((child_agegr_part == 3) ? CA06 : ((child_agegr_part == 4) ? CA09 : ((child_agegr_part == 5) ? CA12 : CA15)))))));
}
#line 4192 "C:/Users/Martin/Dropbox/openM++/models/Dynamis-Pop-3-06-ABC/ompp/src/om_definitions.cpp"
void Person::child_mortality_group_update_identity()
{
    #line 70 "../code/MortalityDetailed.mpp"
    child_mortality_group.set((((mother_age_at_birth >= 17) && (educ_mother == EOL_HIGH)) ? CMG_00 : (((mother_age_at_birth >= 17) && (educ_mother == EOL_MEDIUM)) ? CMG_01 : (((mother_age_at_birth >= 17) && (educ_mother == EOL_LOW)) ? CMG_02 : (((mother_age_at_birth >= 15) && (educ_mother == EOL_HIGH)) ? CMG_03 : (((mother_age_at_birth >= 15) && (educ_mother == EOL_MEDIUM)) ? CMG_04 : (((mother_age_at_birth >= 15) && (educ_mother == EOL_LOW)) ? CMG_05 : ((educ_mother == EOL_HIGH) ? CMG_06 : ((educ_mother == EOL_MEDIUM) ? CMG_07 : CMG_08)))))))));
}
#line 4198 "C:/Users/Martin/Dropbox/openM++/models/Dynamis-Pop-3-06-ABC/ompp/src/om_definitions.cpp"
void Person::child_mortality_update_identity()
{
    #line 57 "../code/MortalityDetailed.mpp"
    child_mortality.set((((integer_age == 0) && (sex == MALE)) ? double(lCalibrator->mort_male_0) : (((integer_age == 1) && (sex == MALE)) ? double(lCalibrator->mort_male_1) : (((integer_age == 2) && (sex == MALE)) ? double(lCalibrator->mort_male_2) : (((integer_age == 3) && (sex == MALE)) ? double(lCalibrator->mort_male_3) : (((integer_age == 4) && (sex == MALE)) ? double(lCalibrator->mort_male_4) : (((integer_age == 0) && (sex == FEMALE)) ? double(lCalibrator->mort_female_0) : (((integer_age == 1) && (sex == FEMALE)) ? double(lCalibrator->mort_female_1) : (((integer_age == 2) && (sex == FEMALE)) ? double(lCalibrator->mort_female_2) : (((integer_age == 3) && (sex == FEMALE)) ? double(lCalibrator->mort_female_3) : (((integer_age == 4) && (sex == FEMALE)) ? double(lCalibrator->mort_female_4) : 0.0)))))))))));
}
#line 4204 "C:/Users/Martin/Dropbox/openM++/models/Dynamis-Pop-3-06-ABC/ompp/src/om_definitions.cpp"
void Person::children_in_household_update_identity()
{
    #line 74 "../code/FamilyGeneral.mpp"
    children_in_household.set(((sex == FEMALE) ? om_mlHHMotherChildren_sum_over_is_alive : om_mlHHFatherChildren_sum_over_is_alive));
}
#line 4210 "C:/Users/Martin/Dropbox/openM++/models/Dynamis-Pop-3-06-ABC/ompp/src/om_definitions.cpp"
void Person::educ1_group_update_identity()
{
    #line 100 "../code/EducationPrimaryTransmission.mpp"
    educ1_group.set(((educ_mother == EOL_LOW) ? E1G_00 : ((educ_mother == EOL_MEDIUM) ? E1G_01 : E1G_02)));
}
#line 4216 "C:/Users/Martin/Dropbox/openM++/models/Dynamis-Pop-3-06-ABC/ompp/src/om_definitions.cpp"
void Person::educ_one_grade_update_identity()
{
    #line 107 "../code/EducationPrimaryTracking.mpp"
    educ_one_grade.set(COERCE(EDUC_ONE_GRADE, educ_one_grade_attended));
}
#line 4222 "C:/Users/Martin/Dropbox/openM++/models/Dynamis-Pop-3-06-ABC/ompp/src/om_definitions.cpp"
void Person::educ_one_level_update_identity()
{
    #line 111 "../code/EducationPrimaryTracking.mpp"
    educ_one_level.set(((educ_one_grade_passed == MAX(EDUC_ONE_GRADE)) ? EOL_HIGH : ((educ_one_grade_attended == 0) ? EOL_LOW : EOL_MEDIUM)));
}
#line 4228 "C:/Users/Martin/Dropbox/openM++/models/Dynamis-Pop-3-06-ABC/ompp/src/om_definitions.cpp"
void Person::educ_one_required_rooms_update_identity()
{
    #line 42 "../code/EducationPrimaryPlanning.mpp"
    educ_one_required_rooms.set(((is_educ_one_student && is_resident) ? (1.0 / Educ1Infrastructure[SI_ROOMS][geo_nat][RANGE_POS(SIM_YEAR_RANGE, calendar_year)]) : 0.0));
}
#line 4234 "C:/Users/Martin/Dropbox/openM++/models/Dynamis-Pop-3-06-ABC/ompp/src/om_definitions.cpp"
void Person::educ_one_required_teachers_update_identity()
{
    #line 38 "../code/EducationPrimaryPlanning.mpp"
    educ_one_required_teachers.set(((is_educ_one_student && is_resident) ? (1.0 / Educ1Infrastructure[SI_TEACHERS][geo_nat][RANGE_POS(SIM_YEAR_RANGE, calendar_year)]) : 0.0));
}
#line 4240 "C:/Users/Martin/Dropbox/openM++/models/Dynamis-Pop-3-06-ABC/ompp/src/om_definitions.cpp"
void Person::educ_two_level_update_identity()
{
    #line 112 "../code/EducationSecondaryBase.mpp"
    educ_two_level.set(((educ_two_status == ETS_NEVER) ? ETL_NEVER : ((educ_two_grade_passed == MAX(EDUC_TWO_GRADE)) ? ETL_INCOMPLETE : ETL_GRADUATE)));
}
#line 4246 "C:/Users/Martin/Dropbox/openM++/models/Dynamis-Pop-3-06-ABC/ompp/src/om_definitions.cpp"
void Person::ethnicity_short_update_identity()
{
    #line 52 "../code/ChildVaccination.mpp"
    ethnicity_short.set(om_aggregate_FOR_ethnicity_X_ETHNICITY_SHORT);
}
#line 4252 "C:/Users/Martin/Dropbox/openM++/models/Dynamis-Pop-3-06-ABC/ompp/src/om_definitions.cpp"
void Person::family_role_update_identity()
{
    #line 71 "../code/FamilyGeneral.mpp"
    family_role.set(((lSpouse && (sex == MALE)) ? FR_SPOUSE : ((lHHFather || lHHMother) ? FR_CHILD : FR_HEAD)));
}
#line 4258 "C:/Users/Martin/Dropbox/openM++/models/Dynamis-Pop-3-06-ABC/ompp/src/om_definitions.cpp"
void Person::female_spouse_age_update_identity()
{
    #line 81 "../code/FamilyPartnerMatching.mpp"
    female_spouse_age.set(((sex == FEMALE) ? COERCE(FEMALE_SPOUSE_AGE, integer_age) : MAX(FEMALE_SPOUSE_AGE)));
}
#line 4264 "C:/Users/Martin/Dropbox/openM++/models/Dynamis-Pop-3-06-ABC/ompp/src/om_definitions.cpp"
void Person::fertile_age_update_identity()
{
    #line 49 "../code/FertilityGeneral.mpp"
    fertile_age.set(COERCE(FERTILE_AGE_RANGE, integer_age));
}
#line 4270 "C:/Users/Martin/Dropbox/openM++/models/Dynamis-Pop-3-06-ABC/ompp/src/om_definitions.cpp"
void Person::geo_nat_update_identity()
{
    #line 55 "../code/MigrationGeneral.mpp"
    geo_nat.set(om_aggregate_FOR_geo_X_GEO_NAT);
}
#line 4276 "C:/Users/Martin/Dropbox/openM++/models/Dynamis-Pop-3-06-ABC/ompp/src/om_definitions.cpp"
void Person::has_passed_primary_update_identity()
{
    #line 25 "../code/TablesEducation.mpp"
    has_passed_primary.set((educ_one_grade_passed == MAX(EDUC_ONE_GRADE)));
}
#line 4282 "C:/Users/Martin/Dropbox/openM++/models/Dynamis-Pop-3-06-ABC/ompp/src/om_definitions.cpp"
void Person::has_spouse_update_identity()
{
    #line 83 "../code/FamilyPartnerMatching.mpp"
    has_spouse.set((lSpouse ? true : false));
}
#line 4288 "C:/Users/Martin/Dropbox/openM++/models/Dynamis-Pop-3-06-ABC/ompp/src/om_definitions.cpp"
void Person::in_hci_sample_update_identity()
{
    #line 82 "../code/HumanCapitalIndex.mpp"
    in_hci_sample.set((((creation_type == CT_BIRTH) && (geo_birth < SIZE(GEO_NAT))) ? true : false));
}
#line 4294 "C:/Users/Martin/Dropbox/openM++/models/Dynamis-Pop-3-06-ABC/ompp/src/om_definitions.cpp"
void Person::in_projected_time_update_identity()
{
    #line 18 "../code/TablesEducation.mpp"
    in_projected_time.set((calendar_year >= MIN(SIM_YEAR_RANGE)));
}
#line 4300 "C:/Users/Martin/Dropbox/openM++/models/Dynamis-Pop-3-06-ABC/ompp/src/om_definitions.cpp"
void Person::in_sel_years_update_identity()
{
    #line 34 "../code/_ContextABC.mpp"
    in_sel_years.set((((((((calendar_year == 2000) || (calendar_year == 2010)) || (calendar_year == 2020)) || (calendar_year == 2030)) || (calendar_year == 2040)) || (calendar_year == 2050)) || (calendar_year == 2060)));
}
#line 4306 "C:/Users/Martin/Dropbox/openM++/models/Dynamis-Pop-3-06-ABC/ompp/src/om_definitions.cpp"
void Person::in_selected_year_update_identity()
{
    #line 34 "../code/TablesPopulation.mpp"
    in_selected_year.set(((selected_year10 != SY40) || (calendar_year == (MIN(SIM_YEAR_RANGE) + 40))));
}
#line 4312 "C:/Users/Martin/Dropbox/openM++/models/Dynamis-Pop-3-06-ABC/ompp/src/om_definitions.cpp"
void Person::is_aded0_update_identity()
{
    #line 22 "../code/TablesEducation.mpp"
    is_aded0.set(((!is_child && !is_old) && (educ_one_fate == EOL_LOW)));
}
#line 4318 "C:/Users/Martin/Dropbox/openM++/models/Dynamis-Pop-3-06-ABC/ompp/src/om_definitions.cpp"
void Person::is_aded1_update_identity()
{
    #line 23 "../code/TablesEducation.mpp"
    is_aded1.set(((!is_child && !is_old) && (educ_one_fate == EOL_MEDIUM)));
}
#line 4324 "C:/Users/Martin/Dropbox/openM++/models/Dynamis-Pop-3-06-ABC/ompp/src/om_definitions.cpp"
void Person::is_aded2_update_identity()
{
    #line 24 "../code/TablesEducation.mpp"
    is_aded2.set(((!is_child && !is_old) && (educ_one_fate == EOL_HIGH)));
}
#line 4330 "C:/Users/Martin/Dropbox/openM++/models/Dynamis-Pop-3-06-ABC/ompp/src/om_definitions.cpp"
void Person::is_adult_update_identity()
{
    #line 103 "../code/HumanCapitalIndex.mpp"
    is_adult.set(((integer_age >= 15) ? true : false));
}
#line 4336 "C:/Users/Martin/Dropbox/openM++/models/Dynamis-Pop-3-06-ABC/ompp/src/om_definitions.cpp"
void Person::is_child_update_identity()
{
    #line 20 "../code/TablesEducation.mpp"
    is_child.set((integer_age < 15));
}
#line 4342 "C:/Users/Martin/Dropbox/openM++/models/Dynamis-Pop-3-06-ABC/ompp/src/om_definitions.cpp"
void Person::is_educ_one_student_update_identity()
{
    #line 103 "../code/EducationPrimaryTracking.mpp"
    is_educ_one_student.set((((educ_one_status == EOS_ATTEND) || ((educ_one_status == EOS_WAIT) && (educ_one_grade_attended > 0))) ? true : false));
}
#line 4348 "C:/Users/Martin/Dropbox/openM++/models/Dynamis-Pop-3-06-ABC/ompp/src/om_definitions.cpp"
void Person::is_fertile_update_identity()
{
    #line 44 "../code/FertilityGeneral.mpp"
    is_fertile.set(((((sex == FEMALE) && WITHIN(FERTILE_AGE_RANGE, integer_age)) && ((((creation_type == CT_BIRTH) || ((creation_type == CT_START) && (calendar_year >= MIN(SIM_YEAR_RANGE)))) || ((creation_type == CT_POOL) && ever_resident)) || ((creation_type == CT_SCRATCH) && ever_resident))) ? true : false));
}
#line 4354 "C:/Users/Martin/Dropbox/openM++/models/Dynamis-Pop-3-06-ABC/ompp/src/om_definitions.cpp"
void Person::is_mortal_update_identity()
{
    #line 42 "../code/MortalityGeneral.mpp"
    is_mortal.set((((((creation_type == CT_BIRTH) || ((creation_type == CT_START) && (calendar_year >= MIN(SIM_YEAR_RANGE)))) || ((creation_type == CT_POOL) && ever_resident)) || ((creation_type == CT_SCRATCH) && ever_resident)) ? true : false));
}
#line 4360 "C:/Users/Martin/Dropbox/openM++/models/Dynamis-Pop-3-06-ABC/ompp/src/om_definitions.cpp"
void Person::is_old_update_identity()
{
    #line 21 "../code/TablesEducation.mpp"
    is_old.set((integer_age >= 60));
}
#line 4366 "C:/Users/Martin/Dropbox/openM++/models/Dynamis-Pop-3-06-ABC/ompp/src/om_definitions.cpp"
void Person::is_resident_update_identity()
{
    #line 79 "../code/ActorPerson.mpp"
    is_resident.set((geo < SIZE(GEO_NAT)));
}
#line 4372 "C:/Users/Martin/Dropbox/openM++/models/Dynamis-Pop-3-06-ABC/ompp/src/om_definitions.cpp"
void Person::lives_with_dependent_child_update_identity()
{
    #line 91 "../code/FamilyFemalePartnershipStatus.mpp"
    lives_with_dependent_child.set(((((sex == FEMALE) && (om_mlHHMotherChildren_count > 0)) || ((sex == MALE) && (om_mlHHFatherChildren_count > 0))) ? true : false));
}
#line 4378 "C:/Users/Martin/Dropbox/openM++/models/Dynamis-Pop-3-06-ABC/ompp/src/om_definitions.cpp"
void Person::male_age_update_identity()
{
    #line 78 "../code/FamilyPartnerMatching.mpp"
    male_age.set(((sex == MALE) ? COERCE(MALE_SPOUSE_AGE, integer_age) : MAX(MALE_SPOUSE_AGE)));
}
#line 4384 "C:/Users/Martin/Dropbox/openM++/models/Dynamis-Pop-3-06-ABC/ompp/src/om_definitions.cpp"
void Person::male_spouse_age_update_identity()
{
    #line 75 "../code/FamilyPartnerMatching.mpp"
    male_spouse_age.set(((has_spouse && (sex == FEMALE)) ? COERCE(MALE_SPOUSE_AGE, lSpouse->integer_age) : MAX(MALE_SPOUSE_AGE)));
}
#line 4390 "C:/Users/Martin/Dropbox/openM++/models/Dynamis-Pop-3-06-ABC/ompp/src/om_definitions.cpp"
void Person::moth_agegr_part_update_identity()
{
    #line 99 "../code/FamilyFemalePartnershipStatus.mpp"
    moth_agegr_part.set(om_split_FOR_age_last_birth_X_MOTH_AGEGR_PART);
}
#line 4396 "C:/Users/Martin/Dropbox/openM++/models/Dynamis-Pop-3-06-ABC/ompp/src/om_definitions.cpp"
void Person::moth_agegr_update_identity()
{
    #line 102 "../code/FamilyFemalePartnershipStatus.mpp"
    moth_agegr.set(((moth_agegr_part == 0) ? CMA20 : ((moth_agegr_part == 1) ? CMA25 : ((moth_agegr_part == 2) ? CMA30 : ((moth_agegr_part == 3) ? CMA35 : ((moth_agegr_part == 4) ? CMA40 : CMA40P))))));
}
#line 4402 "C:/Users/Martin/Dropbox/openM++/models/Dynamis-Pop-3-06-ABC/ompp/src/om_definitions.cpp"
int Person::om_PopPyramidByEduc_current_cell()
{
    assert(thePopPyramidByEduc); // unitary table must be instantiated

    // Dimensionality of table (does not include measure dimension)
    const size_t rank = 4;

    // Size of each dimension of table (includes margin if present)
    const std::array<size_t, rank> shape = {7, 3, 13, 21};

    // Dimension coordinates of current cell
    const std::array<size_t, rank> coordinates = {
        size_t(sel_years), 
        size_t(sex), 
        size_t(geo_nat), 
        size_t(om_split_FOR_integer_age_X_TAB_AGEC5), 
    };

    // Encode the dimension coordinates of the margin cell into flattened index
    size_t cell = coordinates[0];
    for (size_t j = 1; j < rank; ++j) {
        cell *= shape[j];
        cell += coordinates[j];
    }

    assert(cell >= 0 && cell < 5733); // logic guarantee
    return cell;
}
void Person::om_PopPyramidByEduc_init_increment(int pending, big_counter pending_event_counter)
{
    assert(thePopPyramidByEduc); // unitary table must be instantiated

    {
        // interval(om_duration_FOR_educ_one_level_X_EOL_LOW)
        auto & value_in = om_PopPyramidByEduc_in_om_duration_FOR_educ_one_level_X_EOL_LOW;
        Time value_curr = om_duration_FOR_educ_one_level_X_EOL_LOW;

        value_in = value_curr;
    }
    {
        // interval(om_duration_FOR_educ_one_level_X_EOL_MEDIUM)
        auto & value_in = om_PopPyramidByEduc_in_om_duration_FOR_educ_one_level_X_EOL_MEDIUM;
        Time value_curr = om_duration_FOR_educ_one_level_X_EOL_MEDIUM;

        value_in = value_curr;
    }
    {
        // interval(om_duration_FOR_educ_one_level_X_EOL_HIGH)
        auto & value_in = om_PopPyramidByEduc_in_om_duration_FOR_educ_one_level_X_EOL_HIGH;
        Time value_curr = om_duration_FOR_educ_one_level_X_EOL_HIGH;

        value_in = value_curr;
    }
}
void Person::om_PopPyramidByEduc_push_increment(int cell_in, int pending, big_counter pending_event_counter)
{
    assert(thePopPyramidByEduc); // unitary table must be instantiated

    auto& table = thePopPyramidByEduc;

    // Table has margins

    // Dimensionality of table (does not include measure dimension)
    const size_t rank = 4;

    // Size of each dimension of table (includes margin if present)
    const std::array<size_t, rank> shape = {7, 3, 13, 21};

    // Number of dimensions with a margin
    const size_t margin_count = 2;

    // Dimensions with a margin
    const std::array<size_t, margin_count> margin_dims = {1, 2};

    // Number of margin combinations for a cell in the table body
    // e.g. a table with 3 margins has 2^3-1=7 margin cells associated with a body cell
    const size_t margin_combos = (1 << margin_count) - 1;

    // Indexes of table cells to increment (cell in table body and cells in margins)
    std::array<size_t, 1 + margin_combos> cells_to_increment;

    // Populate cells_to_increment

    // The cell in the table body:
    cells_to_increment[0] = cell_in;

    // The margin cells
    {
        // Dimension coordinates of the body cell being incremented
        std::array<size_t, rank> body_coordinates;
        // Decode dimension coordinates of the body cell
        for (int j = rank - 1, w = cell_in; j >= 0; --j) {
            body_coordinates[j] = w % shape[j];
            w /= shape[j];
        }
        // Working coordinates of a margin cell
        std::array<size_t, rank> margin_coordinates;
        for (size_t combo = 1; combo <= margin_combos; ++combo) {
            // The binary bits of combo select the margin dimensions for the combination.
            margin_coordinates = body_coordinates;
            size_t bits = combo;
            for (size_t margin = 0; margin < margin_count; ++margin) {
                // read out the bits in combo
                if (bits & 1) {
                    // low order bit is 1, so replace coordinate from body cell by margin coordinate
                    margin_coordinates[margin_dims[margin]] = shape[margin_dims[margin]] - 1;
                }
                bits >>= 1;
            }
            // Encode the dimension coordinates of the margin cell into flattened index
            size_t margin_cell = margin_coordinates[0];
            for (size_t j = 1; j < rank; ++j) {
                margin_cell *= shape[j];
                margin_cell += margin_coordinates[j];
            }
            assert(margin_cell >= 0 && margin_cell < 5733); // logic guarantee
            cells_to_increment[combo] = margin_cell;
        }
    }

    // Increments and Accumulators:
    //  accumulator 0: sum(delta(interval(duration(educ_one_level, EOL_LOW))))
    {
        const int acc_index = 0; // accumulator index

        // Compute increment
        Time value_out = om_duration_FOR_educ_one_level_X_EOL_LOW;
        auto& value_in = om_PopPyramidByEduc_in_om_duration_FOR_educ_one_level_X_EOL_LOW;

        double dIncrement;
        dIncrement = (double)value_out - (double)value_in;

        // Push increment to body cell and margin cells
        for (int cell : cells_to_increment) {
            auto& dAccumulator = table->acc[acc_index][cell];
            dAccumulator += dIncrement;
        }
    }
    //  accumulator 1: sum(delta(interval(duration(educ_one_level, EOL_MEDIUM))))
    {
        const int acc_index = 1; // accumulator index

        // Compute increment
        Time value_out = om_duration_FOR_educ_one_level_X_EOL_MEDIUM;
        auto& value_in = om_PopPyramidByEduc_in_om_duration_FOR_educ_one_level_X_EOL_MEDIUM;

        double dIncrement;
        dIncrement = (double)value_out - (double)value_in;

        // Push increment to body cell and margin cells
        for (int cell : cells_to_increment) {
            auto& dAccumulator = table->acc[acc_index][cell];
            dAccumulator += dIncrement;
        }
    }
    //  accumulator 2: sum(delta(interval(duration(educ_one_level, EOL_HIGH))))
    {
        const int acc_index = 2; // accumulator index

        // Compute increment
        Time value_out = om_duration_FOR_educ_one_level_X_EOL_HIGH;
        auto& value_in = om_PopPyramidByEduc_in_om_duration_FOR_educ_one_level_X_EOL_HIGH;

        double dIncrement;
        dIncrement = (double)value_out - (double)value_in;

        // Push increment to body cell and margin cells
        for (int cell : cells_to_increment) {
            auto& dAccumulator = table->acc[acc_index][cell];
            dAccumulator += dIncrement;
        }
    }
}
int Person::om_TabChildVaccination_current_cell()
{
    assert(theTabChildVaccination); // unitary table must be instantiated

    // Dimensionality of table (does not include measure dimension)
    const size_t rank = 2;

    // Size of each dimension of table (includes margin if present)
    const std::array<size_t, rank> shape = {151, 6};

    // Dimension coordinates of current cell
    const std::array<size_t, rank> coordinates = {
        size_t(sim_year - 2000), 
        size_t(region_nat), 
    };

    // Encode the dimension coordinates of the margin cell into flattened index
    size_t cell = coordinates[0];
    for (size_t j = 1; j < rank; ++j) {
        cell *= shape[j];
        cell += coordinates[j];
    }

    assert(cell >= 0 && cell < 906); // logic guarantee
    return cell;
}
void Person::om_TabChildVaccination_init_increment(int pending, big_counter pending_event_counter)
{
    assert(theTabChildVaccination); // unitary table must be instantiated

    {
        // interval(om_duration_FOR_is_immunized_X_true)
        auto & value_in = om_TabChildVaccination_in_om_duration_FOR_is_immunized_X_true;
        Time value_curr = om_duration_FOR_is_immunized_X_true;

        value_in = value_curr;
    }
    {
        // interval(om_duration)
        auto & value_in = om_TabChildVaccination_in_om_duration;
        Time value_curr = om_duration;

        value_in = value_curr;
    }
}
void Person::om_TabChildVaccination_push_increment(int cell_in, int pending, big_counter pending_event_counter)
{
    assert(theTabChildVaccination); // unitary table must be instantiated

    auto& table = theTabChildVaccination;

    // Table has margins

    // Dimensionality of table (does not include measure dimension)
    const size_t rank = 2;

    // Size of each dimension of table (includes margin if present)
    const std::array<size_t, rank> shape = {151, 6};

    // Number of dimensions with a margin
    const size_t margin_count = 1;

    // Dimensions with a margin
    const std::array<size_t, margin_count> margin_dims = {1};

    // Number of margin combinations for a cell in the table body
    // e.g. a table with 3 margins has 2^3-1=7 margin cells associated with a body cell
    const size_t margin_combos = (1 << margin_count) - 1;

    // Indexes of table cells to increment (cell in table body and cells in margins)
    std::array<size_t, 1 + margin_combos> cells_to_increment;

    // Populate cells_to_increment

    // The cell in the table body:
    cells_to_increment[0] = cell_in;

    // The margin cells
    {
        // Dimension coordinates of the body cell being incremented
        std::array<size_t, rank> body_coordinates;
        // Decode dimension coordinates of the body cell
        for (int j = rank - 1, w = cell_in; j >= 0; --j) {
            body_coordinates[j] = w % shape[j];
            w /= shape[j];
        }
        // Working coordinates of a margin cell
        std::array<size_t, rank> margin_coordinates;
        for (size_t combo = 1; combo <= margin_combos; ++combo) {
            // The binary bits of combo select the margin dimensions for the combination.
            margin_coordinates = body_coordinates;
            size_t bits = combo;
            for (size_t margin = 0; margin < margin_count; ++margin) {
                // read out the bits in combo
                if (bits & 1) {
                    // low order bit is 1, so replace coordinate from body cell by margin coordinate
                    margin_coordinates[margin_dims[margin]] = shape[margin_dims[margin]] - 1;
                }
                bits >>= 1;
            }
            // Encode the dimension coordinates of the margin cell into flattened index
            size_t margin_cell = margin_coordinates[0];
            for (size_t j = 1; j < rank; ++j) {
                margin_cell *= shape[j];
                margin_cell += margin_coordinates[j];
            }
            assert(margin_cell >= 0 && margin_cell < 906); // logic guarantee
            cells_to_increment[combo] = margin_cell;
        }
    }

    // Increments and Accumulators:
    //  accumulator 0: sum(delta(interval(duration(is_immunized, true))))
    {
        const int acc_index = 0; // accumulator index

        // Compute increment
        Time value_out = om_duration_FOR_is_immunized_X_true;
        auto& value_in = om_TabChildVaccination_in_om_duration_FOR_is_immunized_X_true;

        double dIncrement;
        dIncrement = (double)value_out - (double)value_in;

        // Push increment to body cell and margin cells
        for (int cell : cells_to_increment) {
            auto& dAccumulator = table->acc[acc_index][cell];
            dAccumulator += dIncrement;
        }
    }
    //  accumulator 1: sum(delta(interval(duration())))
    {
        const int acc_index = 1; // accumulator index

        // Compute increment
        Time value_out = om_duration;
        auto& value_in = om_TabChildVaccination_in_om_duration;

        double dIncrement;
        dIncrement = (double)value_out - (double)value_in;

        // Push increment to body cell and margin cells
        for (int cell : cells_to_increment) {
            auto& dAccumulator = table->acc[acc_index][cell];
            dAccumulator += dIncrement;
        }
    }
}
int Person::om_TabEduc15ByDistrictBirth_current_cell()
{
    assert(theTabEduc15ByDistrictBirth); // unitary table must be instantiated

    // Dimensionality of table (does not include measure dimension)
    const size_t rank = 3;

    // Size of each dimension of table (includes margin if present)
    const std::array<size_t, rank> shape = {14, 3, 151};

    // Dimension coordinates of current cell
    const std::array<size_t, rank> coordinates = {
        size_t(geo_birth), 
        size_t(sex), 
        size_t(sim_year - 2000), 
    };

    // Encode the dimension coordinates of the margin cell into flattened index
    size_t cell = coordinates[0];
    for (size_t j = 1; j < rank; ++j) {
        cell *= shape[j];
        cell += coordinates[j];
    }

    assert(cell >= 0 && cell < 6342); // logic guarantee
    return cell;
}
void Person::om_TabEduc15ByDistrictBirth_init_increment(int pending, big_counter pending_event_counter)
{
    assert(theTabEduc15ByDistrictBirth); // unitary table must be instantiated

    {
        // interval(om_duration_FOR_educ_one_fate_X_EOL_LOW)
        auto & value_in = om_TabEduc15ByDistrictBirth_in_om_duration_FOR_educ_one_fate_X_EOL_LOW;
        Time value_curr = om_duration_FOR_educ_one_fate_X_EOL_LOW;

        value_in = value_curr;
    }
    {
        // interval(om_duration)
        auto & value_in = om_TabEduc15ByDistrictBirth_in_om_duration;
        Time value_curr = om_duration;

        value_in = value_curr;
    }
    {
        // interval(om_duration_FOR_educ_one_fate_X_EOL_MEDIUM)
        auto & value_in = om_TabEduc15ByDistrictBirth_in_om_duration_FOR_educ_one_fate_X_EOL_MEDIUM;
        Time value_curr = om_duration_FOR_educ_one_fate_X_EOL_MEDIUM;

        value_in = value_curr;
    }
    {
        // interval(om_duration_FOR_educ_one_fate_X_EOL_HIGH)
        auto & value_in = om_TabEduc15ByDistrictBirth_in_om_duration_FOR_educ_one_fate_X_EOL_HIGH;
        Time value_curr = om_duration_FOR_educ_one_fate_X_EOL_HIGH;

        value_in = value_curr;
    }
}
void Person::om_TabEduc15ByDistrictBirth_push_increment(int cell_in, int pending, big_counter pending_event_counter)
{
    assert(theTabEduc15ByDistrictBirth); // unitary table must be instantiated

    auto& table = theTabEduc15ByDistrictBirth;

    // Table has margins

    // Dimensionality of table (does not include measure dimension)
    const size_t rank = 3;

    // Size of each dimension of table (includes margin if present)
    const std::array<size_t, rank> shape = {14, 3, 151};

    // Number of dimensions with a margin
    const size_t margin_count = 2;

    // Dimensions with a margin
    const std::array<size_t, margin_count> margin_dims = {0, 1};

    // Number of margin combinations for a cell in the table body
    // e.g. a table with 3 margins has 2^3-1=7 margin cells associated with a body cell
    const size_t margin_combos = (1 << margin_count) - 1;

    // Indexes of table cells to increment (cell in table body and cells in margins)
    std::array<size_t, 1 + margin_combos> cells_to_increment;

    // Populate cells_to_increment

    // The cell in the table body:
    cells_to_increment[0] = cell_in;

    // The margin cells
    {
        // Dimension coordinates of the body cell being incremented
        std::array<size_t, rank> body_coordinates;
        // Decode dimension coordinates of the body cell
        for (int j = rank - 1, w = cell_in; j >= 0; --j) {
            body_coordinates[j] = w % shape[j];
            w /= shape[j];
        }
        // Working coordinates of a margin cell
        std::array<size_t, rank> margin_coordinates;
        for (size_t combo = 1; combo <= margin_combos; ++combo) {
            // The binary bits of combo select the margin dimensions for the combination.
            margin_coordinates = body_coordinates;
            size_t bits = combo;
            for (size_t margin = 0; margin < margin_count; ++margin) {
                // read out the bits in combo
                if (bits & 1) {
                    // low order bit is 1, so replace coordinate from body cell by margin coordinate
                    margin_coordinates[margin_dims[margin]] = shape[margin_dims[margin]] - 1;
                }
                bits >>= 1;
            }
            // Encode the dimension coordinates of the margin cell into flattened index
            size_t margin_cell = margin_coordinates[0];
            for (size_t j = 1; j < rank; ++j) {
                margin_cell *= shape[j];
                margin_cell += margin_coordinates[j];
            }
            assert(margin_cell >= 0 && margin_cell < 6342); // logic guarantee
            cells_to_increment[combo] = margin_cell;
        }
    }

    // Increments and Accumulators:
    //  accumulator 0: sum(delta(interval(duration(educ_one_fate, EOL_LOW))))
    {
        const int acc_index = 0; // accumulator index

        // Compute increment
        Time value_out = om_duration_FOR_educ_one_fate_X_EOL_LOW;
        auto& value_in = om_TabEduc15ByDistrictBirth_in_om_duration_FOR_educ_one_fate_X_EOL_LOW;

        double dIncrement;
        dIncrement = (double)value_out - (double)value_in;

        // Push increment to body cell and margin cells
        for (int cell : cells_to_increment) {
            auto& dAccumulator = table->acc[acc_index][cell];
            dAccumulator += dIncrement;
        }
    }
    //  accumulator 1: sum(delta(interval(duration())))
    {
        const int acc_index = 1; // accumulator index

        // Compute increment
        Time value_out = om_duration;
        auto& value_in = om_TabEduc15ByDistrictBirth_in_om_duration;

        double dIncrement;
        dIncrement = (double)value_out - (double)value_in;

        // Push increment to body cell and margin cells
        for (int cell : cells_to_increment) {
            auto& dAccumulator = table->acc[acc_index][cell];
            dAccumulator += dIncrement;
        }
    }
    //  accumulator 2: sum(delta(interval(duration(educ_one_fate, EOL_MEDIUM))))
    {
        const int acc_index = 2; // accumulator index

        // Compute increment
        Time value_out = om_duration_FOR_educ_one_fate_X_EOL_MEDIUM;
        auto& value_in = om_TabEduc15ByDistrictBirth_in_om_duration_FOR_educ_one_fate_X_EOL_MEDIUM;

        double dIncrement;
        dIncrement = (double)value_out - (double)value_in;

        // Push increment to body cell and margin cells
        for (int cell : cells_to_increment) {
            auto& dAccumulator = table->acc[acc_index][cell];
            dAccumulator += dIncrement;
        }
    }
    //  accumulator 3: sum(delta(interval(duration(educ_one_fate, EOL_HIGH))))
    {
        const int acc_index = 3; // accumulator index

        // Compute increment
        Time value_out = om_duration_FOR_educ_one_fate_X_EOL_HIGH;
        auto& value_in = om_TabEduc15ByDistrictBirth_in_om_duration_FOR_educ_one_fate_X_EOL_HIGH;

        double dIncrement;
        dIncrement = (double)value_out - (double)value_in;

        // Push increment to body cell and margin cells
        for (int cell : cells_to_increment) {
            auto& dAccumulator = table->acc[acc_index][cell];
            dAccumulator += dIncrement;
        }
    }
}
int Person::om_TabEduc15ByDistrict_current_cell()
{
    assert(theTabEduc15ByDistrict); // unitary table must be instantiated

    // Dimensionality of table (does not include measure dimension)
    const size_t rank = 3;

    // Size of each dimension of table (includes margin if present)
    const std::array<size_t, rank> shape = {13, 3, 151};

    // Dimension coordinates of current cell
    const std::array<size_t, rank> coordinates = {
        size_t(geo_nat), 
        size_t(sex), 
        size_t(sim_year - 2000), 
    };

    // Encode the dimension coordinates of the margin cell into flattened index
    size_t cell = coordinates[0];
    for (size_t j = 1; j < rank; ++j) {
        cell *= shape[j];
        cell += coordinates[j];
    }

    assert(cell >= 0 && cell < 5889); // logic guarantee
    return cell;
}
void Person::om_TabEduc15ByDistrict_init_increment(int pending, big_counter pending_event_counter)
{
    assert(theTabEduc15ByDistrict); // unitary table must be instantiated

    {
        // interval(om_duration_FOR_educ_one_fate_X_EOL_LOW)
        auto & value_in = om_TabEduc15ByDistrict_in_om_duration_FOR_educ_one_fate_X_EOL_LOW;
        Time value_curr = om_duration_FOR_educ_one_fate_X_EOL_LOW;

        value_in = value_curr;
    }
    {
        // interval(om_duration)
        auto & value_in = om_TabEduc15ByDistrict_in_om_duration;
        Time value_curr = om_duration;

        value_in = value_curr;
    }
    {
        // interval(om_duration_FOR_educ_one_fate_X_EOL_MEDIUM)
        auto & value_in = om_TabEduc15ByDistrict_in_om_duration_FOR_educ_one_fate_X_EOL_MEDIUM;
        Time value_curr = om_duration_FOR_educ_one_fate_X_EOL_MEDIUM;

        value_in = value_curr;
    }
    {
        // interval(om_duration_FOR_educ_one_fate_X_EOL_HIGH)
        auto & value_in = om_TabEduc15ByDistrict_in_om_duration_FOR_educ_one_fate_X_EOL_HIGH;
        Time value_curr = om_duration_FOR_educ_one_fate_X_EOL_HIGH;

        value_in = value_curr;
    }
}
void Person::om_TabEduc15ByDistrict_push_increment(int cell_in, int pending, big_counter pending_event_counter)
{
    assert(theTabEduc15ByDistrict); // unitary table must be instantiated

    auto& table = theTabEduc15ByDistrict;

    // Table has margins

    // Dimensionality of table (does not include measure dimension)
    const size_t rank = 3;

    // Size of each dimension of table (includes margin if present)
    const std::array<size_t, rank> shape = {13, 3, 151};

    // Number of dimensions with a margin
    const size_t margin_count = 2;

    // Dimensions with a margin
    const std::array<size_t, margin_count> margin_dims = {0, 1};

    // Number of margin combinations for a cell in the table body
    // e.g. a table with 3 margins has 2^3-1=7 margin cells associated with a body cell
    const size_t margin_combos = (1 << margin_count) - 1;

    // Indexes of table cells to increment (cell in table body and cells in margins)
    std::array<size_t, 1 + margin_combos> cells_to_increment;

    // Populate cells_to_increment

    // The cell in the table body:
    cells_to_increment[0] = cell_in;

    // The margin cells
    {
        // Dimension coordinates of the body cell being incremented
        std::array<size_t, rank> body_coordinates;
        // Decode dimension coordinates of the body cell
        for (int j = rank - 1, w = cell_in; j >= 0; --j) {
            body_coordinates[j] = w % shape[j];
            w /= shape[j];
        }
        // Working coordinates of a margin cell
        std::array<size_t, rank> margin_coordinates;
        for (size_t combo = 1; combo <= margin_combos; ++combo) {
            // The binary bits of combo select the margin dimensions for the combination.
            margin_coordinates = body_coordinates;
            size_t bits = combo;
            for (size_t margin = 0; margin < margin_count; ++margin) {
                // read out the bits in combo
                if (bits & 1) {
                    // low order bit is 1, so replace coordinate from body cell by margin coordinate
                    margin_coordinates[margin_dims[margin]] = shape[margin_dims[margin]] - 1;
                }
                bits >>= 1;
            }
            // Encode the dimension coordinates of the margin cell into flattened index
            size_t margin_cell = margin_coordinates[0];
            for (size_t j = 1; j < rank; ++j) {
                margin_cell *= shape[j];
                margin_cell += margin_coordinates[j];
            }
            assert(margin_cell >= 0 && margin_cell < 5889); // logic guarantee
            cells_to_increment[combo] = margin_cell;
        }
    }

    // Increments and Accumulators:
    //  accumulator 0: sum(delta(interval(duration(educ_one_fate, EOL_LOW))))
    {
        const int acc_index = 0; // accumulator index

        // Compute increment
        Time value_out = om_duration_FOR_educ_one_fate_X_EOL_LOW;
        auto& value_in = om_TabEduc15ByDistrict_in_om_duration_FOR_educ_one_fate_X_EOL_LOW;

        double dIncrement;
        dIncrement = (double)value_out - (double)value_in;

        // Push increment to body cell and margin cells
        for (int cell : cells_to_increment) {
            auto& dAccumulator = table->acc[acc_index][cell];
            dAccumulator += dIncrement;
        }
    }
    //  accumulator 1: sum(delta(interval(duration())))
    {
        const int acc_index = 1; // accumulator index

        // Compute increment
        Time value_out = om_duration;
        auto& value_in = om_TabEduc15ByDistrict_in_om_duration;

        double dIncrement;
        dIncrement = (double)value_out - (double)value_in;

        // Push increment to body cell and margin cells
        for (int cell : cells_to_increment) {
            auto& dAccumulator = table->acc[acc_index][cell];
            dAccumulator += dIncrement;
        }
    }
    //  accumulator 2: sum(delta(interval(duration(educ_one_fate, EOL_MEDIUM))))
    {
        const int acc_index = 2; // accumulator index

        // Compute increment
        Time value_out = om_duration_FOR_educ_one_fate_X_EOL_MEDIUM;
        auto& value_in = om_TabEduc15ByDistrict_in_om_duration_FOR_educ_one_fate_X_EOL_MEDIUM;

        double dIncrement;
        dIncrement = (double)value_out - (double)value_in;

        // Push increment to body cell and margin cells
        for (int cell : cells_to_increment) {
            auto& dAccumulator = table->acc[acc_index][cell];
            dAccumulator += dIncrement;
        }
    }
    //  accumulator 3: sum(delta(interval(duration(educ_one_fate, EOL_HIGH))))
    {
        const int acc_index = 3; // accumulator index

        // Compute increment
        Time value_out = om_duration_FOR_educ_one_fate_X_EOL_HIGH;
        auto& value_in = om_TabEduc15ByDistrict_in_om_duration_FOR_educ_one_fate_X_EOL_HIGH;

        double dIncrement;
        dIncrement = (double)value_out - (double)value_in;

        // Push increment to body cell and margin cells
        for (int cell : cells_to_increment) {
            auto& dAccumulator = table->acc[acc_index][cell];
            dAccumulator += dIncrement;
        }
    }
}
int Person::om_TabEducFateByGroup_current_cell()
{
    assert(theTabEducFateByGroup); // unitary table must be instantiated

    // Dimensionality of table (does not include measure dimension)
    const size_t rank = 3;

    // Size of each dimension of table (includes margin if present)
    const std::array<size_t, rank> shape = {4, 151, 4};

    // Dimension coordinates of current cell
    const std::array<size_t, rank> coordinates = {
        size_t(educ1_group), 
        size_t(tab_sim_yob - 2000), 
        size_t(educ_one_fate), 
    };

    // Encode the dimension coordinates of the margin cell into flattened index
    size_t cell = coordinates[0];
    for (size_t j = 1; j < rank; ++j) {
        cell *= shape[j];
        cell += coordinates[j];
    }

    assert(cell >= 0 && cell < 2416); // logic guarantee
    return cell;
}
void Person::om_TabEducFateByGroup_init_increment(int pending, big_counter pending_event_counter)
{
    assert(theTabEducFateByGroup); // unitary table must be instantiated

}
void Person::om_TabEducFateByGroup_push_increment(int cell_in, int pending, big_counter pending_event_counter)
{
    assert(theTabEducFateByGroup); // unitary table must be instantiated

    auto& table = theTabEducFateByGroup;

    // Table has margins

    // Dimensionality of table (does not include measure dimension)
    const size_t rank = 3;

    // Size of each dimension of table (includes margin if present)
    const std::array<size_t, rank> shape = {4, 151, 4};

    // Number of dimensions with a margin
    const size_t margin_count = 2;

    // Dimensions with a margin
    const std::array<size_t, margin_count> margin_dims = {0, 2};

    // Number of margin combinations for a cell in the table body
    // e.g. a table with 3 margins has 2^3-1=7 margin cells associated with a body cell
    const size_t margin_combos = (1 << margin_count) - 1;

    // Indexes of table cells to increment (cell in table body and cells in margins)
    std::array<size_t, 1 + margin_combos> cells_to_increment;

    // Populate cells_to_increment

    // The cell in the table body:
    cells_to_increment[0] = cell_in;

    // The margin cells
    {
        // Dimension coordinates of the body cell being incremented
        std::array<size_t, rank> body_coordinates;
        // Decode dimension coordinates of the body cell
        for (int j = rank - 1, w = cell_in; j >= 0; --j) {
            body_coordinates[j] = w % shape[j];
            w /= shape[j];
        }
        // Working coordinates of a margin cell
        std::array<size_t, rank> margin_coordinates;
        for (size_t combo = 1; combo <= margin_combos; ++combo) {
            // The binary bits of combo select the margin dimensions for the combination.
            margin_coordinates = body_coordinates;
            size_t bits = combo;
            for (size_t margin = 0; margin < margin_count; ++margin) {
                // read out the bits in combo
                if (bits & 1) {
                    // low order bit is 1, so replace coordinate from body cell by margin coordinate
                    margin_coordinates[margin_dims[margin]] = shape[margin_dims[margin]] - 1;
                }
                bits >>= 1;
            }
            // Encode the dimension coordinates of the margin cell into flattened index
            size_t margin_cell = margin_coordinates[0];
            for (size_t j = 1; j < rank; ++j) {
                margin_cell *= shape[j];
                margin_cell += margin_coordinates[j];
            }
            assert(margin_cell >= 0 && margin_cell < 2416); // logic guarantee
            cells_to_increment[combo] = margin_cell;
        }
    }

    // Increments and Accumulators:
    //  accumulator 0: unit
    {
        const int acc_index = 0; // accumulator index

        // Compute increment

        double dIncrement;
        dIncrement = 1.0;

        // Push increment to body cell and margin cells
        for (int cell : cells_to_increment) {
            auto& dAccumulator = table->acc[acc_index][cell];
            dAccumulator += dIncrement;
        }
    }
}
int Person::om_TabEducFateDistrYob_current_cell()
{
    assert(theTabEducFateDistrYob); // unitary table must be instantiated

    // Dimensionality of table (does not include measure dimension)
    const size_t rank = 3;

    // Size of each dimension of table (includes margin if present)
    const std::array<size_t, rank> shape = {6, 252, 4};

    // Dimension coordinates of current cell
    const std::array<size_t, rank> coordinates = {
        size_t(om_aggregate_FOR_region_birth_X_REGION_NAT), 
        size_t(year_of_birth - 1899), 
        size_t(educ_one_fate), 
    };

    // Encode the dimension coordinates of the margin cell into flattened index
    size_t cell = coordinates[0];
    for (size_t j = 1; j < rank; ++j) {
        cell *= shape[j];
        cell += coordinates[j];
    }

    assert(cell >= 0 && cell < 6048); // logic guarantee
    return cell;
}
void Person::om_TabEducFateDistrYob_init_increment(int pending, big_counter pending_event_counter)
{
    assert(theTabEducFateDistrYob); // unitary table must be instantiated

}
void Person::om_TabEducFateDistrYob_push_increment(int cell_in, int pending, big_counter pending_event_counter)
{
    assert(theTabEducFateDistrYob); // unitary table must be instantiated

    auto& table = theTabEducFateDistrYob;

    // Table has margins

    // Dimensionality of table (does not include measure dimension)
    const size_t rank = 3;

    // Size of each dimension of table (includes margin if present)
    const std::array<size_t, rank> shape = {6, 252, 4};

    // Number of dimensions with a margin
    const size_t margin_count = 2;

    // Dimensions with a margin
    const std::array<size_t, margin_count> margin_dims = {0, 2};

    // Number of margin combinations for a cell in the table body
    // e.g. a table with 3 margins has 2^3-1=7 margin cells associated with a body cell
    const size_t margin_combos = (1 << margin_count) - 1;

    // Indexes of table cells to increment (cell in table body and cells in margins)
    std::array<size_t, 1 + margin_combos> cells_to_increment;

    // Populate cells_to_increment

    // The cell in the table body:
    cells_to_increment[0] = cell_in;

    // The margin cells
    {
        // Dimension coordinates of the body cell being incremented
        std::array<size_t, rank> body_coordinates;
        // Decode dimension coordinates of the body cell
        for (int j = rank - 1, w = cell_in; j >= 0; --j) {
            body_coordinates[j] = w % shape[j];
            w /= shape[j];
        }
        // Working coordinates of a margin cell
        std::array<size_t, rank> margin_coordinates;
        for (size_t combo = 1; combo <= margin_combos; ++combo) {
            // The binary bits of combo select the margin dimensions for the combination.
            margin_coordinates = body_coordinates;
            size_t bits = combo;
            for (size_t margin = 0; margin < margin_count; ++margin) {
                // read out the bits in combo
                if (bits & 1) {
                    // low order bit is 1, so replace coordinate from body cell by margin coordinate
                    margin_coordinates[margin_dims[margin]] = shape[margin_dims[margin]] - 1;
                }
                bits >>= 1;
            }
            // Encode the dimension coordinates of the margin cell into flattened index
            size_t margin_cell = margin_coordinates[0];
            for (size_t j = 1; j < rank; ++j) {
                margin_cell *= shape[j];
                margin_cell += margin_coordinates[j];
            }
            assert(margin_cell >= 0 && margin_cell < 6048); // logic guarantee
            cells_to_increment[combo] = margin_cell;
        }
    }

    // Increments and Accumulators:
    //  accumulator 0: unit
    {
        const int acc_index = 0; // accumulator index

        // Compute increment

        double dIncrement;
        dIncrement = 1.0;

        // Push increment to body cell and margin cells
        for (int cell : cells_to_increment) {
            auto& dAccumulator = table->acc[acc_index][cell];
            dAccumulator += dIncrement;
        }
    }
}
int Person::om_TabHCIDistrict_current_cell()
{
    assert(theTabHCIDistrict); // unitary table must be instantiated

    // Dimensionality of table (does not include measure dimension)
    const size_t rank = 3;

    // Size of each dimension of table (includes margin if present)
    const std::array<size_t, rank> shape = {3, 13, 151};

    // Dimension coordinates of current cell
    const std::array<size_t, rank> coordinates = {
        size_t(sex), 
        size_t(om_aggregate_FOR_geo_birth_X_GEO_NAT), 
        size_t(tab_sim_yob - 2000), 
    };

    // Encode the dimension coordinates of the margin cell into flattened index
    size_t cell = coordinates[0];
    for (size_t j = 1; j < rank; ++j) {
        cell *= shape[j];
        cell += coordinates[j];
    }

    assert(cell >= 0 && cell < 5889); // logic guarantee
    return cell;
}
void Person::om_TabHCIDistrict_init_increment(int pending, big_counter pending_event_counter)
{
    assert(theTabHCIDistrict); // unitary table must be instantiated

    {
        // interval(om_value_at_transitions_FOR_is_alive_X_true_X_is_stunted_X_false)
        auto & value_in = om_TabHCIDistrict_in_om_value_at_transitions_FOR_is_alive_X_true_X_is_stunted_X_false;
        integer value_curr = om_value_at_transitions_FOR_is_alive_X_true_X_is_stunted_X_false;

        value_in = value_curr;
    }
    {
        // interval(om_transitions_FOR_is_alive_X_true_X_false)
        auto & value_in = om_TabHCIDistrict_in_om_transitions_FOR_is_alive_X_true_X_false;
        counter value_curr = om_transitions_FOR_is_alive_X_true_X_false;

        value_in = value_curr;
    }
    {
        // interval(om_value_at_transitions_FOR_is_alive_X_true_X_survived_early_years_X_false)
        auto & value_in = om_TabHCIDistrict_in_om_value_at_transitions_FOR_is_alive_X_true_X_survived_early_years_X_false;
        integer value_curr = om_value_at_transitions_FOR_is_alive_X_true_X_survived_early_years_X_false;

        value_in = value_curr;
    }
    {
        // interval(om_value_at_transitions_FOR_is_alive_X_true_X_adult_survival_X_false)
        auto & value_in = om_TabHCIDistrict_in_om_value_at_transitions_FOR_is_alive_X_true_X_adult_survival_X_false;
        real value_curr = om_value_at_transitions_FOR_is_alive_X_true_X_adult_survival_X_false;

        value_in = value_curr;
    }
    {
        // interval(om_transitions_FOR_integer_age_X_14_X_15)
        auto & value_in = om_TabHCIDistrict_in_om_transitions_FOR_integer_age_X_14_X_15;
        counter value_curr = om_transitions_FOR_integer_age_X_14_X_15;

        value_in = value_curr;
    }
    {
        // interval(om_value_at_transitions_FOR_is_alive_X_true_X_quality_of_schooling_X_false)
        auto & value_in = om_TabHCIDistrict_in_om_value_at_transitions_FOR_is_alive_X_true_X_quality_of_schooling_X_false;
        real value_curr = om_value_at_transitions_FOR_is_alive_X_true_X_quality_of_schooling_X_false;

        value_in = value_curr;
    }
    {
        // interval(om_transitions_FOR_survived_early_years_X_false_X_true)
        auto & value_in = om_TabHCIDistrict_in_om_transitions_FOR_survived_early_years_X_false_X_true;
        counter value_curr = om_transitions_FOR_survived_early_years_X_false_X_true;

        value_in = value_curr;
    }
    {
        // interval(om_value_at_transitions_FOR_is_alive_X_true_X_years_of_schooling_X_false)
        auto & value_in = om_TabHCIDistrict_in_om_value_at_transitions_FOR_is_alive_X_true_X_years_of_schooling_X_false;
        integer value_curr = om_value_at_transitions_FOR_is_alive_X_true_X_years_of_schooling_X_false;

        value_in = value_curr;
    }
    {
        // interval(om_value_at_transitions_FOR_is_alive_X_true_X_ind_hci_X_false)
        auto & value_in = om_TabHCIDistrict_in_om_value_at_transitions_FOR_is_alive_X_true_X_ind_hci_X_false;
        real value_curr = om_value_at_transitions_FOR_is_alive_X_true_X_ind_hci_X_false;

        value_in = value_curr;
    }
}
void Person::om_TabHCIDistrict_push_increment(int cell_in, int pending, big_counter pending_event_counter)
{
    assert(theTabHCIDistrict); // unitary table must be instantiated

    auto& table = theTabHCIDistrict;

    // Table has margins

    // Dimensionality of table (does not include measure dimension)
    const size_t rank = 3;

    // Size of each dimension of table (includes margin if present)
    const std::array<size_t, rank> shape = {3, 13, 151};

    // Number of dimensions with a margin
    const size_t margin_count = 2;

    // Dimensions with a margin
    const std::array<size_t, margin_count> margin_dims = {0, 1};

    // Number of margin combinations for a cell in the table body
    // e.g. a table with 3 margins has 2^3-1=7 margin cells associated with a body cell
    const size_t margin_combos = (1 << margin_count) - 1;

    // Indexes of table cells to increment (cell in table body and cells in margins)
    std::array<size_t, 1 + margin_combos> cells_to_increment;

    // Populate cells_to_increment

    // The cell in the table body:
    cells_to_increment[0] = cell_in;

    // The margin cells
    {
        // Dimension coordinates of the body cell being incremented
        std::array<size_t, rank> body_coordinates;
        // Decode dimension coordinates of the body cell
        for (int j = rank - 1, w = cell_in; j >= 0; --j) {
            body_coordinates[j] = w % shape[j];
            w /= shape[j];
        }
        // Working coordinates of a margin cell
        std::array<size_t, rank> margin_coordinates;
        for (size_t combo = 1; combo <= margin_combos; ++combo) {
            // The binary bits of combo select the margin dimensions for the combination.
            margin_coordinates = body_coordinates;
            size_t bits = combo;
            for (size_t margin = 0; margin < margin_count; ++margin) {
                // read out the bits in combo
                if (bits & 1) {
                    // low order bit is 1, so replace coordinate from body cell by margin coordinate
                    margin_coordinates[margin_dims[margin]] = shape[margin_dims[margin]] - 1;
                }
                bits >>= 1;
            }
            // Encode the dimension coordinates of the margin cell into flattened index
            size_t margin_cell = margin_coordinates[0];
            for (size_t j = 1; j < rank; ++j) {
                margin_cell *= shape[j];
                margin_cell += margin_coordinates[j];
            }
            assert(margin_cell >= 0 && margin_cell < 5889); // logic guarantee
            cells_to_increment[combo] = margin_cell;
        }
    }

    // Increments and Accumulators:
    //  accumulator 0: sum(delta(interval(value_at_transitions(is_alive, true, false, is_stunted))))
    {
        const int acc_index = 0; // accumulator index

        // Compute increment
        integer value_out = om_value_at_transitions_FOR_is_alive_X_true_X_is_stunted_X_false;
        auto& value_in = om_TabHCIDistrict_in_om_value_at_transitions_FOR_is_alive_X_true_X_is_stunted_X_false;

        double dIncrement;
        dIncrement = (double)value_out - (double)value_in;

        // Push increment to body cell and margin cells
        for (int cell : cells_to_increment) {
            auto& dAccumulator = table->acc[acc_index][cell];
            dAccumulator += dIncrement;
        }
    }
    //  accumulator 1: sum(delta(interval(transitions(is_alive, true, false))))
    {
        const int acc_index = 1; // accumulator index

        // Compute increment
        counter value_out = om_transitions_FOR_is_alive_X_true_X_false;
        auto& value_in = om_TabHCIDistrict_in_om_transitions_FOR_is_alive_X_true_X_false;

        double dIncrement;
        dIncrement = (double)value_out - (double)value_in;

        // Push increment to body cell and margin cells
        for (int cell : cells_to_increment) {
            auto& dAccumulator = table->acc[acc_index][cell];
            dAccumulator += dIncrement;
        }
    }
    //  accumulator 2: sum(delta(interval(value_at_transitions(is_alive, true, false, survived_early_years))))
    {
        const int acc_index = 2; // accumulator index

        // Compute increment
        integer value_out = om_value_at_transitions_FOR_is_alive_X_true_X_survived_early_years_X_false;
        auto& value_in = om_TabHCIDistrict_in_om_value_at_transitions_FOR_is_alive_X_true_X_survived_early_years_X_false;

        double dIncrement;
        dIncrement = (double)value_out - (double)value_in;

        // Push increment to body cell and margin cells
        for (int cell : cells_to_increment) {
            auto& dAccumulator = table->acc[acc_index][cell];
            dAccumulator += dIncrement;
        }
    }
    //  accumulator 3: sum(delta(interval(value_at_transitions(is_alive, true, false, adult_survival))))
    {
        const int acc_index = 3; // accumulator index

        // Compute increment
        real value_out = om_value_at_transitions_FOR_is_alive_X_true_X_adult_survival_X_false;
        auto& value_in = om_TabHCIDistrict_in_om_value_at_transitions_FOR_is_alive_X_true_X_adult_survival_X_false;

        double dIncrement;
        dIncrement = (double)value_out - (double)value_in;

        // Push increment to body cell and margin cells
        for (int cell : cells_to_increment) {
            auto& dAccumulator = table->acc[acc_index][cell];
            dAccumulator += dIncrement;
        }
    }
    //  accumulator 4: sum(delta(interval(transitions(integer_age, 14, 15))))
    {
        const int acc_index = 4; // accumulator index

        // Compute increment
        counter value_out = om_transitions_FOR_integer_age_X_14_X_15;
        auto& value_in = om_TabHCIDistrict_in_om_transitions_FOR_integer_age_X_14_X_15;

        double dIncrement;
        dIncrement = (double)value_out - (double)value_in;

        // Push increment to body cell and margin cells
        for (int cell : cells_to_increment) {
            auto& dAccumulator = table->acc[acc_index][cell];
            dAccumulator += dIncrement;
        }
    }
    //  accumulator 5: sum(delta(interval(value_at_transitions(is_alive, true, false, quality_of_schooling))))
    {
        const int acc_index = 5; // accumulator index

        // Compute increment
        real value_out = om_value_at_transitions_FOR_is_alive_X_true_X_quality_of_schooling_X_false;
        auto& value_in = om_TabHCIDistrict_in_om_value_at_transitions_FOR_is_alive_X_true_X_quality_of_schooling_X_false;

        double dIncrement;
        dIncrement = (double)value_out - (double)value_in;

        // Push increment to body cell and margin cells
        for (int cell : cells_to_increment) {
            auto& dAccumulator = table->acc[acc_index][cell];
            dAccumulator += dIncrement;
        }
    }
    //  accumulator 6: sum(delta(interval(transitions(survived_early_years, false, true))))
    {
        const int acc_index = 6; // accumulator index

        // Compute increment
        counter value_out = om_transitions_FOR_survived_early_years_X_false_X_true;
        auto& value_in = om_TabHCIDistrict_in_om_transitions_FOR_survived_early_years_X_false_X_true;

        double dIncrement;
        dIncrement = (double)value_out - (double)value_in;

        // Push increment to body cell and margin cells
        for (int cell : cells_to_increment) {
            auto& dAccumulator = table->acc[acc_index][cell];
            dAccumulator += dIncrement;
        }
    }
    //  accumulator 7: sum(delta(interval(value_at_transitions(is_alive, true, false, years_of_schooling))))
    {
        const int acc_index = 7; // accumulator index

        // Compute increment
        integer value_out = om_value_at_transitions_FOR_is_alive_X_true_X_years_of_schooling_X_false;
        auto& value_in = om_TabHCIDistrict_in_om_value_at_transitions_FOR_is_alive_X_true_X_years_of_schooling_X_false;

        double dIncrement;
        dIncrement = (double)value_out - (double)value_in;

        // Push increment to body cell and margin cells
        for (int cell : cells_to_increment) {
            auto& dAccumulator = table->acc[acc_index][cell];
            dAccumulator += dIncrement;
        }
    }
    //  accumulator 8: sum(delta(interval(value_at_transitions(is_alive, true, false, ind_hci))))
    {
        const int acc_index = 8; // accumulator index

        // Compute increment
        real value_out = om_value_at_transitions_FOR_is_alive_X_true_X_ind_hci_X_false;
        auto& value_in = om_TabHCIDistrict_in_om_value_at_transitions_FOR_is_alive_X_true_X_ind_hci_X_false;

        double dIncrement;
        dIncrement = (double)value_out - (double)value_in;

        // Push increment to body cell and margin cells
        for (int cell : cells_to_increment) {
            auto& dAccumulator = table->acc[acc_index][cell];
            dAccumulator += dIncrement;
        }
    }
}
int Person::om_TabImmunizationChildren_current_cell()
{
    assert(theTabImmunizationChildren); // unitary table must be instantiated

    // Dimensionality of table (does not include measure dimension)
    const size_t rank = 6;

    // Size of each dimension of table (includes margin if present)
    const std::array<size_t, rank> shape = {3, 8, 3, 6, 4, 151};

    // Dimension coordinates of current cell
    const std::array<size_t, rank> coordinates = {
        size_t(sex), 
        size_t(ethnicity_short), 
        size_t(got_prenat_care), 
        size_t(region_nat), 
        size_t(educ_mother), 
        size_t(sim_year - 2000), 
    };

    // Encode the dimension coordinates of the margin cell into flattened index
    size_t cell = coordinates[0];
    for (size_t j = 1; j < rank; ++j) {
        cell *= shape[j];
        cell += coordinates[j];
    }

    assert(cell >= 0 && cell < 260928); // logic guarantee
    return cell;
}
void Person::om_TabImmunizationChildren_init_increment(int pending, big_counter pending_event_counter)
{
    assert(theTabImmunizationChildren); // unitary table must be instantiated

    {
        // interval(om_duration_FOR_is_immunized_X_true)
        auto & value_in = om_TabImmunizationChildren_in_om_duration_FOR_is_immunized_X_true;
        Time value_curr = om_duration_FOR_is_immunized_X_true;

        value_in = value_curr;
    }
    {
        // interval(om_duration)
        auto & value_in = om_TabImmunizationChildren_in_om_duration;
        Time value_curr = om_duration;

        value_in = value_curr;
    }
}
void Person::om_TabImmunizationChildren_push_increment(int cell_in, int pending, big_counter pending_event_counter)
{
    assert(theTabImmunizationChildren); // unitary table must be instantiated

    auto& table = theTabImmunizationChildren;

    // Table has margins

    // Dimensionality of table (does not include measure dimension)
    const size_t rank = 6;

    // Size of each dimension of table (includes margin if present)
    const std::array<size_t, rank> shape = {3, 8, 3, 6, 4, 151};

    // Number of dimensions with a margin
    const size_t margin_count = 5;

    // Dimensions with a margin
    const std::array<size_t, margin_count> margin_dims = {0, 1, 2, 3, 4};

    // Number of margin combinations for a cell in the table body
    // e.g. a table with 3 margins has 2^3-1=7 margin cells associated with a body cell
    const size_t margin_combos = (1 << margin_count) - 1;

    // Indexes of table cells to increment (cell in table body and cells in margins)
    std::array<size_t, 1 + margin_combos> cells_to_increment;

    // Populate cells_to_increment

    // The cell in the table body:
    cells_to_increment[0] = cell_in;

    // The margin cells
    {
        // Dimension coordinates of the body cell being incremented
        std::array<size_t, rank> body_coordinates;
        // Decode dimension coordinates of the body cell
        for (int j = rank - 1, w = cell_in; j >= 0; --j) {
            body_coordinates[j] = w % shape[j];
            w /= shape[j];
        }
        // Working coordinates of a margin cell
        std::array<size_t, rank> margin_coordinates;
        for (size_t combo = 1; combo <= margin_combos; ++combo) {
            // The binary bits of combo select the margin dimensions for the combination.
            margin_coordinates = body_coordinates;
            size_t bits = combo;
            for (size_t margin = 0; margin < margin_count; ++margin) {
                // read out the bits in combo
                if (bits & 1) {
                    // low order bit is 1, so replace coordinate from body cell by margin coordinate
                    margin_coordinates[margin_dims[margin]] = shape[margin_dims[margin]] - 1;
                }
                bits >>= 1;
            }
            // Encode the dimension coordinates of the margin cell into flattened index
            size_t margin_cell = margin_coordinates[0];
            for (size_t j = 1; j < rank; ++j) {
                margin_cell *= shape[j];
                margin_cell += margin_coordinates[j];
            }
            assert(margin_cell >= 0 && margin_cell < 260928); // logic guarantee
            cells_to_increment[combo] = margin_cell;
        }
    }

    // Increments and Accumulators:
    //  accumulator 0: sum(delta(interval(duration(is_immunized, true))))
    {
        const int acc_index = 0; // accumulator index

        // Compute increment
        Time value_out = om_duration_FOR_is_immunized_X_true;
        auto& value_in = om_TabImmunizationChildren_in_om_duration_FOR_is_immunized_X_true;

        double dIncrement;
        dIncrement = (double)value_out - (double)value_in;

        // Push increment to body cell and margin cells
        for (int cell : cells_to_increment) {
            auto& dAccumulator = table->acc[acc_index][cell];
            dAccumulator += dIncrement;
        }
    }
    //  accumulator 1: sum(delta(interval(duration())))
    {
        const int acc_index = 1; // accumulator index

        // Compute increment
        Time value_out = om_duration;
        auto& value_in = om_TabImmunizationChildren_in_om_duration;

        double dIncrement;
        dIncrement = (double)value_out - (double)value_in;

        // Push increment to body cell and margin cells
        for (int cell : cells_to_increment) {
            auto& dAccumulator = table->acc[acc_index][cell];
            dAccumulator += dIncrement;
        }
    }
}
int Person::om_TabPopProvAgeEducSex_current_cell()
{
    assert(theTabPopProvAgeEducSex); // unitary table must be instantiated

    // Dimensionality of table (does not include measure dimension)
    const size_t rank = 3;

    // Size of each dimension of table (includes margin if present)
    const std::array<size_t, rank> shape = {13, 3, 151};

    // Dimension coordinates of current cell
    const std::array<size_t, rank> coordinates = {
        size_t(geo_nat), 
        size_t(sex), 
        size_t(sim_year - 2000), 
    };

    // Encode the dimension coordinates of the margin cell into flattened index
    size_t cell = coordinates[0];
    for (size_t j = 1; j < rank; ++j) {
        cell *= shape[j];
        cell += coordinates[j];
    }

    assert(cell >= 0 && cell < 5889); // logic guarantee
    return cell;
}
void Person::om_TabPopProvAgeEducSex_init_increment(int pending, big_counter pending_event_counter)
{
    assert(theTabPopProvAgeEducSex); // unitary table must be instantiated

    {
        // interval(om_duration_FOR_is_child_X_true)
        auto & value_in = om_TabPopProvAgeEducSex_in_om_duration_FOR_is_child_X_true;
        Time value_curr = om_duration_FOR_is_child_X_true;

        value_in = value_curr;
    }
    {
        // interval(om_duration_FOR_is_aded0_X_true)
        auto & value_in = om_TabPopProvAgeEducSex_in_om_duration_FOR_is_aded0_X_true;
        Time value_curr = om_duration_FOR_is_aded0_X_true;

        value_in = value_curr;
    }
    {
        // interval(om_duration_FOR_is_aded1_X_true)
        auto & value_in = om_TabPopProvAgeEducSex_in_om_duration_FOR_is_aded1_X_true;
        Time value_curr = om_duration_FOR_is_aded1_X_true;

        value_in = value_curr;
    }
    {
        // interval(om_duration_FOR_is_aded2_X_true)
        auto & value_in = om_TabPopProvAgeEducSex_in_om_duration_FOR_is_aded2_X_true;
        Time value_curr = om_duration_FOR_is_aded2_X_true;

        value_in = value_curr;
    }
    {
        // interval(om_duration_FOR_is_old_X_true)
        auto & value_in = om_TabPopProvAgeEducSex_in_om_duration_FOR_is_old_X_true;
        Time value_curr = om_duration_FOR_is_old_X_true;

        value_in = value_curr;
    }
}
void Person::om_TabPopProvAgeEducSex_push_increment(int cell_in, int pending, big_counter pending_event_counter)
{
    assert(theTabPopProvAgeEducSex); // unitary table must be instantiated

    auto& table = theTabPopProvAgeEducSex;

    // Table has margins

    // Dimensionality of table (does not include measure dimension)
    const size_t rank = 3;

    // Size of each dimension of table (includes margin if present)
    const std::array<size_t, rank> shape = {13, 3, 151};

    // Number of dimensions with a margin
    const size_t margin_count = 2;

    // Dimensions with a margin
    const std::array<size_t, margin_count> margin_dims = {0, 1};

    // Number of margin combinations for a cell in the table body
    // e.g. a table with 3 margins has 2^3-1=7 margin cells associated with a body cell
    const size_t margin_combos = (1 << margin_count) - 1;

    // Indexes of table cells to increment (cell in table body and cells in margins)
    std::array<size_t, 1 + margin_combos> cells_to_increment;

    // Populate cells_to_increment

    // The cell in the table body:
    cells_to_increment[0] = cell_in;

    // The margin cells
    {
        // Dimension coordinates of the body cell being incremented
        std::array<size_t, rank> body_coordinates;
        // Decode dimension coordinates of the body cell
        for (int j = rank - 1, w = cell_in; j >= 0; --j) {
            body_coordinates[j] = w % shape[j];
            w /= shape[j];
        }
        // Working coordinates of a margin cell
        std::array<size_t, rank> margin_coordinates;
        for (size_t combo = 1; combo <= margin_combos; ++combo) {
            // The binary bits of combo select the margin dimensions for the combination.
            margin_coordinates = body_coordinates;
            size_t bits = combo;
            for (size_t margin = 0; margin < margin_count; ++margin) {
                // read out the bits in combo
                if (bits & 1) {
                    // low order bit is 1, so replace coordinate from body cell by margin coordinate
                    margin_coordinates[margin_dims[margin]] = shape[margin_dims[margin]] - 1;
                }
                bits >>= 1;
            }
            // Encode the dimension coordinates of the margin cell into flattened index
            size_t margin_cell = margin_coordinates[0];
            for (size_t j = 1; j < rank; ++j) {
                margin_cell *= shape[j];
                margin_cell += margin_coordinates[j];
            }
            assert(margin_cell >= 0 && margin_cell < 5889); // logic guarantee
            cells_to_increment[combo] = margin_cell;
        }
    }

    // Increments and Accumulators:
    //  accumulator 0: sum(delta(interval(duration(is_child, true))))
    {
        const int acc_index = 0; // accumulator index

        // Compute increment
        Time value_out = om_duration_FOR_is_child_X_true;
        auto& value_in = om_TabPopProvAgeEducSex_in_om_duration_FOR_is_child_X_true;

        double dIncrement;
        dIncrement = (double)value_out - (double)value_in;

        // Push increment to body cell and margin cells
        for (int cell : cells_to_increment) {
            auto& dAccumulator = table->acc[acc_index][cell];
            dAccumulator += dIncrement;
        }
    }
    //  accumulator 1: sum(delta(interval(duration(is_aded0, true))))
    {
        const int acc_index = 1; // accumulator index

        // Compute increment
        Time value_out = om_duration_FOR_is_aded0_X_true;
        auto& value_in = om_TabPopProvAgeEducSex_in_om_duration_FOR_is_aded0_X_true;

        double dIncrement;
        dIncrement = (double)value_out - (double)value_in;

        // Push increment to body cell and margin cells
        for (int cell : cells_to_increment) {
            auto& dAccumulator = table->acc[acc_index][cell];
            dAccumulator += dIncrement;
        }
    }
    //  accumulator 2: sum(delta(interval(duration(is_aded1, true))))
    {
        const int acc_index = 2; // accumulator index

        // Compute increment
        Time value_out = om_duration_FOR_is_aded1_X_true;
        auto& value_in = om_TabPopProvAgeEducSex_in_om_duration_FOR_is_aded1_X_true;

        double dIncrement;
        dIncrement = (double)value_out - (double)value_in;

        // Push increment to body cell and margin cells
        for (int cell : cells_to_increment) {
            auto& dAccumulator = table->acc[acc_index][cell];
            dAccumulator += dIncrement;
        }
    }
    //  accumulator 3: sum(delta(interval(duration(is_aded2, true))))
    {
        const int acc_index = 3; // accumulator index

        // Compute increment
        Time value_out = om_duration_FOR_is_aded2_X_true;
        auto& value_in = om_TabPopProvAgeEducSex_in_om_duration_FOR_is_aded2_X_true;

        double dIncrement;
        dIncrement = (double)value_out - (double)value_in;

        // Push increment to body cell and margin cells
        for (int cell : cells_to_increment) {
            auto& dAccumulator = table->acc[acc_index][cell];
            dAccumulator += dIncrement;
        }
    }
    //  accumulator 4: sum(delta(interval(duration(is_old, true))))
    {
        const int acc_index = 4; // accumulator index

        // Compute increment
        Time value_out = om_duration_FOR_is_old_X_true;
        auto& value_in = om_TabPopProvAgeEducSex_in_om_duration_FOR_is_old_X_true;

        double dIncrement;
        dIncrement = (double)value_out - (double)value_in;

        // Push increment to body cell and margin cells
        for (int cell : cells_to_increment) {
            auto& dAccumulator = table->acc[acc_index][cell];
            dAccumulator += dIncrement;
        }
    }
}
int Person::om_TabPrenatCare_current_cell()
{
    assert(theTabPrenatCare); // unitary table must be instantiated

    // Dimensionality of table (does not include measure dimension)
    const size_t rank = 3;

    // Size of each dimension of table (includes margin if present)
    const std::array<size_t, rank> shape = {6, 4, 151};

    // Dimension coordinates of current cell
    const std::array<size_t, rank> coordinates = {
        size_t(region_nat), 
        size_t(educ_mother), 
        size_t(sim_year - 2000), 
    };

    // Encode the dimension coordinates of the margin cell into flattened index
    size_t cell = coordinates[0];
    for (size_t j = 1; j < rank; ++j) {
        cell *= shape[j];
        cell += coordinates[j];
    }

    assert(cell >= 0 && cell < 3624); // logic guarantee
    return cell;
}
void Person::om_TabPrenatCare_init_increment(int pending, big_counter pending_event_counter)
{
    assert(theTabPrenatCare); // unitary table must be instantiated

    {
        // interval(om_duration_FOR_got_prenat_care_X_GPC_YES)
        auto & value_in = om_TabPrenatCare_in_om_duration_FOR_got_prenat_care_X_GPC_YES;
        Time value_curr = om_duration_FOR_got_prenat_care_X_GPC_YES;

        value_in = value_curr;
    }
    {
        // interval(om_duration)
        auto & value_in = om_TabPrenatCare_in_om_duration;
        Time value_curr = om_duration;

        value_in = value_curr;
    }
}
void Person::om_TabPrenatCare_push_increment(int cell_in, int pending, big_counter pending_event_counter)
{
    assert(theTabPrenatCare); // unitary table must be instantiated

    auto& table = theTabPrenatCare;

    // Table has margins

    // Dimensionality of table (does not include measure dimension)
    const size_t rank = 3;

    // Size of each dimension of table (includes margin if present)
    const std::array<size_t, rank> shape = {6, 4, 151};

    // Number of dimensions with a margin
    const size_t margin_count = 2;

    // Dimensions with a margin
    const std::array<size_t, margin_count> margin_dims = {0, 1};

    // Number of margin combinations for a cell in the table body
    // e.g. a table with 3 margins has 2^3-1=7 margin cells associated with a body cell
    const size_t margin_combos = (1 << margin_count) - 1;

    // Indexes of table cells to increment (cell in table body and cells in margins)
    std::array<size_t, 1 + margin_combos> cells_to_increment;

    // Populate cells_to_increment

    // The cell in the table body:
    cells_to_increment[0] = cell_in;

    // The margin cells
    {
        // Dimension coordinates of the body cell being incremented
        std::array<size_t, rank> body_coordinates;
        // Decode dimension coordinates of the body cell
        for (int j = rank - 1, w = cell_in; j >= 0; --j) {
            body_coordinates[j] = w % shape[j];
            w /= shape[j];
        }
        // Working coordinates of a margin cell
        std::array<size_t, rank> margin_coordinates;
        for (size_t combo = 1; combo <= margin_combos; ++combo) {
            // The binary bits of combo select the margin dimensions for the combination.
            margin_coordinates = body_coordinates;
            size_t bits = combo;
            for (size_t margin = 0; margin < margin_count; ++margin) {
                // read out the bits in combo
                if (bits & 1) {
                    // low order bit is 1, so replace coordinate from body cell by margin coordinate
                    margin_coordinates[margin_dims[margin]] = shape[margin_dims[margin]] - 1;
                }
                bits >>= 1;
            }
            // Encode the dimension coordinates of the margin cell into flattened index
            size_t margin_cell = margin_coordinates[0];
            for (size_t j = 1; j < rank; ++j) {
                margin_cell *= shape[j];
                margin_cell += margin_coordinates[j];
            }
            assert(margin_cell >= 0 && margin_cell < 3624); // logic guarantee
            cells_to_increment[combo] = margin_cell;
        }
    }

    // Increments and Accumulators:
    //  accumulator 0: sum(delta(interval(duration(got_prenat_care, GPC_YES))))
    {
        const int acc_index = 0; // accumulator index

        // Compute increment
        Time value_out = om_duration_FOR_got_prenat_care_X_GPC_YES;
        auto& value_in = om_TabPrenatCare_in_om_duration_FOR_got_prenat_care_X_GPC_YES;

        double dIncrement;
        dIncrement = (double)value_out - (double)value_in;

        // Push increment to body cell and margin cells
        for (int cell : cells_to_increment) {
            auto& dAccumulator = table->acc[acc_index][cell];
            dAccumulator += dIncrement;
        }
    }
    //  accumulator 1: sum(delta(interval(duration())))
    {
        const int acc_index = 1; // accumulator index

        // Compute increment
        Time value_out = om_duration;
        auto& value_in = om_TabPrenatCare_in_om_duration;

        double dIncrement;
        dIncrement = (double)value_out - (double)value_in;

        // Push increment to body cell and margin cells
        for (int cell : cells_to_increment) {
            auto& dAccumulator = table->acc[acc_index][cell];
            dAccumulator += dIncrement;
        }
    }
}
int Person::om_TabPrimSchoolEntries_current_cell()
{
    assert(theTabPrimSchoolEntries); // unitary table must be instantiated

    // Dimensionality of table (does not include measure dimension)
    const size_t rank = 2;

    // Size of each dimension of table (includes margin if present)
    const std::array<size_t, rank> shape = {151, 13};

    // Dimension coordinates of current cell
    const std::array<size_t, rank> coordinates = {
        size_t(sim_year - 2000), 
        size_t(geo_nat), 
    };

    // Encode the dimension coordinates of the margin cell into flattened index
    size_t cell = coordinates[0];
    for (size_t j = 1; j < rank; ++j) {
        cell *= shape[j];
        cell += coordinates[j];
    }

    assert(cell >= 0 && cell < 1963); // logic guarantee
    return cell;
}
void Person::om_TabPrimSchoolEntries_init_increment(int pending, big_counter pending_event_counter)
{
    assert(theTabPrimSchoolEntries); // unitary table must be instantiated

    {
        // interval(om_entrances_FOR_educ_one_grade_attended_X_1)
        auto & value_in = om_TabPrimSchoolEntries_in_om_entrances_FOR_educ_one_grade_attended_X_1;
        counter value_curr = om_entrances_FOR_educ_one_grade_attended_X_1;

        value_in = value_curr;
    }
}
void Person::om_TabPrimSchoolEntries_push_increment(int cell_in, int pending, big_counter pending_event_counter)
{
    assert(theTabPrimSchoolEntries); // unitary table must be instantiated

    auto& table = theTabPrimSchoolEntries;

    // Table has margins

    // Dimensionality of table (does not include measure dimension)
    const size_t rank = 2;

    // Size of each dimension of table (includes margin if present)
    const std::array<size_t, rank> shape = {151, 13};

    // Number of dimensions with a margin
    const size_t margin_count = 1;

    // Dimensions with a margin
    const std::array<size_t, margin_count> margin_dims = {1};

    // Number of margin combinations for a cell in the table body
    // e.g. a table with 3 margins has 2^3-1=7 margin cells associated with a body cell
    const size_t margin_combos = (1 << margin_count) - 1;

    // Indexes of table cells to increment (cell in table body and cells in margins)
    std::array<size_t, 1 + margin_combos> cells_to_increment;

    // Populate cells_to_increment

    // The cell in the table body:
    cells_to_increment[0] = cell_in;

    // The margin cells
    {
        // Dimension coordinates of the body cell being incremented
        std::array<size_t, rank> body_coordinates;
        // Decode dimension coordinates of the body cell
        for (int j = rank - 1, w = cell_in; j >= 0; --j) {
            body_coordinates[j] = w % shape[j];
            w /= shape[j];
        }
        // Working coordinates of a margin cell
        std::array<size_t, rank> margin_coordinates;
        for (size_t combo = 1; combo <= margin_combos; ++combo) {
            // The binary bits of combo select the margin dimensions for the combination.
            margin_coordinates = body_coordinates;
            size_t bits = combo;
            for (size_t margin = 0; margin < margin_count; ++margin) {
                // read out the bits in combo
                if (bits & 1) {
                    // low order bit is 1, so replace coordinate from body cell by margin coordinate
                    margin_coordinates[margin_dims[margin]] = shape[margin_dims[margin]] - 1;
                }
                bits >>= 1;
            }
            // Encode the dimension coordinates of the margin cell into flattened index
            size_t margin_cell = margin_coordinates[0];
            for (size_t j = 1; j < rank; ++j) {
                margin_cell *= shape[j];
                margin_cell += margin_coordinates[j];
            }
            assert(margin_cell >= 0 && margin_cell < 1963); // logic guarantee
            cells_to_increment[combo] = margin_cell;
        }
    }

    // Increments and Accumulators:
    //  accumulator 0: sum(delta(interval(entrances(educ_one_grade_attended, 1))))
    {
        const int acc_index = 0; // accumulator index

        // Compute increment
        counter value_out = om_entrances_FOR_educ_one_grade_attended_X_1;
        auto& value_in = om_TabPrimSchoolEntries_in_om_entrances_FOR_educ_one_grade_attended_X_1;

        double dIncrement;
        dIncrement = (double)value_out - (double)value_in;

        // Push increment to body cell and margin cells
        for (int cell : cells_to_increment) {
            auto& dAccumulator = table->acc[acc_index][cell];
            dAccumulator += dIncrement;
        }
    }
}
int Person::om_TabPrimSchoolGraduations_current_cell()
{
    assert(theTabPrimSchoolGraduations); // unitary table must be instantiated

    // Dimensionality of table (does not include measure dimension)
    const size_t rank = 2;

    // Size of each dimension of table (includes margin if present)
    const std::array<size_t, rank> shape = {151, 13};

    // Dimension coordinates of current cell
    const std::array<size_t, rank> coordinates = {
        size_t(sim_year - 2000), 
        size_t(geo_nat), 
    };

    // Encode the dimension coordinates of the margin cell into flattened index
    size_t cell = coordinates[0];
    for (size_t j = 1; j < rank; ++j) {
        cell *= shape[j];
        cell += coordinates[j];
    }

    assert(cell >= 0 && cell < 1963); // logic guarantee
    return cell;
}
void Person::om_TabPrimSchoolGraduations_init_increment(int pending, big_counter pending_event_counter)
{
    assert(theTabPrimSchoolGraduations); // unitary table must be instantiated

    {
        // interval(om_entrances_FOR_has_passed_primary_X_true)
        auto & value_in = om_TabPrimSchoolGraduations_in_om_entrances_FOR_has_passed_primary_X_true;
        counter value_curr = om_entrances_FOR_has_passed_primary_X_true;

        value_in = value_curr;
    }
}
void Person::om_TabPrimSchoolGraduations_push_increment(int cell_in, int pending, big_counter pending_event_counter)
{
    assert(theTabPrimSchoolGraduations); // unitary table must be instantiated

    auto& table = theTabPrimSchoolGraduations;

    // Table has margins

    // Dimensionality of table (does not include measure dimension)
    const size_t rank = 2;

    // Size of each dimension of table (includes margin if present)
    const std::array<size_t, rank> shape = {151, 13};

    // Number of dimensions with a margin
    const size_t margin_count = 1;

    // Dimensions with a margin
    const std::array<size_t, margin_count> margin_dims = {1};

    // Number of margin combinations for a cell in the table body
    // e.g. a table with 3 margins has 2^3-1=7 margin cells associated with a body cell
    const size_t margin_combos = (1 << margin_count) - 1;

    // Indexes of table cells to increment (cell in table body and cells in margins)
    std::array<size_t, 1 + margin_combos> cells_to_increment;

    // Populate cells_to_increment

    // The cell in the table body:
    cells_to_increment[0] = cell_in;

    // The margin cells
    {
        // Dimension coordinates of the body cell being incremented
        std::array<size_t, rank> body_coordinates;
        // Decode dimension coordinates of the body cell
        for (int j = rank - 1, w = cell_in; j >= 0; --j) {
            body_coordinates[j] = w % shape[j];
            w /= shape[j];
        }
        // Working coordinates of a margin cell
        std::array<size_t, rank> margin_coordinates;
        for (size_t combo = 1; combo <= margin_combos; ++combo) {
            // The binary bits of combo select the margin dimensions for the combination.
            margin_coordinates = body_coordinates;
            size_t bits = combo;
            for (size_t margin = 0; margin < margin_count; ++margin) {
                // read out the bits in combo
                if (bits & 1) {
                    // low order bit is 1, so replace coordinate from body cell by margin coordinate
                    margin_coordinates[margin_dims[margin]] = shape[margin_dims[margin]] - 1;
                }
                bits >>= 1;
            }
            // Encode the dimension coordinates of the margin cell into flattened index
            size_t margin_cell = margin_coordinates[0];
            for (size_t j = 1; j < rank; ++j) {
                margin_cell *= shape[j];
                margin_cell += margin_coordinates[j];
            }
            assert(margin_cell >= 0 && margin_cell < 1963); // logic guarantee
            cells_to_increment[combo] = margin_cell;
        }
    }

    // Increments and Accumulators:
    //  accumulator 0: sum(delta(interval(entrances(has_passed_primary, true))))
    {
        const int acc_index = 0; // accumulator index

        // Compute increment
        counter value_out = om_entrances_FOR_has_passed_primary_X_true;
        auto& value_in = om_TabPrimSchoolGraduations_in_om_entrances_FOR_has_passed_primary_X_true;

        double dIncrement;
        dIncrement = (double)value_out - (double)value_in;

        // Push increment to body cell and margin cells
        for (int cell : cells_to_increment) {
            auto& dAccumulator = table->acc[acc_index][cell];
            dAccumulator += dIncrement;
        }
    }
}
int Person::om_TabPrimSchoolOutOfSchool9to11_current_cell()
{
    assert(theTabPrimSchoolOutOfSchool9to11); // unitary table must be instantiated

    // Dimensionality of table (does not include measure dimension)
    const size_t rank = 2;

    // Size of each dimension of table (includes margin if present)
    const std::array<size_t, rank> shape = {151, 13};

    // Dimension coordinates of current cell
    const std::array<size_t, rank> coordinates = {
        size_t(sim_year - 2000), 
        size_t(geo_nat), 
    };

    // Encode the dimension coordinates of the margin cell into flattened index
    size_t cell = coordinates[0];
    for (size_t j = 1; j < rank; ++j) {
        cell *= shape[j];
        cell += coordinates[j];
    }

    assert(cell >= 0 && cell < 1963); // logic guarantee
    return cell;
}
void Person::om_TabPrimSchoolOutOfSchool9to11_init_increment(int pending, big_counter pending_event_counter)
{
    assert(theTabPrimSchoolOutOfSchool9to11); // unitary table must be instantiated

    {
        // interval(om_duration_FOR_tab_out_of_primary_X_true)
        auto & value_in = om_TabPrimSchoolOutOfSchool9to11_in_om_duration_FOR_tab_out_of_primary_X_true;
        Time value_curr = om_duration_FOR_tab_out_of_primary_X_true;

        value_in = value_curr;
    }
    {
        // interval(om_duration)
        auto & value_in = om_TabPrimSchoolOutOfSchool9to11_in_om_duration;
        Time value_curr = om_duration;

        value_in = value_curr;
    }
}
void Person::om_TabPrimSchoolOutOfSchool9to11_push_increment(int cell_in, int pending, big_counter pending_event_counter)
{
    assert(theTabPrimSchoolOutOfSchool9to11); // unitary table must be instantiated

    auto& table = theTabPrimSchoolOutOfSchool9to11;

    // Table has margins

    // Dimensionality of table (does not include measure dimension)
    const size_t rank = 2;

    // Size of each dimension of table (includes margin if present)
    const std::array<size_t, rank> shape = {151, 13};

    // Number of dimensions with a margin
    const size_t margin_count = 1;

    // Dimensions with a margin
    const std::array<size_t, margin_count> margin_dims = {1};

    // Number of margin combinations for a cell in the table body
    // e.g. a table with 3 margins has 2^3-1=7 margin cells associated with a body cell
    const size_t margin_combos = (1 << margin_count) - 1;

    // Indexes of table cells to increment (cell in table body and cells in margins)
    std::array<size_t, 1 + margin_combos> cells_to_increment;

    // Populate cells_to_increment

    // The cell in the table body:
    cells_to_increment[0] = cell_in;

    // The margin cells
    {
        // Dimension coordinates of the body cell being incremented
        std::array<size_t, rank> body_coordinates;
        // Decode dimension coordinates of the body cell
        for (int j = rank - 1, w = cell_in; j >= 0; --j) {
            body_coordinates[j] = w % shape[j];
            w /= shape[j];
        }
        // Working coordinates of a margin cell
        std::array<size_t, rank> margin_coordinates;
        for (size_t combo = 1; combo <= margin_combos; ++combo) {
            // The binary bits of combo select the margin dimensions for the combination.
            margin_coordinates = body_coordinates;
            size_t bits = combo;
            for (size_t margin = 0; margin < margin_count; ++margin) {
                // read out the bits in combo
                if (bits & 1) {
                    // low order bit is 1, so replace coordinate from body cell by margin coordinate
                    margin_coordinates[margin_dims[margin]] = shape[margin_dims[margin]] - 1;
                }
                bits >>= 1;
            }
            // Encode the dimension coordinates of the margin cell into flattened index
            size_t margin_cell = margin_coordinates[0];
            for (size_t j = 1; j < rank; ++j) {
                margin_cell *= shape[j];
                margin_cell += margin_coordinates[j];
            }
            assert(margin_cell >= 0 && margin_cell < 1963); // logic guarantee
            cells_to_increment[combo] = margin_cell;
        }
    }

    // Increments and Accumulators:
    //  accumulator 0: sum(delta(interval(duration(tab_out_of_primary, true))))
    {
        const int acc_index = 0; // accumulator index

        // Compute increment
        Time value_out = om_duration_FOR_tab_out_of_primary_X_true;
        auto& value_in = om_TabPrimSchoolOutOfSchool9to11_in_om_duration_FOR_tab_out_of_primary_X_true;

        double dIncrement;
        dIncrement = (double)value_out - (double)value_in;

        // Push increment to body cell and margin cells
        for (int cell : cells_to_increment) {
            auto& dAccumulator = table->acc[acc_index][cell];
            dAccumulator += dIncrement;
        }
    }
    //  accumulator 1: sum(delta(interval(duration())))
    {
        const int acc_index = 1; // accumulator index

        // Compute increment
        Time value_out = om_duration;
        auto& value_in = om_TabPrimSchoolOutOfSchool9to11_in_om_duration;

        double dIncrement;
        dIncrement = (double)value_out - (double)value_in;

        // Push increment to body cell and margin cells
        for (int cell : cells_to_increment) {
            auto& dAccumulator = table->acc[acc_index][cell];
            dAccumulator += dIncrement;
        }
    }
}
int Person::om_TabPrimarySchoolPlanning_current_cell()
{
    assert(theTabPrimarySchoolPlanning); // unitary table must be instantiated

    // Dimensionality of table (does not include measure dimension)
    const size_t rank = 3;

    // Size of each dimension of table (includes margin if present)
    const std::array<size_t, rank> shape = {13, 151, 7};

    // Dimension coordinates of current cell
    const std::array<size_t, rank> coordinates = {
        size_t(geo_nat), 
        size_t(sim_year - 2000), 
        size_t(educ_one_grade - 1), 
    };

    // Encode the dimension coordinates of the margin cell into flattened index
    size_t cell = coordinates[0];
    for (size_t j = 1; j < rank; ++j) {
        cell *= shape[j];
        cell += coordinates[j];
    }

    assert(cell >= 0 && cell < 13741); // logic guarantee
    return cell;
}
void Person::om_TabPrimarySchoolPlanning_init_increment(int pending, big_counter pending_event_counter)
{
    assert(theTabPrimarySchoolPlanning); // unitary table must be instantiated

}
void Person::om_TabPrimarySchoolPlanning_push_increment(int cell_in, int pending, big_counter pending_event_counter)
{
    assert(theTabPrimarySchoolPlanning); // unitary table must be instantiated

    auto& table = theTabPrimarySchoolPlanning;

    // Table has margins

    // Dimensionality of table (does not include measure dimension)
    const size_t rank = 3;

    // Size of each dimension of table (includes margin if present)
    const std::array<size_t, rank> shape = {13, 151, 7};

    // Number of dimensions with a margin
    const size_t margin_count = 2;

    // Dimensions with a margin
    const std::array<size_t, margin_count> margin_dims = {0, 2};

    // Number of margin combinations for a cell in the table body
    // e.g. a table with 3 margins has 2^3-1=7 margin cells associated with a body cell
    const size_t margin_combos = (1 << margin_count) - 1;

    // Indexes of table cells to increment (cell in table body and cells in margins)
    std::array<size_t, 1 + margin_combos> cells_to_increment;

    // Populate cells_to_increment

    // The cell in the table body:
    cells_to_increment[0] = cell_in;

    // The margin cells
    {
        // Dimension coordinates of the body cell being incremented
        std::array<size_t, rank> body_coordinates;
        // Decode dimension coordinates of the body cell
        for (int j = rank - 1, w = cell_in; j >= 0; --j) {
            body_coordinates[j] = w % shape[j];
            w /= shape[j];
        }
        // Working coordinates of a margin cell
        std::array<size_t, rank> margin_coordinates;
        for (size_t combo = 1; combo <= margin_combos; ++combo) {
            // The binary bits of combo select the margin dimensions for the combination.
            margin_coordinates = body_coordinates;
            size_t bits = combo;
            for (size_t margin = 0; margin < margin_count; ++margin) {
                // read out the bits in combo
                if (bits & 1) {
                    // low order bit is 1, so replace coordinate from body cell by margin coordinate
                    margin_coordinates[margin_dims[margin]] = shape[margin_dims[margin]] - 1;
                }
                bits >>= 1;
            }
            // Encode the dimension coordinates of the margin cell into flattened index
            size_t margin_cell = margin_coordinates[0];
            for (size_t j = 1; j < rank; ++j) {
                margin_cell *= shape[j];
                margin_cell += margin_coordinates[j];
            }
            assert(margin_cell >= 0 && margin_cell < 13741); // logic guarantee
            cells_to_increment[combo] = margin_cell;
        }
    }

    // Increments and Accumulators:
    //  accumulator 0: unit
    {
        const int acc_index = 0; // accumulator index

        // Compute increment

        double dIncrement;
        dIncrement = 1.0;

        // Push increment to body cell and margin cells
        for (int cell : cells_to_increment) {
            auto& dAccumulator = table->acc[acc_index][cell];
            dAccumulator += dIncrement;
        }
    }
    //  accumulator 1: sum(value_out(interval(educ_one_required_teachers)))
    {
        const int acc_index = 1; // accumulator index

        // Compute increment
        double value_out = educ_one_required_teachers;

        double dIncrement;
        dIncrement = value_out;

        // Push increment to body cell and margin cells
        for (int cell : cells_to_increment) {
            auto& dAccumulator = table->acc[acc_index][cell];
            dAccumulator += dIncrement;
        }
    }
    //  accumulator 2: sum(value_out(interval(educ_one_required_rooms)))
    {
        const int acc_index = 2; // accumulator index

        // Compute increment
        double value_out = educ_one_required_rooms;

        double dIncrement;
        dIncrement = value_out;

        // Push increment to body cell and margin cells
        for (int cell : cells_to_increment) {
            auto& dAccumulator = table->acc[acc_index][cell];
            dAccumulator += dIncrement;
        }
    }
}
int Person::om_TabSchool2AttainmentsTab_current_cell()
{
    assert(theTabSchool2AttainmentsTab); // unitary table must be instantiated

    // Dimensionality of table (does not include measure dimension)
    const size_t rank = 2;

    // Size of each dimension of table (includes margin if present)
    const std::array<size_t, rank> shape = {3, 151};

    // Dimension coordinates of current cell
    const std::array<size_t, rank> coordinates = {
        size_t(sex), 
        size_t(sim_year - 2000), 
    };

    // Encode the dimension coordinates of the margin cell into flattened index
    size_t cell = coordinates[0];
    for (size_t j = 1; j < rank; ++j) {
        cell *= shape[j];
        cell += coordinates[j];
    }

    assert(cell >= 0 && cell < 453); // logic guarantee
    return cell;
}
void Person::om_TabSchool2AttainmentsTab_init_increment(int pending, big_counter pending_event_counter)
{
    assert(theTabSchool2AttainmentsTab); // unitary table must be instantiated

    {
        // interval(om_duration_FOR_educ_two_level_X_ETL_NEVER)
        auto & value_in = om_TabSchool2AttainmentsTab_in_om_duration_FOR_educ_two_level_X_ETL_NEVER;
        Time value_curr = om_duration_FOR_educ_two_level_X_ETL_NEVER;

        value_in = value_curr;
    }
    {
        // interval(om_duration)
        auto & value_in = om_TabSchool2AttainmentsTab_in_om_duration;
        Time value_curr = om_duration;

        value_in = value_curr;
    }
    {
        // interval(om_duration_FOR_educ_two_level_X_ETL_INCOMPLETE)
        auto & value_in = om_TabSchool2AttainmentsTab_in_om_duration_FOR_educ_two_level_X_ETL_INCOMPLETE;
        Time value_curr = om_duration_FOR_educ_two_level_X_ETL_INCOMPLETE;

        value_in = value_curr;
    }
    {
        // interval(om_duration_FOR_educ_two_level_X_ETL_GRADUATE)
        auto & value_in = om_TabSchool2AttainmentsTab_in_om_duration_FOR_educ_two_level_X_ETL_GRADUATE;
        Time value_curr = om_duration_FOR_educ_two_level_X_ETL_GRADUATE;

        value_in = value_curr;
    }
}
void Person::om_TabSchool2AttainmentsTab_push_increment(int cell_in, int pending, big_counter pending_event_counter)
{
    assert(theTabSchool2AttainmentsTab); // unitary table must be instantiated

    auto& table = theTabSchool2AttainmentsTab;

    // Table has margins

    // Dimensionality of table (does not include measure dimension)
    const size_t rank = 2;

    // Size of each dimension of table (includes margin if present)
    const std::array<size_t, rank> shape = {3, 151};

    // Number of dimensions with a margin
    const size_t margin_count = 1;

    // Dimensions with a margin
    const std::array<size_t, margin_count> margin_dims = {0};

    // Number of margin combinations for a cell in the table body
    // e.g. a table with 3 margins has 2^3-1=7 margin cells associated with a body cell
    const size_t margin_combos = (1 << margin_count) - 1;

    // Indexes of table cells to increment (cell in table body and cells in margins)
    std::array<size_t, 1 + margin_combos> cells_to_increment;

    // Populate cells_to_increment

    // The cell in the table body:
    cells_to_increment[0] = cell_in;

    // The margin cells
    {
        // Dimension coordinates of the body cell being incremented
        std::array<size_t, rank> body_coordinates;
        // Decode dimension coordinates of the body cell
        for (int j = rank - 1, w = cell_in; j >= 0; --j) {
            body_coordinates[j] = w % shape[j];
            w /= shape[j];
        }
        // Working coordinates of a margin cell
        std::array<size_t, rank> margin_coordinates;
        for (size_t combo = 1; combo <= margin_combos; ++combo) {
            // The binary bits of combo select the margin dimensions for the combination.
            margin_coordinates = body_coordinates;
            size_t bits = combo;
            for (size_t margin = 0; margin < margin_count; ++margin) {
                // read out the bits in combo
                if (bits & 1) {
                    // low order bit is 1, so replace coordinate from body cell by margin coordinate
                    margin_coordinates[margin_dims[margin]] = shape[margin_dims[margin]] - 1;
                }
                bits >>= 1;
            }
            // Encode the dimension coordinates of the margin cell into flattened index
            size_t margin_cell = margin_coordinates[0];
            for (size_t j = 1; j < rank; ++j) {
                margin_cell *= shape[j];
                margin_cell += margin_coordinates[j];
            }
            assert(margin_cell >= 0 && margin_cell < 453); // logic guarantee
            cells_to_increment[combo] = margin_cell;
        }
    }

    // Increments and Accumulators:
    //  accumulator 0: sum(delta(interval(duration(educ_two_level, ETL_NEVER))))
    {
        const int acc_index = 0; // accumulator index

        // Compute increment
        Time value_out = om_duration_FOR_educ_two_level_X_ETL_NEVER;
        auto& value_in = om_TabSchool2AttainmentsTab_in_om_duration_FOR_educ_two_level_X_ETL_NEVER;

        double dIncrement;
        dIncrement = (double)value_out - (double)value_in;

        // Push increment to body cell and margin cells
        for (int cell : cells_to_increment) {
            auto& dAccumulator = table->acc[acc_index][cell];
            dAccumulator += dIncrement;
        }
    }
    //  accumulator 1: sum(delta(interval(duration())))
    {
        const int acc_index = 1; // accumulator index

        // Compute increment
        Time value_out = om_duration;
        auto& value_in = om_TabSchool2AttainmentsTab_in_om_duration;

        double dIncrement;
        dIncrement = (double)value_out - (double)value_in;

        // Push increment to body cell and margin cells
        for (int cell : cells_to_increment) {
            auto& dAccumulator = table->acc[acc_index][cell];
            dAccumulator += dIncrement;
        }
    }
    //  accumulator 2: sum(delta(interval(duration(educ_two_level, ETL_INCOMPLETE))))
    {
        const int acc_index = 2; // accumulator index

        // Compute increment
        Time value_out = om_duration_FOR_educ_two_level_X_ETL_INCOMPLETE;
        auto& value_in = om_TabSchool2AttainmentsTab_in_om_duration_FOR_educ_two_level_X_ETL_INCOMPLETE;

        double dIncrement;
        dIncrement = (double)value_out - (double)value_in;

        // Push increment to body cell and margin cells
        for (int cell : cells_to_increment) {
            auto& dAccumulator = table->acc[acc_index][cell];
            dAccumulator += dIncrement;
        }
    }
    //  accumulator 3: sum(delta(interval(duration(educ_two_level, ETL_GRADUATE))))
    {
        const int acc_index = 3; // accumulator index

        // Compute increment
        Time value_out = om_duration_FOR_educ_two_level_X_ETL_GRADUATE;
        auto& value_in = om_TabSchool2AttainmentsTab_in_om_duration_FOR_educ_two_level_X_ETL_GRADUATE;

        double dIncrement;
        dIncrement = (double)value_out - (double)value_in;

        // Push increment to body cell and margin cells
        for (int cell : cells_to_increment) {
            auto& dAccumulator = table->acc[acc_index][cell];
            dAccumulator += dIncrement;
        }
    }
}
int Person::om_TabSchool2TrackTab_current_cell()
{
    assert(theTabSchool2TrackTab); // unitary table must be instantiated

    // Dimensionality of table (does not include measure dimension)
    const size_t rank = 2;

    // Size of each dimension of table (includes margin if present)
    const std::array<size_t, rank> shape = {151, 8};

    // Dimension coordinates of current cell
    const std::array<size_t, rank> coordinates = {
        size_t(sim_year - 2000), 
        size_t(educ_two_grade_attended), 
    };

    // Encode the dimension coordinates of the margin cell into flattened index
    size_t cell = coordinates[0];
    for (size_t j = 1; j < rank; ++j) {
        cell *= shape[j];
        cell += coordinates[j];
    }

    assert(cell >= 0 && cell < 1208); // logic guarantee
    return cell;
}
void Person::om_TabSchool2TrackTab_init_increment(int pending, big_counter pending_event_counter)
{
    assert(theTabSchool2TrackTab); // unitary table must be instantiated

}
void Person::om_TabSchool2TrackTab_push_increment(int cell_in, int pending, big_counter pending_event_counter)
{
    assert(theTabSchool2TrackTab); // unitary table must be instantiated

    auto& table = theTabSchool2TrackTab;

    // Table has margins

    // Dimensionality of table (does not include measure dimension)
    const size_t rank = 2;

    // Size of each dimension of table (includes margin if present)
    const std::array<size_t, rank> shape = {151, 8};

    // Number of dimensions with a margin
    const size_t margin_count = 1;

    // Dimensions with a margin
    const std::array<size_t, margin_count> margin_dims = {1};

    // Number of margin combinations for a cell in the table body
    // e.g. a table with 3 margins has 2^3-1=7 margin cells associated with a body cell
    const size_t margin_combos = (1 << margin_count) - 1;

    // Indexes of table cells to increment (cell in table body and cells in margins)
    std::array<size_t, 1 + margin_combos> cells_to_increment;

    // Populate cells_to_increment

    // The cell in the table body:
    cells_to_increment[0] = cell_in;

    // The margin cells
    {
        // Dimension coordinates of the body cell being incremented
        std::array<size_t, rank> body_coordinates;
        // Decode dimension coordinates of the body cell
        for (int j = rank - 1, w = cell_in; j >= 0; --j) {
            body_coordinates[j] = w % shape[j];
            w /= shape[j];
        }
        // Working coordinates of a margin cell
        std::array<size_t, rank> margin_coordinates;
        for (size_t combo = 1; combo <= margin_combos; ++combo) {
            // The binary bits of combo select the margin dimensions for the combination.
            margin_coordinates = body_coordinates;
            size_t bits = combo;
            for (size_t margin = 0; margin < margin_count; ++margin) {
                // read out the bits in combo
                if (bits & 1) {
                    // low order bit is 1, so replace coordinate from body cell by margin coordinate
                    margin_coordinates[margin_dims[margin]] = shape[margin_dims[margin]] - 1;
                }
                bits >>= 1;
            }
            // Encode the dimension coordinates of the margin cell into flattened index
            size_t margin_cell = margin_coordinates[0];
            for (size_t j = 1; j < rank; ++j) {
                margin_cell *= shape[j];
                margin_cell += margin_coordinates[j];
            }
            assert(margin_cell >= 0 && margin_cell < 1208); // logic guarantee
            cells_to_increment[combo] = margin_cell;
        }
    }

    // Increments and Accumulators:
    //  accumulator 0: unit
    {
        const int acc_index = 0; // accumulator index

        // Compute increment

        double dIncrement;
        dIncrement = 1.0;

        // Push increment to body cell and margin cells
        for (int cell : cells_to_increment) {
            auto& dAccumulator = table->acc[acc_index][cell];
            dAccumulator += dIncrement;
        }
    }
}
void Person::om_aia_0_update_identity()
{
    //#line This is a generated identity attribute which has no associated model source file
    om_aia_0.set((this_parity_spell == true));
}
#line 7034 "C:/Users/Martin/Dropbox/openM++/models/Dynamis-Pop-3-06-ABC/ompp/src/om_definitions.cpp"
void Person::om_aia_10_update_identity()
{
    //#line This is a generated identity attribute which has no associated model source file
    om_aia_10.set((educ_one_level == EOL_LOW));
}
#line 7040 "C:/Users/Martin/Dropbox/openM++/models/Dynamis-Pop-3-06-ABC/ompp/src/om_definitions.cpp"
void Person::om_aia_11_update_identity()
{
    //#line This is a generated identity attribute which has no associated model source file
    om_aia_11.set((educ_one_level == EOL_MEDIUM));
}
#line 7046 "C:/Users/Martin/Dropbox/openM++/models/Dynamis-Pop-3-06-ABC/ompp/src/om_definitions.cpp"
void Person::om_aia_12_update_identity()
{
    //#line This is a generated identity attribute which has no associated model source file
    om_aia_12.set((educ_one_level == EOL_HIGH));
}
#line 7052 "C:/Users/Martin/Dropbox/openM++/models/Dynamis-Pop-3-06-ABC/ompp/src/om_definitions.cpp"
void Person::om_aia_13_update_identity()
{
    #line 115 "../code/TablesEducation.mpp"
    om_aia_13.set((((in_projected_time && om_trigger_changes_FOR_calendar_year) && (integer_age == 0)) && (creation_type == CT_BIRTH)));
}
#line 7058 "C:/Users/Martin/Dropbox/openM++/models/Dynamis-Pop-3-06-ABC/ompp/src/om_definitions.cpp"
void Person::om_aia_14_update_identity()
{
    #line 126 "../code/TablesEducation.mpp"
    om_aia_14.set((((in_projected_time && om_trigger_changes_FOR_calendar_year) && is_educ_one_student) && is_resident));
}
#line 7064 "C:/Users/Martin/Dropbox/openM++/models/Dynamis-Pop-3-06-ABC/ompp/src/om_definitions.cpp"
void Person::om_aia_15_update_identity()
{
    #line 139 "../code/TablesEducation.mpp"
    om_aia_15.set((in_projected_time && is_resident));
}
#line 7070 "C:/Users/Martin/Dropbox/openM++/models/Dynamis-Pop-3-06-ABC/ompp/src/om_definitions.cpp"
void Person::om_aia_16_update_identity()
{
    //#line This is a generated identity attribute which has no associated model source file
    om_aia_16.set((is_child == true));
}
#line 7076 "C:/Users/Martin/Dropbox/openM++/models/Dynamis-Pop-3-06-ABC/ompp/src/om_definitions.cpp"
void Person::om_aia_17_update_identity()
{
    //#line This is a generated identity attribute which has no associated model source file
    om_aia_17.set((is_aded0 == true));
}
#line 7082 "C:/Users/Martin/Dropbox/openM++/models/Dynamis-Pop-3-06-ABC/ompp/src/om_definitions.cpp"
void Person::om_aia_18_update_identity()
{
    //#line This is a generated identity attribute which has no associated model source file
    om_aia_18.set((is_aded1 == true));
}
#line 7088 "C:/Users/Martin/Dropbox/openM++/models/Dynamis-Pop-3-06-ABC/ompp/src/om_definitions.cpp"
void Person::om_aia_19_update_identity()
{
    //#line This is a generated identity attribute which has no associated model source file
    om_aia_19.set((is_aded2 == true));
}
#line 7094 "C:/Users/Martin/Dropbox/openM++/models/Dynamis-Pop-3-06-ABC/ompp/src/om_definitions.cpp"
void Person::om_aia_1_update_identity()
{
    #line 76 "../code/TablesEducation.mpp"
    om_aia_1.set((WITHIN(SIM_YEAR_RANGE, year_of_birth) && (integer_age == 10)));
}
#line 7100 "C:/Users/Martin/Dropbox/openM++/models/Dynamis-Pop-3-06-ABC/ompp/src/om_definitions.cpp"
void Person::om_aia_20_update_identity()
{
    //#line This is a generated identity attribute which has no associated model source file
    om_aia_20.set((is_old == true));
}
#line 7106 "C:/Users/Martin/Dropbox/openM++/models/Dynamis-Pop-3-06-ABC/ompp/src/om_definitions.cpp"
void Person::om_aia_21_update_identity()
{
    #line 154 "../code/TablesEducation.mpp"
    om_aia_21.set(((om_trigger_changes_FOR_calendar_year && (integer_age == 0)) && is_resident));
}
#line 7112 "C:/Users/Martin/Dropbox/openM++/models/Dynamis-Pop-3-06-ABC/ompp/src/om_definitions.cpp"
void Person::om_aia_22_update_identity()
{
    #line 165 "../code/TablesEducation.mpp"
    om_aia_22.set((((integer_age == 15) && in_projected_time) && is_resident));
}
#line 7118 "C:/Users/Martin/Dropbox/openM++/models/Dynamis-Pop-3-06-ABC/ompp/src/om_definitions.cpp"
void Person::om_aia_23_update_identity()
{
    #line 211 "../code/TablesEducation.mpp"
    om_aia_23.set((((in_projected_time && is_resident) && (integer_age >= 9)) && (integer_age <= 11)));
}
#line 7124 "C:/Users/Martin/Dropbox/openM++/models/Dynamis-Pop-3-06-ABC/ompp/src/om_definitions.cpp"
void Person::om_aia_24_update_identity()
{
    //#line This is a generated identity attribute which has no associated model source file
    om_aia_24.set((tab_out_of_primary == true));
}
#line 7130 "C:/Users/Martin/Dropbox/openM++/models/Dynamis-Pop-3-06-ABC/ompp/src/om_definitions.cpp"
void Person::om_aia_25_update_identity()
{
    #line 221 "../code/TablesEducation.mpp"
    om_aia_25.set((((om_trigger_changes_FOR_calendar_year && in_projected_time) && is_resident) && (educ_two_status == ETS_ATTEND)));
}
#line 7136 "C:/Users/Martin/Dropbox/openM++/models/Dynamis-Pop-3-06-ABC/ompp/src/om_definitions.cpp"
void Person::om_aia_26_update_identity()
{
    #line 231 "../code/TablesEducation.mpp"
    om_aia_26.set((((in_projected_time && is_resident) && (integer_age >= 20)) && (integer_age < 25)));
}
#line 7142 "C:/Users/Martin/Dropbox/openM++/models/Dynamis-Pop-3-06-ABC/ompp/src/om_definitions.cpp"
void Person::om_aia_27_update_identity()
{
    //#line This is a generated identity attribute which has no associated model source file
    om_aia_27.set((educ_two_level == ETL_NEVER));
}
#line 7148 "C:/Users/Martin/Dropbox/openM++/models/Dynamis-Pop-3-06-ABC/ompp/src/om_definitions.cpp"
void Person::om_aia_28_update_identity()
{
    //#line This is a generated identity attribute which has no associated model source file
    om_aia_28.set((educ_two_level == ETL_INCOMPLETE));
}
#line 7154 "C:/Users/Martin/Dropbox/openM++/models/Dynamis-Pop-3-06-ABC/ompp/src/om_definitions.cpp"
void Person::om_aia_29_update_identity()
{
    //#line This is a generated identity attribute which has no associated model source file
    om_aia_29.set((educ_two_level == ETL_GRADUATE));
}
#line 7160 "C:/Users/Martin/Dropbox/openM++/models/Dynamis-Pop-3-06-ABC/ompp/src/om_definitions.cpp"
void Person::om_aia_2_update_identity()
{
    //#line This is a generated identity attribute which has no associated model source file
    om_aia_2.set((years_preschool == 0));
}
#line 7166 "C:/Users/Martin/Dropbox/openM++/models/Dynamis-Pop-3-06-ABC/ompp/src/om_definitions.cpp"
void Person::om_aia_30_update_identity()
{
    #line 13 "../code/TablesFamily.mpp"
    om_aia_30.set((WITHIN(SIM_YEAR_RANGE, calendar_year) && is_resident));
}
#line 7172 "C:/Users/Martin/Dropbox/openM++/models/Dynamis-Pop-3-06-ABC/ompp/src/om_definitions.cpp"
void Person::om_aia_31_update_identity()
{
    //#line This is a generated identity attribute which has no associated model source file
    om_aia_31.set((has_spouse == true));
}
#line 7178 "C:/Users/Martin/Dropbox/openM++/models/Dynamis-Pop-3-06-ABC/ompp/src/om_definitions.cpp"
void Person::om_aia_32_update_identity()
{
    //#line This is a generated identity attribute which has no associated model source file
    om_aia_32.set((ever_union == true));
}
#line 7184 "C:/Users/Martin/Dropbox/openM++/models/Dynamis-Pop-3-06-ABC/ompp/src/om_definitions.cpp"
void Person::om_aia_33_update_identity()
{
    #line 17 "../code/TablesHumanCapital.mpp"
    om_aia_33.set(((in_projected_time && in_hci_sample) && (year_of_birth >= MIN(SIM_YEAR_RANGE))));
}
#line 7190 "C:/Users/Martin/Dropbox/openM++/models/Dynamis-Pop-3-06-ABC/ompp/src/om_definitions.cpp"
void Person::om_aia_34_update_identity()
{
    #line 45 "../code/TablesPopulation.mpp"
    om_aia_34.set(WITHIN(SIM_YEAR_RANGE, calendar_year));
}
#line 7196 "C:/Users/Martin/Dropbox/openM++/models/Dynamis-Pop-3-06-ABC/ompp/src/om_definitions.cpp"
void Person::om_aia_35_update_identity()
{
    #line 65 "../code/TablesPopulation.mpp"
    om_aia_35.set(((WITHIN(SIM_YEAR_RANGE, calendar_year) && om_trigger_changes_FOR_geo) && in_selected_year));
}
#line 7202 "C:/Users/Martin/Dropbox/openM++/models/Dynamis-Pop-3-06-ABC/ompp/src/om_definitions.cpp"
void Person::om_aia_36_update_identity()
{
    #line 17 "../code/TablesStunting.mpp"
    om_aia_36.set((((in_projected_time && is_resident) && (creation_type == CT_BIRTH)) && om_trigger_entrances_FOR_is_ready_for_birthtables_X_true));
}
#line 7208 "C:/Users/Martin/Dropbox/openM++/models/Dynamis-Pop-3-06-ABC/ompp/src/om_definitions.cpp"
void Person::om_aia_37_update_identity()
{
    #line 19 "../code/TablesVaccination.mpp"
    om_aia_37.set((((in_projected_time && (integer_age == 0)) && (creation_type == CT_BIRTH)) && is_resident));
}
#line 7214 "C:/Users/Martin/Dropbox/openM++/models/Dynamis-Pop-3-06-ABC/ompp/src/om_definitions.cpp"
void Person::om_aia_38_update_identity()
{
    //#line This is a generated identity attribute which has no associated model source file
    om_aia_38.set((got_prenat_care == GPC_YES));
}
#line 7220 "C:/Users/Martin/Dropbox/openM++/models/Dynamis-Pop-3-06-ABC/ompp/src/om_definitions.cpp"
void Person::om_aia_39_update_identity()
{
    //#line This is a generated identity attribute which has no associated model source file
    om_aia_39.set((is_immunized == true));
}
#line 7226 "C:/Users/Martin/Dropbox/openM++/models/Dynamis-Pop-3-06-ABC/ompp/src/om_definitions.cpp"
void Person::om_aia_3_update_identity()
{
    //#line This is a generated identity attribute which has no associated model source file
    om_aia_3.set((years_preschool == 1));
}
#line 7232 "C:/Users/Martin/Dropbox/openM++/models/Dynamis-Pop-3-06-ABC/ompp/src/om_definitions.cpp"
void Person::om_aia_40_update_identity()
{
    #line 46 "../code/TablesVaccination.mpp"
    om_aia_40.set((((in_projected_time && (creation_type == CT_BIRTH)) && is_resident) && (integer_age == 0)));
}
#line 7238 "C:/Users/Martin/Dropbox/openM++/models/Dynamis-Pop-3-06-ABC/ompp/src/om_definitions.cpp"
void Person::om_aia_4_update_identity()
{
    //#line This is a generated identity attribute which has no associated model source file
    om_aia_4.set((years_preschool == 2));
}
#line 7244 "C:/Users/Martin/Dropbox/openM++/models/Dynamis-Pop-3-06-ABC/ompp/src/om_definitions.cpp"
void Person::om_aia_5_update_identity()
{
    #line 88 "../code/TablesEducation.mpp"
    om_aia_5.set((integer_age == 1));
}
#line 7250 "C:/Users/Martin/Dropbox/openM++/models/Dynamis-Pop-3-06-ABC/ompp/src/om_definitions.cpp"
void Person::om_aia_6_update_identity()
{
    //#line This is a generated identity attribute which has no associated model source file
    om_aia_6.set((educ_one_fate == EOL_LOW));
}
#line 7256 "C:/Users/Martin/Dropbox/openM++/models/Dynamis-Pop-3-06-ABC/ompp/src/om_definitions.cpp"
void Person::om_aia_7_update_identity()
{
    //#line This is a generated identity attribute which has no associated model source file
    om_aia_7.set((educ_one_fate == EOL_MEDIUM));
}
#line 7262 "C:/Users/Martin/Dropbox/openM++/models/Dynamis-Pop-3-06-ABC/ompp/src/om_definitions.cpp"
void Person::om_aia_8_update_identity()
{
    //#line This is a generated identity attribute which has no associated model source file
    om_aia_8.set((educ_one_fate == EOL_HIGH));
}
#line 7268 "C:/Users/Martin/Dropbox/openM++/models/Dynamis-Pop-3-06-ABC/ompp/src/om_definitions.cpp"
void Person::om_aia_9_update_identity()
{
    #line 101 "../code/TablesEducation.mpp"
    om_aia_9.set((in_sel_years && is_resident));
}
#line 7274 "C:/Users/Martin/Dropbox/openM++/models/Dynamis-Pop-3-06-ABC/ompp/src/om_definitions.cpp"
void Person::om_asAllFertilePersonsForFertilityAlignmentByAge_erase()
{
    int cell = om_asAllFertilePersonsForFertilityAlignmentByAge_cell;
    EntitySet<Person> ** flattened_array = reinterpret_cast<EntitySet<Person> **>(asAllFertilePersonsForFertilityAlignmentByAge);
    assert(flattened_array[cell]);
    flattened_array[cell]->erase(this);
}
void Person::om_asAllFertilePersonsForFertilityAlignmentByAge_filter_update_identity()
{
    #line 27 "../code/FertilityDetailed.mpp"
    om_asAllFertilePersonsForFertilityAlignmentByAge_filter.set(((FertilityModel == FEM_ALIGNED_AGE) && is_fertile));
}
#line 7287 "C:/Users/Martin/Dropbox/openM++/models/Dynamis-Pop-3-06-ABC/ompp/src/om_definitions.cpp"
void Person::om_asAllFertilePersonsForFertilityAlignmentByAge_insert()
{
    int cell = om_asAllFertilePersonsForFertilityAlignmentByAge_cell;
    EntitySet<Person> ** flattened_array = reinterpret_cast<EntitySet<Person> **>(asAllFertilePersonsForFertilityAlignmentByAge);
    assert(flattened_array[cell]);
    flattened_array[cell]->insert(this);
}
void Person::om_asAllFertilePersonsForFertilityAlignmentByAge_update_cell()
{
    int cell = 0;
    int index = 0;

    // dimension=0 agentvar=fertile_age type=FERTILE_AGE_RANGE size=38
    index = fertile_age;
    // adjust range to zero-based
    index -= 12;
    cell += index;

    // dimension=1 agentvar=is_resident type=bool size=2
    cell *= 2;
    index = is_resident;
    cell += index;

    assert(cell >= 0 && cell < 76); // logic guarantee

    om_asAllFertilePersonsForFertilityAlignmentByAge_cell = cell;
}
void Person::om_asAllFertilePersonsForFertilityAlignment_erase()
{
    int cell = om_asAllFertilePersonsForFertilityAlignment_cell;
    EntitySet<Person> ** flattened_array = reinterpret_cast<EntitySet<Person> **>(asAllFertilePersonsForFertilityAlignment);
    assert(flattened_array[cell]);
    flattened_array[cell]->erase(this);
}
void Person::om_asAllFertilePersonsForFertilityAlignment_filter_update_identity()
{
    #line 31 "../code/FertilityDetailed.mpp"
    om_asAllFertilePersonsForFertilityAlignment_filter.set(((FertilityModel == FEM_ALIGNED_TOTAL) && is_fertile));
}
#line 7327 "C:/Users/Martin/Dropbox/openM++/models/Dynamis-Pop-3-06-ABC/ompp/src/om_definitions.cpp"
void Person::om_asAllFertilePersonsForFertilityAlignment_insert()
{
    int cell = om_asAllFertilePersonsForFertilityAlignment_cell;
    EntitySet<Person> ** flattened_array = reinterpret_cast<EntitySet<Person> **>(asAllFertilePersonsForFertilityAlignment);
    assert(flattened_array[cell]);
    flattened_array[cell]->insert(this);
}
void Person::om_asAllFertilePersonsForFertilityAlignment_update_cell()
{
    int cell = 0;
    int index = 0;

    // dimension=0 agentvar=is_resident type=bool size=2
    index = is_resident;
    cell += index;

    assert(cell >= 0 && cell < 2); // logic guarantee

    om_asAllFertilePersonsForFertilityAlignment_cell = cell;
}
void Person::om_asAllPerson_erase()
{
    asAllPerson->erase(this);
}
void Person::om_asAllPerson_filter_update_identity()
{
    #line 40 "../code/ActorPerson.mpp"
    om_asAllPerson_filter.set(is_alive);
}
#line 7357 "C:/Users/Martin/Dropbox/openM++/models/Dynamis-Pop-3-06-ABC/ompp/src/om_definitions.cpp"
void Person::om_asAllPerson_insert()
{
    asAllPerson->insert(this);
}
void Person::om_asAllPerson_update_cell()
{
    // only a single cell if rank 0
    om_asAllPerson_cell = 0;
}
void Person::om_asAvailableMaleByTypeImmiScratch_erase()
{
    int cell = om_asAvailableMaleByTypeImmiScratch_cell;
    EntitySet<Person> ** flattened_array = reinterpret_cast<EntitySet<Person> **>(asAvailableMaleByTypeImmiScratch);
    assert(flattened_array[cell]);
    flattened_array[cell]->erase(this);
}
void Person::om_asAvailableMaleByTypeImmiScratch_filter_update_identity()
{
    #line 32 "../code/FamilyPartnerMatching.mpp"
    om_asAvailableMaleByTypeImmiScratch_filter.set((((((is_alive && (creation_type == CT_SCRATCH)) && (sex == MALE)) && !has_spouse) && WITHIN(MALE_SPOUSE_AGE, integer_age)) && !is_mortal));
}
#line 7379 "C:/Users/Martin/Dropbox/openM++/models/Dynamis-Pop-3-06-ABC/ompp/src/om_definitions.cpp"
void Person::om_asAvailableMaleByTypeImmiScratch_insert()
{
    int cell = om_asAvailableMaleByTypeImmiScratch_cell;
    EntitySet<Person> ** flattened_array = reinterpret_cast<EntitySet<Person> **>(asAvailableMaleByTypeImmiScratch);
    assert(flattened_array[cell]);
    flattened_array[cell]->insert(this);
}
void Person::om_asAvailableMaleByTypeImmiScratch_update_cell()
{
    int cell = 0;
    int index = 0;

    // dimension=0 agentvar=male_age type=MALE_SPOUSE_AGE size=86
    index = male_age;
    // adjust range to zero-based
    index -= 15;
    cell += index;

    // dimension=1 agentvar=spouse_group type=SPOUSE_GROUP size=3
    cell *= 3;
    index = spouse_group;
    cell += index;

    // dimension=2 agentvar=geo type=GEO size=13
    cell *= 13;
    index = geo;
    cell += index;

    // dimension=3 agentvar=year_of_first_immigration type=SIM_YEAR_RANGE size=151
    cell *= 151;
    index = year_of_first_immigration;
    // adjust range to zero-based
    index -= 2000;
    cell += index;

    assert(cell >= 0 && cell < 506454); // logic guarantee

    om_asAvailableMaleByTypeImmiScratch_cell = cell;
}
void Person::om_asAvailableMaleByType_erase()
{
    int cell = om_asAvailableMaleByType_cell;
    EntitySet<Person> ** flattened_array = reinterpret_cast<EntitySet<Person> **>(asAvailableMaleByType);
    assert(flattened_array[cell]);
    flattened_array[cell]->erase(this);
}
void Person::om_asAvailableMaleByType_filter_update_identity()
{
    #line 18 "../code/FamilyPartnerMatching.mpp"
    om_asAvailableMaleByType_filter.set(((((is_alive && (sex == MALE)) && !has_spouse) && WITHIN(MALE_SPOUSE_AGE, integer_age)) && is_mortal));
}
#line 7431 "C:/Users/Martin/Dropbox/openM++/models/Dynamis-Pop-3-06-ABC/ompp/src/om_definitions.cpp"
void Person::om_asAvailableMaleByType_insert()
{
    int cell = om_asAvailableMaleByType_cell;
    EntitySet<Person> ** flattened_array = reinterpret_cast<EntitySet<Person> **>(asAvailableMaleByType);
    assert(flattened_array[cell]);
    flattened_array[cell]->insert(this);
}
void Person::om_asAvailableMaleByType_update_cell()
{
    int cell = 0;
    int index = 0;

    // dimension=0 agentvar=male_age type=MALE_SPOUSE_AGE size=86
    index = male_age;
    // adjust range to zero-based
    index -= 15;
    cell += index;

    // dimension=1 agentvar=spouse_group type=SPOUSE_GROUP size=3
    cell *= 3;
    index = spouse_group;
    cell += index;

    // dimension=2 agentvar=geo type=GEO size=13
    cell *= 13;
    index = geo;
    cell += index;

    assert(cell >= 0 && cell < 3354); // logic guarantee

    om_asAvailableMaleByType_cell = cell;
}
void Person::om_asAvailableMaleImmiScratch_erase()
{
    int cell = om_asAvailableMaleImmiScratch_cell;
    EntitySet<Person> ** flattened_array = reinterpret_cast<EntitySet<Person> **>(asAvailableMaleImmiScratch);
    assert(flattened_array[cell]);
    flattened_array[cell]->erase(this);
}
void Person::om_asAvailableMaleImmiScratch_filter_update_identity()
{
    #line 28 "../code/FamilyPartnerMatching.mpp"
    om_asAvailableMaleImmiScratch_filter.set((((((is_alive && (creation_type == CT_SCRATCH)) && (sex == MALE)) && !has_spouse) && WITHIN(MALE_SPOUSE_AGE, integer_age)) && !is_mortal));
}
#line 7476 "C:/Users/Martin/Dropbox/openM++/models/Dynamis-Pop-3-06-ABC/ompp/src/om_definitions.cpp"
void Person::om_asAvailableMaleImmiScratch_insert()
{
    int cell = om_asAvailableMaleImmiScratch_cell;
    EntitySet<Person> ** flattened_array = reinterpret_cast<EntitySet<Person> **>(asAvailableMaleImmiScratch);
    assert(flattened_array[cell]);
    flattened_array[cell]->insert(this);
}
void Person::om_asAvailableMaleImmiScratch_update_cell()
{
    int cell = 0;
    int index = 0;

    // dimension=0 agentvar=male_age type=MALE_SPOUSE_AGE size=86
    index = male_age;
    // adjust range to zero-based
    index -= 15;
    cell += index;

    // dimension=1 agentvar=geo type=GEO size=13
    cell *= 13;
    index = geo;
    cell += index;

    // dimension=2 agentvar=year_of_first_immigration type=SIM_YEAR_RANGE size=151
    cell *= 151;
    index = year_of_first_immigration;
    // adjust range to zero-based
    index -= 2000;
    cell += index;

    assert(cell >= 0 && cell < 168818); // logic guarantee

    om_asAvailableMaleImmiScratch_cell = cell;
}
void Person::om_asAvailableMale_erase()
{
    int cell = om_asAvailableMale_cell;
    EntitySet<Person> ** flattened_array = reinterpret_cast<EntitySet<Person> **>(asAvailableMale);
    assert(flattened_array[cell]);
    flattened_array[cell]->erase(this);
}
void Person::om_asAvailableMale_filter_update_identity()
{
    #line 14 "../code/FamilyPartnerMatching.mpp"
    om_asAvailableMale_filter.set(((((is_alive && (sex == MALE)) && !has_spouse) && WITHIN(MALE_SPOUSE_AGE, integer_age)) && is_mortal));
}
#line 7523 "C:/Users/Martin/Dropbox/openM++/models/Dynamis-Pop-3-06-ABC/ompp/src/om_definitions.cpp"
void Person::om_asAvailableMale_insert()
{
    int cell = om_asAvailableMale_cell;
    EntitySet<Person> ** flattened_array = reinterpret_cast<EntitySet<Person> **>(asAvailableMale);
    assert(flattened_array[cell]);
    flattened_array[cell]->insert(this);
}
void Person::om_asAvailableMale_update_cell()
{
    int cell = 0;
    int index = 0;

    // dimension=0 agentvar=male_age type=MALE_SPOUSE_AGE size=86
    index = male_age;
    // adjust range to zero-based
    index -= 15;
    cell += index;

    // dimension=1 agentvar=geo type=GEO size=13
    cell *= 13;
    index = geo;
    cell += index;

    assert(cell >= 0 && cell < 1118); // logic guarantee

    om_asAvailableMale_cell = cell;
}
void Person::om_asFemaleInUnionByAgeAndPartnerAgeImmiScratch_erase()
{
    int cell = om_asFemaleInUnionByAgeAndPartnerAgeImmiScratch_cell;
    EntitySet<Person> ** flattened_array = reinterpret_cast<EntitySet<Person> **>(asFemaleInUnionByAgeAndPartnerAgeImmiScratch);
    assert(flattened_array[cell]);
    flattened_array[cell]->erase(this);
}
void Person::om_asFemaleInUnionByAgeAndPartnerAgeImmiScratch_filter_update_identity()
{
    #line 36 "../code/FamilyPartnerMatching.mpp"
    om_asFemaleInUnionByAgeAndPartnerAgeImmiScratch_filter.set((((((is_alive && (creation_type == CT_SCRATCH)) && (sex == FEMALE)) && has_spouse) && WITHIN(FEMALE_SPOUSE_AGE, integer_age)) && !is_mortal));
}
#line 7563 "C:/Users/Martin/Dropbox/openM++/models/Dynamis-Pop-3-06-ABC/ompp/src/om_definitions.cpp"
void Person::om_asFemaleInUnionByAgeAndPartnerAgeImmiScratch_insert()
{
    int cell = om_asFemaleInUnionByAgeAndPartnerAgeImmiScratch_cell;
    EntitySet<Person> ** flattened_array = reinterpret_cast<EntitySet<Person> **>(asFemaleInUnionByAgeAndPartnerAgeImmiScratch);
    assert(flattened_array[cell]);
    flattened_array[cell]->insert(this);
}
void Person::om_asFemaleInUnionByAgeAndPartnerAgeImmiScratch_update_cell()
{
    int cell = 0;
    int index = 0;

    // dimension=0 agentvar=female_spouse_age type=FEMALE_SPOUSE_AGE size=51
    index = female_spouse_age;
    // adjust range to zero-based
    index -= 10;
    cell += index;

    // dimension=1 agentvar=male_spouse_age type=MALE_SPOUSE_AGE size=86
    cell *= 86;
    index = male_spouse_age;
    // adjust range to zero-based
    index -= 15;
    cell += index;

    // dimension=2 agentvar=year_of_first_immigration type=SIM_YEAR_RANGE size=151
    cell *= 151;
    index = year_of_first_immigration;
    // adjust range to zero-based
    index -= 2000;
    cell += index;

    assert(cell >= 0 && cell < 662286); // logic guarantee

    om_asFemaleInUnionByAgeAndPartnerAgeImmiScratch_cell = cell;
}
void Person::om_asFemaleInUnionByAgeAndPartnerAge_erase()
{
    int cell = om_asFemaleInUnionByAgeAndPartnerAge_cell;
    EntitySet<Person> ** flattened_array = reinterpret_cast<EntitySet<Person> **>(asFemaleInUnionByAgeAndPartnerAge);
    assert(flattened_array[cell]);
    flattened_array[cell]->erase(this);
}
void Person::om_asFemaleInUnionByAgeAndPartnerAge_filter_update_identity()
{
    #line 22 "../code/FamilyPartnerMatching.mpp"
    om_asFemaleInUnionByAgeAndPartnerAge_filter.set(((((is_alive && (sex == FEMALE)) && has_spouse) && WITHIN(FEMALE_SPOUSE_AGE, integer_age)) && is_mortal));
}
#line 7612 "C:/Users/Martin/Dropbox/openM++/models/Dynamis-Pop-3-06-ABC/ompp/src/om_definitions.cpp"
void Person::om_asFemaleInUnionByAgeAndPartnerAge_insert()
{
    int cell = om_asFemaleInUnionByAgeAndPartnerAge_cell;
    EntitySet<Person> ** flattened_array = reinterpret_cast<EntitySet<Person> **>(asFemaleInUnionByAgeAndPartnerAge);
    assert(flattened_array[cell]);
    flattened_array[cell]->insert(this);
}
void Person::om_asFemaleInUnionByAgeAndPartnerAge_update_cell()
{
    int cell = 0;
    int index = 0;

    // dimension=0 agentvar=female_spouse_age type=FEMALE_SPOUSE_AGE size=51
    index = female_spouse_age;
    // adjust range to zero-based
    index -= 10;
    cell += index;

    // dimension=1 agentvar=male_spouse_age type=MALE_SPOUSE_AGE size=86
    cell *= 86;
    index = male_spouse_age;
    // adjust range to zero-based
    index -= 15;
    cell += index;

    assert(cell >= 0 && cell < 4386); // logic guarantee

    om_asFemaleInUnionByAgeAndPartnerAge_cell = cell;
}
void Person::om_asPotentialImmigrantMothers_erase()
{
    int cell = om_asPotentialImmigrantMothers_cell;
    EntitySet<Person> ** flattened_array = reinterpret_cast<EntitySet<Person> **>(asPotentialImmigrantMothers);
    assert(flattened_array[cell]);
    flattened_array[cell]->erase(this);
}
void Person::om_asPotentialImmigrantMothers_filter_update_identity()
{
    #line 9 "../code/ImmigrationFromScratch.mpp"
    om_asPotentialImmigrantMothers_filter.set((((((is_alive && (sex == FEMALE)) && (creation_type == CT_SCRATCH)) && !ever_resident) && (family_role != FR_CHILD)) && ever_union));
}
#line 7654 "C:/Users/Martin/Dropbox/openM++/models/Dynamis-Pop-3-06-ABC/ompp/src/om_definitions.cpp"
void Person::om_asPotentialImmigrantMothers_insert()
{
    int cell = om_asPotentialImmigrantMothers_cell;
    EntitySet<Person> ** flattened_array = reinterpret_cast<EntitySet<Person> **>(asPotentialImmigrantMothers);
    assert(flattened_array[cell]);
    flattened_array[cell]->insert(this);
}
void Person::om_asPotentialImmigrantMothers_update_cell()
{
    int cell = 0;
    int index = 0;

    // dimension=0 agentvar=integer_age type=AGE_RANGE size=101
    index = integer_age;
    // adjust range to zero-based
    index -= 0;
    cell += index;

    // dimension=1 agentvar=year_of_first_immigration type=SIM_YEAR_RANGE size=151
    cell *= 151;
    index = year_of_first_immigration;
    // adjust range to zero-based
    index -= 2000;
    cell += index;

    // dimension=2 agentvar=geo type=GEO size=13
    cell *= 13;
    index = geo;
    cell += index;

    assert(cell >= 0 && cell < 198263); // logic guarantee

    om_asPotentialImmigrantMothers_cell = cell;
}
void Person::om_asPotentialSchoolOneStudentToProcess_erase()
{
    asPotentialSchoolOneStudentToProcess->erase(this);
}
void Person::om_asPotentialSchoolOneStudentToProcess_filter_update_identity()
{
    #line 28 "../code/EducationPrimaryTracking.mpp"
    om_asPotentialSchoolOneStudentToProcess_filter.set((is_alive && educ_one_to_process));
}
#line 7698 "C:/Users/Martin/Dropbox/openM++/models/Dynamis-Pop-3-06-ABC/ompp/src/om_definitions.cpp"
void Person::om_asPotentialSchoolOneStudentToProcess_insert()
{
    asPotentialSchoolOneStudentToProcess->insert(this);
}
void Person::om_asPotentialSchoolOneStudentToProcess_update_cell()
{
    // only a single cell if rank 0
    om_asPotentialSchoolOneStudentToProcess_cell = 0;
}
void Person::om_asPotentialSchoolOneStudent_erase()
{
    asPotentialSchoolOneStudent->erase(this);
}
void Person::om_asPotentialSchoolOneStudent_filter_update_identity()
{
    #line 25 "../code/EducationPrimaryTracking.mpp"
    om_asPotentialSchoolOneStudent_filter.set(((is_alive && (educ_one_status != EOS_OUT)) && (educ_one_fate != EOL_LOW)));
}
#line 7717 "C:/Users/Martin/Dropbox/openM++/models/Dynamis-Pop-3-06-ABC/ompp/src/om_definitions.cpp"
void Person::om_asPotentialSchoolOneStudent_insert()
{
    asPotentialSchoolOneStudent->insert(this);
}
void Person::om_asPotentialSchoolOneStudent_update_cell()
{
    // only a single cell if rank 0
    om_asPotentialSchoolOneStudent_cell = 0;
}
void Person::om_asPotentialSchoolTwoStudentToProcess_erase()
{
    asPotentialSchoolTwoStudentToProcess->erase(this);
}
void Person::om_asPotentialSchoolTwoStudentToProcess_filter_update_identity()
{
    #line 29 "../code/EducationSecondaryBase.mpp"
    om_asPotentialSchoolTwoStudentToProcess_filter.set((is_alive && educ_two_to_process));
}
#line 7736 "C:/Users/Martin/Dropbox/openM++/models/Dynamis-Pop-3-06-ABC/ompp/src/om_definitions.cpp"
void Person::om_asPotentialSchoolTwoStudentToProcess_insert()
{
    asPotentialSchoolTwoStudentToProcess->insert(this);
}
void Person::om_asPotentialSchoolTwoStudentToProcess_update_cell()
{
    // only a single cell if rank 0
    om_asPotentialSchoolTwoStudentToProcess_cell = 0;
}
void Person::om_asPotentialSchoolTwoStudent_erase()
{
    asPotentialSchoolTwoStudent->erase(this);
}
void Person::om_asPotentialSchoolTwoStudent_filter_update_identity()
{
    #line 26 "../code/EducationSecondaryBase.mpp"
    om_asPotentialSchoolTwoStudent_filter.set((((educ_one_grade_passed == MAX(EDUC_ONE_GRADE)) && (educ_two_status != ETS_OUT)) && (educ_two_delay <= Educ2AllowedDelays)));
}
#line 7755 "C:/Users/Martin/Dropbox/openM++/models/Dynamis-Pop-3-06-ABC/ompp/src/om_definitions.cpp"
void Person::om_asPotentialSchoolTwoStudent_insert()
{
    asPotentialSchoolTwoStudent->insert(this);
}
void Person::om_asPotentialSchoolTwoStudent_update_cell()
{
    // only a single cell if rank 0
    om_asPotentialSchoolTwoStudent_cell = 0;
}
void Person::om_asResidentBabies_erase()
{
    asResidentBabies->erase(this);
}
void Person::om_asResidentBabies_filter_update_identity()
{
    #line 18 "../code/ChildVaccination.mpp"
    om_asResidentBabies_filter.set((((is_alive && (integer_age == 0)) && is_resident) && (creation_type == CT_BIRTH)));
}
#line 7774 "C:/Users/Martin/Dropbox/openM++/models/Dynamis-Pop-3-06-ABC/ompp/src/om_definitions.cpp"
void Person::om_asResidentBabies_insert()
{
    asResidentBabies->insert(this);
}
void Person::om_asResidentBabies_update_cell()
{
    // only a single cell if rank 0
    om_asResidentBabies_cell = 0;
}
void Person::om_asResidentsAge0SexGeo_erase()
{
    int cell = om_asResidentsAge0SexGeo_cell;
    EntitySet<Person> ** flattened_array = reinterpret_cast<EntitySet<Person> **>(asResidentsAge0SexGeo);
    assert(flattened_array[cell]);
    flattened_array[cell]->erase(this);
}
void Person::om_asResidentsAge0SexGeo_filter_update_identity()
{
    #line 27 "../code/EducationPrimaryBase.mpp"
    om_asResidentsAge0SexGeo_filter.set(((is_alive && is_resident) && (integer_age == 0)));
}
#line 7796 "C:/Users/Martin/Dropbox/openM++/models/Dynamis-Pop-3-06-ABC/ompp/src/om_definitions.cpp"
void Person::om_asResidentsAge0SexGeo_insert()
{
    int cell = om_asResidentsAge0SexGeo_cell;
    EntitySet<Person> ** flattened_array = reinterpret_cast<EntitySet<Person> **>(asResidentsAge0SexGeo);
    assert(flattened_array[cell]);
    flattened_array[cell]->insert(this);
}
void Person::om_asResidentsAge0SexGeo_update_cell()
{
    int cell = 0;
    int index = 0;

    // dimension=0 agentvar=sex type=SEX size=2
    index = sex;
    cell += index;

    // dimension=1 agentvar=geo_birth type=GEO size=13
    cell *= 13;
    index = geo_birth;
    cell += index;

    assert(cell >= 0 && cell < 26); // logic guarantee

    om_asResidentsAge0SexGeo_cell = cell;
}
void Person::om_asResidentsAge0Sex_erase()
{
    int cell = om_asResidentsAge0Sex_cell;
    EntitySet<Person> ** flattened_array = reinterpret_cast<EntitySet<Person> **>(asResidentsAge0Sex);
    assert(flattened_array[cell]);
    flattened_array[cell]->erase(this);
}
void Person::om_asResidentsAge0Sex_filter_update_identity()
{
    #line 30 "../code/EducationPrimaryBase.mpp"
    om_asResidentsAge0Sex_filter.set(((is_alive && (integer_age == 0)) && is_resident));
}
#line 7834 "C:/Users/Martin/Dropbox/openM++/models/Dynamis-Pop-3-06-ABC/ompp/src/om_definitions.cpp"
void Person::om_asResidentsAge0Sex_insert()
{
    int cell = om_asResidentsAge0Sex_cell;
    EntitySet<Person> ** flattened_array = reinterpret_cast<EntitySet<Person> **>(asResidentsAge0Sex);
    assert(flattened_array[cell]);
    flattened_array[cell]->insert(this);
}
void Person::om_asResidentsAge0Sex_update_cell()
{
    int cell = 0;
    int index = 0;

    // dimension=0 agentvar=sex type=SEX size=2
    index = sex;
    cell += index;

    assert(cell >= 0 && cell < 2); // logic guarantee

    om_asResidentsAge0Sex_cell = cell;
}
void Person::om_asSimBornAge0_erase()
{
    int cell = om_asSimBornAge0_cell;
    EntitySet<Person> ** flattened_array = reinterpret_cast<EntitySet<Person> **>(asSimBornAge0);
    assert(flattened_array[cell]);
    flattened_array[cell]->erase(this);
}
void Person::om_asSimBornAge0_filter_update_identity()
{
    #line 35 "../code/EducationPrimaryTransmission.mpp"
    om_asSimBornAge0_filter.set(((is_alive && (creation_type == CT_BIRTH)) && (integer_age == 0)));
}
#line 7867 "C:/Users/Martin/Dropbox/openM++/models/Dynamis-Pop-3-06-ABC/ompp/src/om_definitions.cpp"
void Person::om_asSimBornAge0_insert()
{
    int cell = om_asSimBornAge0_cell;
    EntitySet<Person> ** flattened_array = reinterpret_cast<EntitySet<Person> **>(asSimBornAge0);
    assert(flattened_array[cell]);
    flattened_array[cell]->insert(this);
}
void Person::om_asSimBornAge0_update_cell()
{
    int cell = 0;
    int index = 0;

    // dimension=0 agentvar=sex type=SEX size=2
    index = sex;
    cell += index;

    // dimension=1 agentvar=geo type=GEO size=13
    cell *= 13;
    index = geo;
    cell += index;

    // dimension=2 agentvar=educ1_group type=EDUC1_GROUP size=3
    cell *= 3;
    index = educ1_group;
    cell += index;

    assert(cell >= 0 && cell < 78); // logic guarantee

    om_asSimBornAge0_cell = cell;
}
void Person::om_asWantToMove_erase()
{
    int cell = om_asWantToMove_cell;
    EntitySet<Person> ** flattened_array = reinterpret_cast<EntitySet<Person> **>(asWantToMove);
    assert(flattened_array[cell]);
    flattened_array[cell]->erase(this);
}
void Person::om_asWantToMove_filter_update_identity()
{
    #line 11 "../code/MigrationGeneral.mpp"
    om_asWantToMove_filter.set(is_alive);
}
#line 7910 "C:/Users/Martin/Dropbox/openM++/models/Dynamis-Pop-3-06-ABC/ompp/src/om_definitions.cpp"
void Person::om_asWantToMove_insert()
{
    int cell = om_asWantToMove_cell;
    EntitySet<Person> ** flattened_array = reinterpret_cast<EntitySet<Person> **>(asWantToMove);
    assert(flattened_array[cell]);
    flattened_array[cell]->insert(this);
}
void Person::om_asWantToMove_update_cell()
{
    int cell = 0;
    int index = 0;

    // dimension=0 agentvar=geo type=GEO size=13
    index = geo;
    cell += index;

    // dimension=1 agentvar=geo_want_to_move type=GEO size=13
    cell *= 13;
    index = geo_want_to_move;
    cell += index;

    // dimension=2 agentvar=sex type=SEX size=2
    cell *= 2;
    index = sex;
    cell += index;

    // dimension=3 agentvar=age_mig type=AGE_MIG size=13
    cell *= 13;
    index = age_mig;
    // adjust range to zero-based
    index -= 0;
    cell += index;

    assert(cell >= 0 && cell < 4394); // logic guarantee

    om_asWantToMove_cell = cell;
}
void Person::om_asWomenNoChildren_erase()
{
    int cell = om_asWomenNoChildren_cell;
    EntitySet<Person> ** flattened_array = reinterpret_cast<EntitySet<Person> **>(asWomenNoChildren);
    assert(flattened_array[cell]);
    flattened_array[cell]->erase(this);
}
void Person::om_asWomenNoChildren_filter_update_identity()
{
    #line 27 "../code/FamilyFemalePartnershipStatus.mpp"
    om_asWomenNoChildren_filter.set((((((is_alive && (sex == FEMALE)) && WITHIN(FEMALE_SPOUSE_AGE, integer_age)) && !lives_with_dependent_child) && is_mortal) && !is_blocked_from_marriage));
}
#line 7960 "C:/Users/Martin/Dropbox/openM++/models/Dynamis-Pop-3-06-ABC/ompp/src/om_definitions.cpp"
void Person::om_asWomenNoChildren_insert()
{
    int cell = om_asWomenNoChildren_cell;
    EntitySet<Person> ** flattened_array = reinterpret_cast<EntitySet<Person> **>(asWomenNoChildren);
    assert(flattened_array[cell]);
    flattened_array[cell]->insert(this);
}
void Person::om_asWomenNoChildren_update_cell()
{
    int cell = 0;
    int index = 0;

    // dimension=0 agentvar=union1_group type=UNION1_GROUP size=3
    index = union1_group;
    cell += index;

    // dimension=1 agentvar=female_spouse_age type=FEMALE_SPOUSE_AGE size=51
    cell *= 51;
    index = female_spouse_age;
    // adjust range to zero-based
    index -= 10;
    cell += index;

    // dimension=2 agentvar=has_spouse type=bool size=2
    cell *= 2;
    index = has_spouse;
    cell += index;

    assert(cell >= 0 && cell < 306); // logic guarantee

    om_asWomenNoChildren_cell = cell;
}
void Person::om_asWomenWithChildren_erase()
{
    int cell = om_asWomenWithChildren_cell;
    EntitySet<Person> ** flattened_array = reinterpret_cast<EntitySet<Person> **>(asWomenWithChildren);
    assert(flattened_array[cell]);
    flattened_array[cell]->erase(this);
}
void Person::om_asWomenWithChildren_filter_update_identity()
{
    #line 22 "../code/FamilyFemalePartnershipStatus.mpp"
    om_asWomenWithChildren_filter.set((((((is_alive && (sex == FEMALE)) && WITHIN(FEMALE_SPOUSE_AGE, integer_age)) && lives_with_dependent_child) && is_mortal) && !is_blocked_from_marriage));
}
#line 8005 "C:/Users/Martin/Dropbox/openM++/models/Dynamis-Pop-3-06-ABC/ompp/src/om_definitions.cpp"
void Person::om_asWomenWithChildren_insert()
{
    int cell = om_asWomenWithChildren_cell;
    EntitySet<Person> ** flattened_array = reinterpret_cast<EntitySet<Person> **>(asWomenWithChildren);
    assert(flattened_array[cell]);
    flattened_array[cell]->insert(this);
}
void Person::om_asWomenWithChildren_update_cell()
{
    int cell = 0;
    int index = 0;

    // dimension=0 agentvar=union1_group type=UNION1_GROUP size=3
    index = union1_group;
    cell += index;

    // dimension=1 agentvar=child_agegr type=CHILD_AGEGR size=7
    cell *= 7;
    index = child_agegr;
    cell += index;

    // dimension=2 agentvar=moth_agegr type=MOTH_AGEGR size=6
    cell *= 6;
    index = moth_agegr;
    cell += index;

    // dimension=3 agentvar=has_spouse type=bool size=2
    cell *= 2;
    index = has_spouse;
    cell += index;

    assert(cell >= 0 && cell < 252); // logic guarantee

    om_asWomenWithChildren_cell = cell;
}
void Person::om_assign_member_offsets()
{
    adult_survival.offset_in_agent = (char *)&(this->adult_survival) - (char *)this;
    age.offset_in_agent = (char *)&(this->age) - (char *)this;
    age_last_birth.offset_in_agent = (char *)&(this->age_last_birth) - (char *)this;
    age_mig.offset_in_agent = (char *)&(this->age_mig) - (char *)this;
    age_youngest_child.offset_in_agent = (char *)&(this->age_youngest_child) - (char *)this;
    all_year.offset_in_agent = (char *)&(this->all_year) - (char *)this;
    calendar_year.offset_in_agent = (char *)&(this->calendar_year) - (char *)this;
    case_seed.offset_in_agent = (char *)&(this->case_seed) - (char *)this;
    child_agegr.offset_in_agent = (char *)&(this->child_agegr) - (char *)this;
    child_agegr_part.offset_in_agent = (char *)&(this->child_agegr_part) - (char *)this;
    child_mortality.offset_in_agent = (char *)&(this->child_mortality) - (char *)this;
    child_mortality_group.offset_in_agent = (char *)&(this->child_mortality_group) - (char *)this;
    children_in_household.offset_in_agent = (char *)&(this->children_in_household) - (char *)this;
    creation_type.offset_in_agent = (char *)&(this->creation_type) - (char *)this;
    educ1_group.offset_in_agent = (char *)&(this->educ1_group) - (char *)this;
    educ_mother.offset_in_agent = (char *)&(this->educ_mother) - (char *)this;
    educ_one_entry_age.offset_in_agent = (char *)&(this->educ_one_entry_age) - (char *)this;
    educ_one_fate.offset_in_agent = (char *)&(this->educ_one_fate) - (char *)this;
    educ_one_geo.offset_in_agent = (char *)&(this->educ_one_geo) - (char *)this;
    educ_one_grade.offset_in_agent = (char *)&(this->educ_one_grade) - (char *)this;
    educ_one_grade_attended.offset_in_agent = (char *)&(this->educ_one_grade_attended) - (char *)this;
    educ_one_grade_fate.offset_in_agent = (char *)&(this->educ_one_grade_fate) - (char *)this;
    educ_one_grade_passed.offset_in_agent = (char *)&(this->educ_one_grade_passed) - (char *)this;
    educ_one_group.offset_in_agent = (char *)&(this->educ_one_group) - (char *)this;
    educ_one_level.offset_in_agent = (char *)&(this->educ_one_level) - (char *)this;
    educ_one_required_rooms.offset_in_agent = (char *)&(this->educ_one_required_rooms) - (char *)this;
    educ_one_required_teachers.offset_in_agent = (char *)&(this->educ_one_required_teachers) - (char *)this;
    educ_one_status.offset_in_agent = (char *)&(this->educ_one_status) - (char *)this;
    educ_one_to_process.offset_in_agent = (char *)&(this->educ_one_to_process) - (char *)this;
    educ_two_delay.offset_in_agent = (char *)&(this->educ_two_delay) - (char *)this;
    educ_two_geo.offset_in_agent = (char *)&(this->educ_two_geo) - (char *)this;
    educ_two_grade_attended.offset_in_agent = (char *)&(this->educ_two_grade_attended) - (char *)this;
    educ_two_grade_passed.offset_in_agent = (char *)&(this->educ_two_grade_passed) - (char *)this;
    educ_two_group.offset_in_agent = (char *)&(this->educ_two_group) - (char *)this;
    educ_two_level.offset_in_agent = (char *)&(this->educ_two_level) - (char *)this;
    educ_two_status.offset_in_agent = (char *)&(this->educ_two_status) - (char *)this;
    educ_two_to_process.offset_in_agent = (char *)&(this->educ_two_to_process) - (char *)this;
    entity_id.offset_in_agent = (char *)&(this->entity_id) - (char *)this;
    ethnicity.offset_in_agent = (char *)&(this->ethnicity) - (char *)this;
    ethnicity_short.offset_in_agent = (char *)&(this->ethnicity_short) - (char *)this;
    events.offset_in_agent = (char *)&(this->events) - (char *)this;
    ever_resident.offset_in_agent = (char *)&(this->ever_resident) - (char *)this;
    ever_union.offset_in_agent = (char *)&(this->ever_union) - (char *)this;
    family_role.offset_in_agent = (char *)&(this->family_role) - (char *)this;
    female_spouse_age.offset_in_agent = (char *)&(this->female_spouse_age) - (char *)this;
    fertile_age.offset_in_agent = (char *)&(this->fertile_age) - (char *)this;
    first_move_done.offset_in_agent = (char *)&(this->first_move_done) - (char *)this;
    geo.offset_in_agent = (char *)&(this->geo) - (char *)this;
    geo_birth.offset_in_agent = (char *)&(this->geo_birth) - (char *)this;
    geo_nat.offset_in_agent = (char *)&(this->geo_nat) - (char *)this;
    geo_prev.offset_in_agent = (char *)&(this->geo_prev) - (char *)this;
    geo_want_to_move.offset_in_agent = (char *)&(this->geo_want_to_move) - (char *)this;
    got_prenat_care.offset_in_agent = (char *)&(this->got_prenat_care) - (char *)this;
    has_passed_primary.offset_in_agent = (char *)&(this->has_passed_primary) - (char *)this;
    has_spouse.offset_in_agent = (char *)&(this->has_spouse) - (char *)this;
    in_hci_sample.offset_in_agent = (char *)&(this->in_hci_sample) - (char *)this;
    in_projected_time.offset_in_agent = (char *)&(this->in_projected_time) - (char *)this;
    in_sel_years.offset_in_agent = (char *)&(this->in_sel_years) - (char *)this;
    in_selected_year.offset_in_agent = (char *)&(this->in_selected_year) - (char *)this;
    ind_hci.offset_in_agent = (char *)&(this->ind_hci) - (char *)this;
    integer_age.offset_in_agent = (char *)&(this->integer_age) - (char *)this;
    is_aded0.offset_in_agent = (char *)&(this->is_aded0) - (char *)this;
    is_aded1.offset_in_agent = (char *)&(this->is_aded1) - (char *)this;
    is_aded2.offset_in_agent = (char *)&(this->is_aded2) - (char *)this;
    is_adult.offset_in_agent = (char *)&(this->is_adult) - (char *)this;
    is_alive.offset_in_agent = (char *)&(this->is_alive) - (char *)this;
    is_blocked_from_marriage.offset_in_agent = (char *)&(this->is_blocked_from_marriage) - (char *)this;
    is_child.offset_in_agent = (char *)&(this->is_child) - (char *)this;
    is_educ_one_student.offset_in_agent = (char *)&(this->is_educ_one_student) - (char *)this;
    is_fertile.offset_in_agent = (char *)&(this->is_fertile) - (char *)this;
    is_immunized.offset_in_agent = (char *)&(this->is_immunized) - (char *)this;
    is_mortal.offset_in_agent = (char *)&(this->is_mortal) - (char *)this;
    is_old.offset_in_agent = (char *)&(this->is_old) - (char *)this;
    is_ready_for_birthtables.offset_in_agent = (char *)&(this->is_ready_for_birthtables) - (char *)this;
    is_resident.offset_in_agent = (char *)&(this->is_resident) - (char *)this;
    is_stunted.offset_in_agent = (char *)&(this->is_stunted) - (char *)this;
    lBioFather.offset_in_agent = (char *)&(this->lBioFather) - (char *)this;
    lBioMother.offset_in_agent = (char *)&(this->lBioMother) - (char *)this;
    lCalibrator.offset_in_agent = (char *)&(this->lCalibrator) - (char *)this;
    lHHFather.offset_in_agent = (char *)&(this->lHHFather) - (char *)this;
    lHHMother.offset_in_agent = (char *)&(this->lHHMother) - (char *)this;
    lSpouse.offset_in_agent = (char *)&(this->lSpouse) - (char *)this;
    lStartValues.offset_in_agent = (char *)&(this->lStartValues) - (char *)this;
    lives_with_dependent_child.offset_in_agent = (char *)&(this->lives_with_dependent_child) - (char *)this;
    male_age.offset_in_agent = (char *)&(this->male_age) - (char *)this;
    male_spouse_age.offset_in_agent = (char *)&(this->male_spouse_age) - (char *)this;
    mlBioFatherChildren.offset_in_agent = (char *)&(this->mlBioFatherChildren) - (char *)this;
    mlBioMotherChildren.offset_in_agent = (char *)&(this->mlBioMotherChildren) - (char *)this;
    mlHHFatherChildren.offset_in_agent = (char *)&(this->mlHHFatherChildren) - (char *)this;
    mlHHMotherChildren.offset_in_agent = (char *)&(this->mlHHMotherChildren) - (char *)this;
    moth_agegr.offset_in_agent = (char *)&(this->moth_agegr) - (char *)this;
    moth_agegr_part.offset_in_agent = (char *)&(this->moth_agegr_part) - (char *)this;
    mother_age_at_birth.offset_in_agent = (char *)&(this->mother_age_at_birth) - (char *)this;
    om_BackMigrationEvent_om_event.offset_in_agent = (char *)&(this->om_BackMigrationEvent_om_event) - (char *)this;
    om_BirthdayEvent_om_event.offset_in_agent = (char *)&(this->om_BirthdayEvent_om_event) - (char *)this;
    om_DeathAtMaxLifespanEvent_om_event.offset_in_agent = (char *)&(this->om_DeathAtMaxLifespanEvent_om_event) - (char *)this;
    om_EmigrationEvent_om_event.offset_in_agent = (char *)&(this->om_EmigrationEvent_om_event) - (char *)this;
    om_FertilityBaseEvent_om_event.offset_in_agent = (char *)&(this->om_FertilityBaseEvent_om_event) - (char *)this;
    om_FertilityDetailedEvent_om_event.offset_in_agent = (char *)&(this->om_FertilityDetailedEvent_om_event) - (char *)this;
    om_FirstImmigrationFromPoolEvent_om_event.offset_in_agent = (char *)&(this->om_FirstImmigrationFromPoolEvent_om_event) - (char *)this;
    om_FirstImmigrationFromScratchEvent_om_event.offset_in_agent = (char *)&(this->om_FirstImmigrationFromScratchEvent_om_event) - (char *)this;
    om_FirstUnionFormationEvent_om_event.offset_in_agent = (char *)&(this->om_FirstUnionFormationEvent_om_event) - (char *)this;
    om_LeavingHomeEvent_om_event.offset_in_agent = (char *)&(this->om_LeavingHomeEvent_om_event) - (char *)this;
    om_MigrationEvent_om_event.offset_in_agent = (char *)&(this->om_MigrationEvent_om_event) - (char *)this;
    om_MortalityBaseEvent_om_event.offset_in_agent = (char *)&(this->om_MortalityBaseEvent_om_event) - (char *)this;
    om_MortalityDetailedEvent_om_event.offset_in_agent = (char *)&(this->om_MortalityDetailedEvent_om_event) - (char *)this;
    om_PopPyramidByEduc_incr.offset_in_agent = (char *)&(this->om_PopPyramidByEduc_incr) - (char *)this;
    om_SetAliveEvent_om_event.offset_in_agent = (char *)&(this->om_SetAliveEvent_om_event) - (char *)this;
    om_SetPreschoolYearsEvent_om_event.offset_in_agent = (char *)&(this->om_SetPreschoolYearsEvent_om_event) - (char *)this;
    om_TabChildVaccination_incr.offset_in_agent = (char *)&(this->om_TabChildVaccination_incr) - (char *)this;
    om_TabEduc15ByDistrictBirth_incr.offset_in_agent = (char *)&(this->om_TabEduc15ByDistrictBirth_incr) - (char *)this;
    om_TabEduc15ByDistrict_incr.offset_in_agent = (char *)&(this->om_TabEduc15ByDistrict_incr) - (char *)this;
    om_TabEducFateByGroup_incr.offset_in_agent = (char *)&(this->om_TabEducFateByGroup_incr) - (char *)this;
    om_TabEducFateDistrYob_incr.offset_in_agent = (char *)&(this->om_TabEducFateDistrYob_incr) - (char *)this;
    om_TabHCIDistrict_incr.offset_in_agent = (char *)&(this->om_TabHCIDistrict_incr) - (char *)this;
    om_TabImmunizationChildren_incr.offset_in_agent = (char *)&(this->om_TabImmunizationChildren_incr) - (char *)this;
    om_TabPopProvAgeEducSex_incr.offset_in_agent = (char *)&(this->om_TabPopProvAgeEducSex_incr) - (char *)this;
    om_TabPrenatCare_incr.offset_in_agent = (char *)&(this->om_TabPrenatCare_incr) - (char *)this;
    om_TabPrimSchoolEntries_incr.offset_in_agent = (char *)&(this->om_TabPrimSchoolEntries_incr) - (char *)this;
    om_TabPrimSchoolGraduations_incr.offset_in_agent = (char *)&(this->om_TabPrimSchoolGraduations_incr) - (char *)this;
    om_TabPrimSchoolOutOfSchool9to11_incr.offset_in_agent = (char *)&(this->om_TabPrimSchoolOutOfSchool9to11_incr) - (char *)this;
    om_TabPrimarySchoolPlanning_incr.offset_in_agent = (char *)&(this->om_TabPrimarySchoolPlanning_incr) - (char *)this;
    om_TabSchool2AttainmentsTab_incr.offset_in_agent = (char *)&(this->om_TabSchool2AttainmentsTab_incr) - (char *)this;
    om_TabSchool2TrackTab_incr.offset_in_agent = (char *)&(this->om_TabSchool2TrackTab_incr) - (char *)this;
    om_active_spell_duration_FOR_this_parity_spell_X_true.offset_in_agent = (char *)&(this->om_active_spell_duration_FOR_this_parity_spell_X_true) - (char *)this;
    om_aggregate_FOR_ethnicity_X_ETHNICITY_SHORT.offset_in_agent = (char *)&(this->om_aggregate_FOR_ethnicity_X_ETHNICITY_SHORT) - (char *)this;
    om_aggregate_FOR_geo_X_GEO_NAT.offset_in_agent = (char *)&(this->om_aggregate_FOR_geo_X_GEO_NAT) - (char *)this;
    om_aggregate_FOR_geo_X_REGION_INT.offset_in_agent = (char *)&(this->om_aggregate_FOR_geo_X_REGION_INT) - (char *)this;
    om_aggregate_FOR_geo_birth_X_GEO_NAT.offset_in_agent = (char *)&(this->om_aggregate_FOR_geo_birth_X_GEO_NAT) - (char *)this;
    om_aggregate_FOR_geo_birth_X_REGION_INT.offset_in_agent = (char *)&(this->om_aggregate_FOR_geo_birth_X_REGION_INT) - (char *)this;
    om_aggregate_FOR_region_birth_X_REGION_NAT.offset_in_agent = (char *)&(this->om_aggregate_FOR_region_birth_X_REGION_NAT) - (char *)this;
    om_aggregate_FOR_region_int_X_REGION_NAT.offset_in_agent = (char *)&(this->om_aggregate_FOR_region_int_X_REGION_NAT) - (char *)this;
    om_aia_0.offset_in_agent = (char *)&(this->om_aia_0) - (char *)this;
    om_aia_1.offset_in_agent = (char *)&(this->om_aia_1) - (char *)this;
    om_aia_10.offset_in_agent = (char *)&(this->om_aia_10) - (char *)this;
    om_aia_11.offset_in_agent = (char *)&(this->om_aia_11) - (char *)this;
    om_aia_12.offset_in_agent = (char *)&(this->om_aia_12) - (char *)this;
    om_aia_13.offset_in_agent = (char *)&(this->om_aia_13) - (char *)this;
    om_aia_14.offset_in_agent = (char *)&(this->om_aia_14) - (char *)this;
    om_aia_15.offset_in_agent = (char *)&(this->om_aia_15) - (char *)this;
    om_aia_16.offset_in_agent = (char *)&(this->om_aia_16) - (char *)this;
    om_aia_17.offset_in_agent = (char *)&(this->om_aia_17) - (char *)this;
    om_aia_18.offset_in_agent = (char *)&(this->om_aia_18) - (char *)this;
    om_aia_19.offset_in_agent = (char *)&(this->om_aia_19) - (char *)this;
    om_aia_2.offset_in_agent = (char *)&(this->om_aia_2) - (char *)this;
    om_aia_20.offset_in_agent = (char *)&(this->om_aia_20) - (char *)this;
    om_aia_21.offset_in_agent = (char *)&(this->om_aia_21) - (char *)this;
    om_aia_22.offset_in_agent = (char *)&(this->om_aia_22) - (char *)this;
    om_aia_23.offset_in_agent = (char *)&(this->om_aia_23) - (char *)this;
    om_aia_24.offset_in_agent = (char *)&(this->om_aia_24) - (char *)this;
    om_aia_25.offset_in_agent = (char *)&(this->om_aia_25) - (char *)this;
    om_aia_26.offset_in_agent = (char *)&(this->om_aia_26) - (char *)this;
    om_aia_27.offset_in_agent = (char *)&(this->om_aia_27) - (char *)this;
    om_aia_28.offset_in_agent = (char *)&(this->om_aia_28) - (char *)this;
    om_aia_29.offset_in_agent = (char *)&(this->om_aia_29) - (char *)this;
    om_aia_3.offset_in_agent = (char *)&(this->om_aia_3) - (char *)this;
    om_aia_30.offset_in_agent = (char *)&(this->om_aia_30) - (char *)this;
    om_aia_31.offset_in_agent = (char *)&(this->om_aia_31) - (char *)this;
    om_aia_32.offset_in_agent = (char *)&(this->om_aia_32) - (char *)this;
    om_aia_33.offset_in_agent = (char *)&(this->om_aia_33) - (char *)this;
    om_aia_34.offset_in_agent = (char *)&(this->om_aia_34) - (char *)this;
    om_aia_35.offset_in_agent = (char *)&(this->om_aia_35) - (char *)this;
    om_aia_36.offset_in_agent = (char *)&(this->om_aia_36) - (char *)this;
    om_aia_37.offset_in_agent = (char *)&(this->om_aia_37) - (char *)this;
    om_aia_38.offset_in_agent = (char *)&(this->om_aia_38) - (char *)this;
    om_aia_39.offset_in_agent = (char *)&(this->om_aia_39) - (char *)this;
    om_aia_4.offset_in_agent = (char *)&(this->om_aia_4) - (char *)this;
    om_aia_40.offset_in_agent = (char *)&(this->om_aia_40) - (char *)this;
    om_aia_5.offset_in_agent = (char *)&(this->om_aia_5) - (char *)this;
    om_aia_6.offset_in_agent = (char *)&(this->om_aia_6) - (char *)this;
    om_aia_7.offset_in_agent = (char *)&(this->om_aia_7) - (char *)this;
    om_aia_8.offset_in_agent = (char *)&(this->om_aia_8) - (char *)this;
    om_aia_9.offset_in_agent = (char *)&(this->om_aia_9) - (char *)this;
    om_asAllFertilePersonsForFertilityAlignmentByAge_filter.offset_in_agent = (char *)&(this->om_asAllFertilePersonsForFertilityAlignmentByAge_filter) - (char *)this;
    om_asAllFertilePersonsForFertilityAlignment_filter.offset_in_agent = (char *)&(this->om_asAllFertilePersonsForFertilityAlignment_filter) - (char *)this;
    om_asAllPerson_filter.offset_in_agent = (char *)&(this->om_asAllPerson_filter) - (char *)this;
    om_asAvailableMaleByTypeImmiScratch_filter.offset_in_agent = (char *)&(this->om_asAvailableMaleByTypeImmiScratch_filter) - (char *)this;
    om_asAvailableMaleByType_filter.offset_in_agent = (char *)&(this->om_asAvailableMaleByType_filter) - (char *)this;
    om_asAvailableMaleImmiScratch_filter.offset_in_agent = (char *)&(this->om_asAvailableMaleImmiScratch_filter) - (char *)this;
    om_asAvailableMale_filter.offset_in_agent = (char *)&(this->om_asAvailableMale_filter) - (char *)this;
    om_asFemaleInUnionByAgeAndPartnerAgeImmiScratch_filter.offset_in_agent = (char *)&(this->om_asFemaleInUnionByAgeAndPartnerAgeImmiScratch_filter) - (char *)this;
    om_asFemaleInUnionByAgeAndPartnerAge_filter.offset_in_agent = (char *)&(this->om_asFemaleInUnionByAgeAndPartnerAge_filter) - (char *)this;
    om_asPotentialImmigrantMothers_filter.offset_in_agent = (char *)&(this->om_asPotentialImmigrantMothers_filter) - (char *)this;
    om_asPotentialSchoolOneStudentToProcess_filter.offset_in_agent = (char *)&(this->om_asPotentialSchoolOneStudentToProcess_filter) - (char *)this;
    om_asPotentialSchoolOneStudent_filter.offset_in_agent = (char *)&(this->om_asPotentialSchoolOneStudent_filter) - (char *)this;
    om_asPotentialSchoolTwoStudentToProcess_filter.offset_in_agent = (char *)&(this->om_asPotentialSchoolTwoStudentToProcess_filter) - (char *)this;
    om_asPotentialSchoolTwoStudent_filter.offset_in_agent = (char *)&(this->om_asPotentialSchoolTwoStudent_filter) - (char *)this;
    om_asResidentBabies_filter.offset_in_agent = (char *)&(this->om_asResidentBabies_filter) - (char *)this;
    om_asResidentsAge0SexGeo_filter.offset_in_agent = (char *)&(this->om_asResidentsAge0SexGeo_filter) - (char *)this;
    om_asResidentsAge0Sex_filter.offset_in_agent = (char *)&(this->om_asResidentsAge0Sex_filter) - (char *)this;
    om_asSimBornAge0_filter.offset_in_agent = (char *)&(this->om_asSimBornAge0_filter) - (char *)this;
    om_asWantToMove_filter.offset_in_agent = (char *)&(this->om_asWantToMove_filter) - (char *)this;
    om_asWomenNoChildren_filter.offset_in_agent = (char *)&(this->om_asWomenNoChildren_filter) - (char *)this;
    om_asWomenWithChildren_filter.offset_in_agent = (char *)&(this->om_asWomenWithChildren_filter) - (char *)this;
    om_duration.offset_in_agent = (char *)&(this->om_duration) - (char *)this;
    om_duration_FOR_educ_one_fate_X_EOL_HIGH.offset_in_agent = (char *)&(this->om_duration_FOR_educ_one_fate_X_EOL_HIGH) - (char *)this;
    om_duration_FOR_educ_one_fate_X_EOL_LOW.offset_in_agent = (char *)&(this->om_duration_FOR_educ_one_fate_X_EOL_LOW) - (char *)this;
    om_duration_FOR_educ_one_fate_X_EOL_MEDIUM.offset_in_agent = (char *)&(this->om_duration_FOR_educ_one_fate_X_EOL_MEDIUM) - (char *)this;
    om_duration_FOR_educ_one_level_X_EOL_HIGH.offset_in_agent = (char *)&(this->om_duration_FOR_educ_one_level_X_EOL_HIGH) - (char *)this;
    om_duration_FOR_educ_one_level_X_EOL_LOW.offset_in_agent = (char *)&(this->om_duration_FOR_educ_one_level_X_EOL_LOW) - (char *)this;
    om_duration_FOR_educ_one_level_X_EOL_MEDIUM.offset_in_agent = (char *)&(this->om_duration_FOR_educ_one_level_X_EOL_MEDIUM) - (char *)this;
    om_duration_FOR_educ_two_level_X_ETL_GRADUATE.offset_in_agent = (char *)&(this->om_duration_FOR_educ_two_level_X_ETL_GRADUATE) - (char *)this;
    om_duration_FOR_educ_two_level_X_ETL_INCOMPLETE.offset_in_agent = (char *)&(this->om_duration_FOR_educ_two_level_X_ETL_INCOMPLETE) - (char *)this;
    om_duration_FOR_educ_two_level_X_ETL_NEVER.offset_in_agent = (char *)&(this->om_duration_FOR_educ_two_level_X_ETL_NEVER) - (char *)this;
    om_duration_FOR_ever_union_X_true.offset_in_agent = (char *)&(this->om_duration_FOR_ever_union_X_true) - (char *)this;
    om_duration_FOR_got_prenat_care_X_GPC_YES.offset_in_agent = (char *)&(this->om_duration_FOR_got_prenat_care_X_GPC_YES) - (char *)this;
    om_duration_FOR_has_spouse_X_true.offset_in_agent = (char *)&(this->om_duration_FOR_has_spouse_X_true) - (char *)this;
    om_duration_FOR_is_aded0_X_true.offset_in_agent = (char *)&(this->om_duration_FOR_is_aded0_X_true) - (char *)this;
    om_duration_FOR_is_aded1_X_true.offset_in_agent = (char *)&(this->om_duration_FOR_is_aded1_X_true) - (char *)this;
    om_duration_FOR_is_aded2_X_true.offset_in_agent = (char *)&(this->om_duration_FOR_is_aded2_X_true) - (char *)this;
    om_duration_FOR_is_child_X_true.offset_in_agent = (char *)&(this->om_duration_FOR_is_child_X_true) - (char *)this;
    om_duration_FOR_is_immunized_X_true.offset_in_agent = (char *)&(this->om_duration_FOR_is_immunized_X_true) - (char *)this;
    om_duration_FOR_is_old_X_true.offset_in_agent = (char *)&(this->om_duration_FOR_is_old_X_true) - (char *)this;
    om_duration_FOR_tab_out_of_primary_X_true.offset_in_agent = (char *)&(this->om_duration_FOR_tab_out_of_primary_X_true) - (char *)this;
    om_duration_FOR_years_preschool_X_0.offset_in_agent = (char *)&(this->om_duration_FOR_years_preschool_X_0) - (char *)this;
    om_duration_FOR_years_preschool_X_1.offset_in_agent = (char *)&(this->om_duration_FOR_years_preschool_X_1) - (char *)this;
    om_duration_FOR_years_preschool_X_2.offset_in_agent = (char *)&(this->om_duration_FOR_years_preschool_X_2) - (char *)this;
    om_entrances_FOR_educ_one_grade_attended_X_1.offset_in_agent = (char *)&(this->om_entrances_FOR_educ_one_grade_attended_X_1) - (char *)this;
    om_entrances_FOR_has_passed_primary_X_true.offset_in_agent = (char *)&(this->om_entrances_FOR_has_passed_primary_X_true) - (char *)this;
    om_mlHHFatherChildren_count.offset_in_agent = (char *)&(this->om_mlHHFatherChildren_count) - (char *)this;
    om_mlHHFatherChildren_sum_over_is_alive.offset_in_agent = (char *)&(this->om_mlHHFatherChildren_sum_over_is_alive) - (char *)this;
    om_mlHHMotherChildren_count.offset_in_agent = (char *)&(this->om_mlHHMotherChildren_count) - (char *)this;
    om_mlHHMotherChildren_min_over_integer_age.offset_in_agent = (char *)&(this->om_mlHHMotherChildren_min_over_integer_age) - (char *)this;
    om_mlHHMotherChildren_sum_over_is_alive.offset_in_agent = (char *)&(this->om_mlHHMotherChildren_sum_over_is_alive) - (char *)this;
    om_self_scheduling_split_FOR_age_X_AGE_MIG_PART.offset_in_agent = (char *)&(this->om_self_scheduling_split_FOR_age_X_AGE_MIG_PART) - (char *)this;
    om_self_scheduling_split_FOR_om_active_spell_duration_FOR_this_parity_spell_X_true_X_DUR_TIME_IN_PARITY.offset_in_agent = (char *)&(this->om_self_scheduling_split_FOR_om_active_spell_duration_FOR_this_parity_spell_X_true_X_DUR_TIME_IN_PARITY) - (char *)this;
    om_split_FOR_age_last_birth_X_MOTH_AGEGR_PART.offset_in_agent = (char *)&(this->om_split_FOR_age_last_birth_X_MOTH_AGEGR_PART) - (char *)this;
    om_split_FOR_age_youngest_child_X_CHILD_AGEGR_PART.offset_in_agent = (char *)&(this->om_split_FOR_age_youngest_child_X_CHILD_AGEGR_PART) - (char *)this;
    om_split_FOR_integer_age_X_TAB_AGEC5.offset_in_agent = (char *)&(this->om_split_FOR_integer_age_X_TAB_AGEC5) - (char *)this;
    om_tabBirthsYearPlace_incr.offset_in_agent = (char *)&(this->om_tabBirthsYearPlace_incr) - (char *)this;
    om_tabEducationFateGeobirYob_incr.offset_in_agent = (char *)&(this->om_tabEducationFateGeobirYob_incr) - (char *)this;
    om_tabHCI_incr.offset_in_agent = (char *)&(this->om_tabHCI_incr) - (char *)this;
    om_tabHavingSpouse_incr.offset_in_agent = (char *)&(this->om_tabHavingSpouse_incr) - (char *)this;
    om_tabMigrationOriginDestination_incr.offset_in_agent = (char *)&(this->om_tabMigrationOriginDestination_incr) - (char *)this;
    om_tabPopulationYearPlace_incr.offset_in_agent = (char *)&(this->om_tabPopulationYearPlace_incr) - (char *)this;
    om_tabPreSchool_incr.offset_in_agent = (char *)&(this->om_tabPreSchool_incr) - (char *)this;
    om_tabStuntingSexRegMotherYob_incr.offset_in_agent = (char *)&(this->om_tabStuntingSexRegMotherYob_incr) - (char *)this;
    om_tabStuntingSexRegYob_incr.offset_in_agent = (char *)&(this->om_tabStuntingSexRegYob_incr) - (char *)this;
    om_transitions_FOR_integer_age_X_14_X_15.offset_in_agent = (char *)&(this->om_transitions_FOR_integer_age_X_14_X_15) - (char *)this;
    om_transitions_FOR_is_alive_X_false_X_true.offset_in_agent = (char *)&(this->om_transitions_FOR_is_alive_X_false_X_true) - (char *)this;
    om_transitions_FOR_is_alive_X_true_X_false.offset_in_agent = (char *)&(this->om_transitions_FOR_is_alive_X_true_X_false) - (char *)this;
    om_transitions_FOR_survived_early_years_X_false_X_true.offset_in_agent = (char *)&(this->om_transitions_FOR_survived_early_years_X_false_X_true) - (char *)this;
    om_trigger_changes_FOR_calendar_year.offset_in_agent = (char *)&(this->om_trigger_changes_FOR_calendar_year) - (char *)this;
    om_trigger_changes_FOR_geo.offset_in_agent = (char *)&(this->om_trigger_changes_FOR_geo) - (char *)this;
    om_trigger_entrances_FOR_is_ready_for_birthtables_X_true.offset_in_agent = (char *)&(this->om_trigger_entrances_FOR_is_ready_for_birthtables_X_true) - (char *)this;
    om_value_at_transitions_FOR_is_alive_X_true_X_adult_survival_X_false.offset_in_agent = (char *)&(this->om_value_at_transitions_FOR_is_alive_X_true_X_adult_survival_X_false) - (char *)this;
    om_value_at_transitions_FOR_is_alive_X_true_X_ind_hci_X_false.offset_in_agent = (char *)&(this->om_value_at_transitions_FOR_is_alive_X_true_X_ind_hci_X_false) - (char *)this;
    om_value_at_transitions_FOR_is_alive_X_true_X_is_stunted_X_false.offset_in_agent = (char *)&(this->om_value_at_transitions_FOR_is_alive_X_true_X_is_stunted_X_false) - (char *)this;
    om_value_at_transitions_FOR_is_alive_X_true_X_quality_of_schooling_X_false.offset_in_agent = (char *)&(this->om_value_at_transitions_FOR_is_alive_X_true_X_quality_of_schooling_X_false) - (char *)this;
    om_value_at_transitions_FOR_is_alive_X_true_X_survived_early_years_X_false.offset_in_agent = (char *)&(this->om_value_at_transitions_FOR_is_alive_X_true_X_survived_early_years_X_false) - (char *)this;
    om_value_at_transitions_FOR_is_alive_X_true_X_years_of_schooling_X_false.offset_in_agent = (char *)&(this->om_value_at_transitions_FOR_is_alive_X_true_X_years_of_schooling_X_false) - (char *)this;
    parity.offset_in_agent = (char *)&(this->parity) - (char *)this;
    preschool_is_decided.offset_in_agent = (char *)&(this->preschool_is_decided) - (char *)this;
    quality_adjusted_schooling.offset_in_agent = (char *)&(this->quality_adjusted_schooling) - (char *)this;
    quality_of_schooling.offset_in_agent = (char *)&(this->quality_of_schooling) - (char *)this;
    ready_to_set_alive.offset_in_agent = (char *)&(this->ready_to_set_alive) - (char *)this;
    region_birth.offset_in_agent = (char *)&(this->region_birth) - (char *)this;
    region_int.offset_in_agent = (char *)&(this->region_int) - (char *)this;
    region_nat.offset_in_agent = (char *)&(this->region_nat) - (char *)this;
    sel_years.offset_in_agent = (char *)&(this->sel_years) - (char *)this;
    selected_year10.offset_in_agent = (char *)&(this->selected_year10) - (char *)this;
    sex.offset_in_agent = (char *)&(this->sex) - (char *)this;
    sim_year.offset_in_agent = (char *)&(this->sim_year) - (char *)this;
    spouse_group.offset_in_agent = (char *)&(this->spouse_group) - (char *)this;
    survived_early_years.offset_in_agent = (char *)&(this->survived_early_years) - (char *)this;
    tab_out_of_primary.offset_in_agent = (char *)&(this->tab_out_of_primary) - (char *)this;
    tab_sim_yob.offset_in_agent = (char *)&(this->tab_sim_yob) - (char *)this;
    this_parity_spell.offset_in_agent = (char *)&(this->this_parity_spell) - (char *)this;
    time.offset_in_agent = (char *)&(this->time) - (char *)this;
    time_first_move.offset_in_agent = (char *)&(this->time_first_move) - (char *)this;
    time_in_parity.offset_in_agent = (char *)&(this->time_in_parity) - (char *)this;
    time_last_move.offset_in_agent = (char *)&(this->time_last_move) - (char *)this;
    time_next_birthday.offset_in_agent = (char *)&(this->time_next_birthday) - (char *)this;
    time_of_birth.offset_in_agent = (char *)&(this->time_of_birth) - (char *)this;
    time_of_first_immigration.offset_in_agent = (char *)&(this->time_of_first_immigration) - (char *)this;
    union1_group.offset_in_agent = (char *)&(this->union1_group) - (char *)this;
    year_of_birth.offset_in_agent = (char *)&(this->year_of_birth) - (char *)this;
    year_of_first_immigration.offset_in_agent = (char *)&(this->year_of_first_immigration) - (char *)this;
    years_of_schooling.offset_in_agent = (char *)&(this->years_of_schooling) - (char *)this;
    years_preschool.offset_in_agent = (char *)&(this->years_preschool) - (char *)this;
    zzz_om_om_ss_event_om_event.offset_in_agent = (char *)&(this->zzz_om_om_ss_event_om_event) - (char *)this;
}
void Person::om_check_starting_time()
{
    if (!std::isfinite((double)time)) {
        std::stringstream ss;
        ss << std::setprecision(std::numeric_limits<long double>::digits10 + 1) // maximum precision
           << std::showpoint // show decimal point
           << LT("error : invalid starting time ") << (double)time
           << LT(" in new ") << "Person"
           << LT(" with entity_id ") << entity_id
           << LT(" at global time ") << (double)BaseEvent::get_global_time()
           << LT(" in simulation member ") << get_simulation_member()
           << LT(" with combined seed ") << get_combined_seed()
            ;
        throw openm::SimulationException(ss.str().c_str());
    }
}
void Person::om_finalize_entity_sets()
{
    // asAllFertilePersonsForFertilityAlignment
    if (om_asAllFertilePersonsForFertilityAlignment_filter) {
        om_asAllFertilePersonsForFertilityAlignment_erase();
    }

    // asAllFertilePersonsForFertilityAlignmentByAge
    if (om_asAllFertilePersonsForFertilityAlignmentByAge_filter) {
        om_asAllFertilePersonsForFertilityAlignmentByAge_erase();
    }

    // asAllPerson
    if (om_asAllPerson_filter) {
        om_asAllPerson_erase();
    }

    // asAvailableMale
    if (om_asAvailableMale_filter) {
        om_asAvailableMale_erase();
    }

    // asAvailableMaleByType
    if (om_asAvailableMaleByType_filter) {
        om_asAvailableMaleByType_erase();
    }

    // asAvailableMaleByTypeImmiScratch
    if (om_asAvailableMaleByTypeImmiScratch_filter) {
        om_asAvailableMaleByTypeImmiScratch_erase();
    }

    // asAvailableMaleImmiScratch
    if (om_asAvailableMaleImmiScratch_filter) {
        om_asAvailableMaleImmiScratch_erase();
    }

    // asFemaleInUnionByAgeAndPartnerAge
    if (om_asFemaleInUnionByAgeAndPartnerAge_filter) {
        om_asFemaleInUnionByAgeAndPartnerAge_erase();
    }

    // asFemaleInUnionByAgeAndPartnerAgeImmiScratch
    if (om_asFemaleInUnionByAgeAndPartnerAgeImmiScratch_filter) {
        om_asFemaleInUnionByAgeAndPartnerAgeImmiScratch_erase();
    }

    // asPotentialImmigrantMothers
    if (om_asPotentialImmigrantMothers_filter) {
        om_asPotentialImmigrantMothers_erase();
    }

    // asPotentialSchoolOneStudent
    if (om_asPotentialSchoolOneStudent_filter) {
        om_asPotentialSchoolOneStudent_erase();
    }

    // asPotentialSchoolOneStudentToProcess
    if (om_asPotentialSchoolOneStudentToProcess_filter) {
        om_asPotentialSchoolOneStudentToProcess_erase();
    }

    // asPotentialSchoolTwoStudent
    if (om_asPotentialSchoolTwoStudent_filter) {
        om_asPotentialSchoolTwoStudent_erase();
    }

    // asPotentialSchoolTwoStudentToProcess
    if (om_asPotentialSchoolTwoStudentToProcess_filter) {
        om_asPotentialSchoolTwoStudentToProcess_erase();
    }

    // asResidentBabies
    if (om_asResidentBabies_filter) {
        om_asResidentBabies_erase();
    }

    // asResidentsAge0Sex
    if (om_asResidentsAge0Sex_filter) {
        om_asResidentsAge0Sex_erase();
    }

    // asResidentsAge0SexGeo
    if (om_asResidentsAge0SexGeo_filter) {
        om_asResidentsAge0SexGeo_erase();
    }

    // asSimBornAge0
    if (om_asSimBornAge0_filter) {
        om_asSimBornAge0_erase();
    }

    // asWantToMove
    if (om_asWantToMove_filter) {
        om_asWantToMove_erase();
    }

    // asWomenNoChildren
    if (om_asWomenNoChildren_filter) {
        om_asWomenNoChildren_erase();
    }

    // asWomenWithChildren
    if (om_asWomenWithChildren_filter) {
        om_asWomenWithChildren_erase();
    }

}
void Person::om_finalize_events()
{
    om_BackMigrationEvent_om_event.make_zombie();
    om_BirthdayEvent_om_event.make_zombie();
    om_DeathAtMaxLifespanEvent_om_event.make_zombie();
    om_EmigrationEvent_om_event.make_zombie();
    om_FertilityBaseEvent_om_event.make_zombie();
    om_FertilityDetailedEvent_om_event.make_zombie();
    om_FirstImmigrationFromPoolEvent_om_event.make_zombie();
    om_FirstImmigrationFromScratchEvent_om_event.make_zombie();
    om_FirstUnionFormationEvent_om_event.make_zombie();
    om_LeavingHomeEvent_om_event.make_zombie();
    om_MigrationEvent_om_event.make_zombie();
    om_MortalityBaseEvent_om_event.make_zombie();
    om_MortalityDetailedEvent_om_event.make_zombie();
    om_SetAliveEvent_om_event.make_zombie();
    om_SetPreschoolYearsEvent_om_event.make_zombie();
    zzz_om_om_ss_event_om_event.make_zombie();
}
void Person::om_finalize_links()
{
    lBioFather.set(nullptr);
    lBioMother.set(nullptr);
    lCalibrator.set(nullptr);
    lHHFather.set(nullptr);
    lHHMother.set(nullptr);
    lSpouse.set(nullptr);
    lStartValues.set(nullptr);
}
void Person::om_finalize_multilinks()
{
    mlBioFatherChildren.clear();
    mlBioMotherChildren.clear();
    mlHHFatherChildren.clear();
    mlHHMotherChildren.clear();
}
void Person::om_finalize_tables()
{
    // PopPyramidByEduc
    if (thePopPyramidByEduc) {
        auto & incr = om_PopPyramidByEduc_incr;
        incr.finalize_increment();
    }

    // TabChildVaccination
    if (theTabChildVaccination) {
        auto & incr = om_TabChildVaccination_incr;
        incr.finalize_increment();
    }

    // TabEduc15ByDistrict
    if (theTabEduc15ByDistrict) {
        auto & incr = om_TabEduc15ByDistrict_incr;
        incr.finalize_increment();
    }

    // TabEduc15ByDistrictBirth
    if (theTabEduc15ByDistrictBirth) {
        auto & incr = om_TabEduc15ByDistrictBirth_incr;
        incr.finalize_increment();
    }

    // TabEducFateByGroup
    if (theTabEducFateByGroup) {
        auto & incr = om_TabEducFateByGroup_incr;
        incr.finalize_increment();
    }

    // TabEducFateDistrYob
    if (theTabEducFateDistrYob) {
        auto & incr = om_TabEducFateDistrYob_incr;
        incr.finalize_increment();
    }

    // TabHCIDistrict
    if (theTabHCIDistrict) {
        auto & incr = om_TabHCIDistrict_incr;
        incr.finalize_increment();
    }

    // TabImmunizationChildren
    if (theTabImmunizationChildren) {
        auto & incr = om_TabImmunizationChildren_incr;
        incr.finalize_increment();
    }

    // TabPopProvAgeEducSex
    if (theTabPopProvAgeEducSex) {
        auto & incr = om_TabPopProvAgeEducSex_incr;
        incr.finalize_increment();
    }

    // TabPrenatCare
    if (theTabPrenatCare) {
        auto & incr = om_TabPrenatCare_incr;
        incr.finalize_increment();
    }

    // TabPrimSchoolEntries
    if (theTabPrimSchoolEntries) {
        auto & incr = om_TabPrimSchoolEntries_incr;
        incr.finalize_increment();
    }

    // TabPrimSchoolGraduations
    if (theTabPrimSchoolGraduations) {
        auto & incr = om_TabPrimSchoolGraduations_incr;
        incr.finalize_increment();
    }

    // TabPrimSchoolOutOfSchool9to11
    if (theTabPrimSchoolOutOfSchool9to11) {
        auto & incr = om_TabPrimSchoolOutOfSchool9to11_incr;
        incr.finalize_increment();
    }

    // TabPrimarySchoolPlanning
    if (theTabPrimarySchoolPlanning) {
        auto & incr = om_TabPrimarySchoolPlanning_incr;
        incr.finalize_increment();
    }

    // TabSchool2AttainmentsTab
    if (theTabSchool2AttainmentsTab) {
        auto & incr = om_TabSchool2AttainmentsTab_incr;
        incr.finalize_increment();
    }

    // TabSchool2TrackTab
    if (theTabSchool2TrackTab) {
        auto & incr = om_TabSchool2TrackTab_incr;
        incr.finalize_increment();
    }

    // tabBirthsYearPlace
    if (thetabBirthsYearPlace) {
        auto & incr = om_tabBirthsYearPlace_incr;
        incr.finalize_increment();
    }

    // tabEducationFateGeobirYob
    if (thetabEducationFateGeobirYob) {
        auto & incr = om_tabEducationFateGeobirYob_incr;
        incr.finalize_increment();
    }

    // tabHCI
    if (thetabHCI) {
        auto & incr = om_tabHCI_incr;
        incr.finalize_increment();
    }

    // tabHavingSpouse
    if (thetabHavingSpouse) {
        auto & incr = om_tabHavingSpouse_incr;
        incr.finalize_increment();
    }

    // tabMigrationOriginDestination
    if (thetabMigrationOriginDestination) {
        auto & incr = om_tabMigrationOriginDestination_incr;
        incr.finalize_increment();
    }

    // tabPopulationYearPlace
    if (thetabPopulationYearPlace) {
        auto & incr = om_tabPopulationYearPlace_incr;
        incr.finalize_increment();
    }

    // tabPreSchool
    if (thetabPreSchool) {
        auto & incr = om_tabPreSchool_incr;
        incr.finalize_increment();
    }

    // tabStuntingSexRegMotherYob
    if (thetabStuntingSexRegMotherYob) {
        auto & incr = om_tabStuntingSexRegMotherYob_incr;
        incr.finalize_increment();
    }

    // tabStuntingSexRegYob
    if (thetabStuntingSexRegYob) {
        auto & incr = om_tabStuntingSexRegYob_incr;
        incr.finalize_increment();
    }

}
int Person::om_get_entity_id()
{
    return entity_id;
}
Time Person::om_get_time()
{
    return time.get();
}
void Person::om_initialize_data_members()
{
    #line 100 "../code/HumanCapitalIndex.mpp"
    adult_survival.initialize( 0.0 );
    age.initialize( 0 );
    #line 95 "../code/FamilyFemalePartnershipStatus.mpp"
    age_last_birth.initialize( 0.0 );
    #line 43 "../code/MigrationGeneral.mpp"
    age_mig.initialize( 0 );
    #line 84 "../code/FamilyFemalePartnershipStatus.mpp"
    age_youngest_child.initialize( 0.0 );
    #line 23 "../code/TablesPopulation.mpp"
    all_year.initialize( 1899 );
    #line 21 "../code/ClockEvents.mpp"
    calendar_year.initialize( 1899 );
    case_seed.initialize( 0.0 );
    #line 109 "../code/FamilyFemalePartnershipStatus.mpp"
    child_agegr.initialize( CA00 );
    #line 88 "../code/FamilyFemalePartnershipStatus.mpp"
    child_agegr_part.initialize( 0 );
    #line 57 "../code/MortalityDetailed.mpp"
    child_mortality.initialize( 0.0 );
    #line 70 "../code/MortalityDetailed.mpp"
    child_mortality_group.initialize( CMG_00 );
    #line 74 "../code/FamilyGeneral.mpp"
    children_in_household.initialize( 0 );
    #line 69 "../code/ActorPerson.mpp"
    creation_type.initialize( CT_START );
    #line 100 "../code/EducationPrimaryTransmission.mpp"
    educ1_group.initialize( E1G_00 );
    #line 97 "../code/EducationPrimaryTransmission.mpp"
    educ_mother.initialize( EOL_LOW );
    #line 97 "../code/EducationPrimaryTracking.mpp"
    educ_one_entry_age.initialize( 6 );
    #line 65 "../code/EducationPrimaryBase.mpp"
    educ_one_fate.initialize( EOL_LOW );
    #line 99 "../code/EducationPrimaryTracking.mpp"
    educ_one_geo.initialize( EOG_OO );
    #line 107 "../code/EducationPrimaryTracking.mpp"
    educ_one_grade.initialize( 1 );
    #line 94 "../code/EducationPrimaryTracking.mpp"
    educ_one_grade_attended.initialize( 0 );
    #line 98 "../code/EducationPrimaryTracking.mpp"
    educ_one_grade_fate.initialize( 1 );
    #line 95 "../code/EducationPrimaryTracking.mpp"
    educ_one_grade_passed.initialize( 0 );
    #line 100 "../code/EducationPrimaryTracking.mpp"
    educ_one_group.initialize( E1G_OO );
    #line 111 "../code/EducationPrimaryTracking.mpp"
    educ_one_level.initialize( EOL_LOW );
    #line 42 "../code/EducationPrimaryPlanning.mpp"
    educ_one_required_rooms.initialize( 0.0 );
    #line 38 "../code/EducationPrimaryPlanning.mpp"
    educ_one_required_teachers.initialize( 0.0 );
    #line 96 "../code/EducationPrimaryTracking.mpp"
    educ_one_status.initialize( EOS_NEVER );
    #line 93 "../code/EducationPrimaryTracking.mpp"
    educ_one_to_process.initialize( false );
    #line 107 "../code/EducationSecondaryBase.mpp"
    educ_two_delay.initialize( 0 );
    #line 118 "../code/EducationSecondaryBase.mpp"
    educ_two_geo.initialize( ETG_OO );
    #line 116 "../code/EducationSecondaryBase.mpp"
    educ_two_grade_attended.initialize( 0 );
    #line 117 "../code/EducationSecondaryBase.mpp"
    educ_two_grade_passed.initialize( 0 );
    #line 119 "../code/EducationSecondaryBase.mpp"
    educ_two_group.initialize( E2G_OO );
    #line 112 "../code/EducationSecondaryBase.mpp"
    educ_two_level.initialize( ETL_NEVER );
    #line 109 "../code/EducationSecondaryBase.mpp"
    educ_two_status.initialize( ETS_NEVER );
    #line 108 "../code/EducationSecondaryBase.mpp"
    educ_two_to_process.initialize( false );
    entity_id.initialize( 0 );
    #line 42 "../code/Ethnicity.mpp"
    ethnicity.initialize( ETHNO_00 );
    #line 52 "../code/ChildVaccination.mpp"
    ethnicity_short.initialize( ES_00 );
    events.initialize( 0 );
    #line 76 "../code/ActorPerson.mpp"
    ever_resident.initialize( false );
    #line 90 "../code/FamilyFirstUnion.mpp"
    ever_union.initialize( false );
    #line 71 "../code/FamilyGeneral.mpp"
    family_role.initialize( FR_HEAD );
    #line 81 "../code/FamilyPartnerMatching.mpp"
    female_spouse_age.initialize( 10 );
    #line 49 "../code/FertilityGeneral.mpp"
    fertile_age.initialize( 12 );
    #line 48 "../code/MigrationGeneral.mpp"
    first_move_done.initialize( false );
    #line 72 "../code/ActorPerson.mpp"
    geo.initialize( GEO_00 );
    #line 71 "../code/ActorPerson.mpp"
    geo_birth.initialize( GEO_00 );
    #line 55 "../code/MigrationGeneral.mpp"
    geo_nat.initialize( GEON_00 );
    #line 73 "../code/ActorPerson.mpp"
    geo_prev.initialize( GEO_00 );
    #line 53 "../code/MigrationGeneral.mpp"
    geo_want_to_move.initialize( GEO_00 );
    #line 54 "../code/ChildVaccination.mpp"
    got_prenat_care.initialize( GPC_NO );
    #line 25 "../code/TablesEducation.mpp"
    has_passed_primary.initialize( false );
    #line 83 "../code/FamilyPartnerMatching.mpp"
    has_spouse.initialize( false );
    #line 82 "../code/HumanCapitalIndex.mpp"
    in_hci_sample.initialize( false );
    #line 18 "../code/TablesEducation.mpp"
    in_projected_time.initialize( false );
    #line 34 "../code/_ContextABC.mpp"
    in_sel_years.initialize( false );
    #line 34 "../code/TablesPopulation.mpp"
    in_selected_year.initialize( false );
    #line 106 "../code/HumanCapitalIndex.mpp"
    ind_hci.initialize( 0.0 );
    #line 13 "../code/ClockEvents.mpp"
    integer_age.initialize( 0 );
    #line 22 "../code/TablesEducation.mpp"
    is_aded0.initialize( false );
    #line 23 "../code/TablesEducation.mpp"
    is_aded1.initialize( false );
    #line 24 "../code/TablesEducation.mpp"
    is_aded2.initialize( false );
    #line 103 "../code/HumanCapitalIndex.mpp"
    is_adult.initialize( false );
    #line 75 "../code/ActorPerson.mpp"
    is_alive.initialize( false );
    #line 116 "../code/FamilyFemalePartnershipStatus.mpp"
    is_blocked_from_marriage.initialize( false );
    #line 20 "../code/TablesEducation.mpp"
    is_child.initialize( false );
    #line 103 "../code/EducationPrimaryTracking.mpp"
    is_educ_one_student.initialize( false );
    #line 44 "../code/FertilityGeneral.mpp"
    is_fertile.initialize( false );
    #line 53 "../code/ChildVaccination.mpp"
    is_immunized.initialize( false );
    #line 42 "../code/MortalityGeneral.mpp"
    is_mortal.initialize( false );
    #line 21 "../code/TablesEducation.mpp"
    is_old.initialize( false );
    #line 77 "../code/ActorPerson.mpp"
    is_ready_for_birthtables.initialize( false );
    #line 79 "../code/ActorPerson.mpp"
    is_resident.initialize( false );
    #line 30 "../code/Stunting.mpp"
    is_stunted.initialize( false );
    #line 21 "../code/FamilyGeneral.mpp"
    lBioFather.initialize( nullptr );
    #line 22 "../code/FamilyGeneral.mpp"
    lBioMother.initialize( nullptr );
    #line 22 "../code/ActorCalibrator.mpp"
    lCalibrator.initialize( nullptr );
    #line 24 "../code/FamilyGeneral.mpp"
    lHHFather.initialize( nullptr );
    #line 25 "../code/FamilyGeneral.mpp"
    lHHMother.initialize( nullptr );
    #line 27 "../code/FamilyGeneral.mpp"
    lSpouse.initialize( nullptr );
    #line 14 "../code/ActorStartpopValues.mpp"
    lStartValues.initialize( nullptr );
    #line 91 "../code/FamilyFemalePartnershipStatus.mpp"
    lives_with_dependent_child.initialize( false );
    #line 78 "../code/FamilyPartnerMatching.mpp"
    male_age.initialize( 15 );
    #line 75 "../code/FamilyPartnerMatching.mpp"
    male_spouse_age.initialize( 15 );
    #line 21 "../code/FamilyGeneral.mpp"
    mlBioFatherChildren.initialize( nullptr );
    #line 22 "../code/FamilyGeneral.mpp"
    mlBioMotherChildren.initialize( nullptr );
    #line 24 "../code/FamilyGeneral.mpp"
    mlHHFatherChildren.initialize( nullptr );
    #line 25 "../code/FamilyGeneral.mpp"
    mlHHMotherChildren.initialize( nullptr );
    #line 102 "../code/FamilyFemalePartnershipStatus.mpp"
    moth_agegr.initialize( CMA20 );
    #line 99 "../code/FamilyFemalePartnershipStatus.mpp"
    moth_agegr_part.initialize( 0 );
    #line 81 "../code/MortalityDetailed.mpp"
    mother_age_at_birth.initialize( time_infinite );
    #line 29 "../code/ImmigrationBackMigration.mpp"
    om_BackMigrationEvent_om_event.initialize( time_infinite );
    #line 15 "../code/ClockEvents.mpp"
    om_BirthdayEvent_om_event.initialize( time_infinite );
    #line 52 "../code/MortalityGeneral.mpp"
    om_DeathAtMaxLifespanEvent_om_event.initialize( time_infinite );
    #line 37 "../code/EmigrationBase.mpp"
    om_EmigrationEvent_om_event.initialize( time_infinite );
    #line 36 "../code/FertilityBase.mpp"
    om_FertilityBaseEvent_om_event.initialize( time_infinite );
    #line 105 "../code/FertilityDetailed.mpp"
    om_FertilityDetailedEvent_om_event.initialize( time_infinite );
    #line 32 "../code/ImmigrationFromPool.mpp"
    om_FirstImmigrationFromPoolEvent_om_event.initialize( time_infinite );
    #line 64 "../code/ImmigrationFromScratch.mpp"
    om_FirstImmigrationFromScratchEvent_om_event.initialize( time_infinite );
    #line 91 "../code/FamilyFirstUnion.mpp"
    om_FirstUnionFormationEvent_om_event.initialize( time_infinite );
    #line 27 "../code/FamilyLeavingHome.mpp"
    om_LeavingHomeEvent_om_event.initialize( time_infinite );
    #line 30 "../code/MigrationBase.mpp"
    om_MigrationEvent_om_event.initialize( time_infinite );
    #line 33 "../code/MortalityBase.mpp"
    om_MortalityBaseEvent_om_event.initialize( time_infinite );
    #line 82 "../code/MortalityDetailed.mpp"
    om_MortalityDetailedEvent_om_event.initialize( time_infinite );
    om_PopPyramidByEduc_in_om_duration_FOR_educ_one_level_X_EOL_HIGH = 0;
    om_PopPyramidByEduc_in_om_duration_FOR_educ_one_level_X_EOL_LOW = 0;
    om_PopPyramidByEduc_in_om_duration_FOR_educ_one_level_X_EOL_MEDIUM = 0;
    #line 82 "../code/ActorPerson.mpp"
    om_SetAliveEvent_om_event.initialize( time_infinite );
    #line 40 "../code/EducationPreSchool.mpp"
    om_SetPreschoolYearsEvent_om_event.initialize( time_infinite );
    om_TabChildVaccination_in_om_duration = 0;
    om_TabChildVaccination_in_om_duration_FOR_is_immunized_X_true = 0;
    om_TabEduc15ByDistrictBirth_in_om_duration = 0;
    om_TabEduc15ByDistrictBirth_in_om_duration_FOR_educ_one_fate_X_EOL_HIGH = 0;
    om_TabEduc15ByDistrictBirth_in_om_duration_FOR_educ_one_fate_X_EOL_LOW = 0;
    om_TabEduc15ByDistrictBirth_in_om_duration_FOR_educ_one_fate_X_EOL_MEDIUM = 0;
    om_TabEduc15ByDistrict_in_om_duration = 0;
    om_TabEduc15ByDistrict_in_om_duration_FOR_educ_one_fate_X_EOL_HIGH = 0;
    om_TabEduc15ByDistrict_in_om_duration_FOR_educ_one_fate_X_EOL_LOW = 0;
    om_TabEduc15ByDistrict_in_om_duration_FOR_educ_one_fate_X_EOL_MEDIUM = 0;
    om_TabHCIDistrict_in_om_transitions_FOR_integer_age_X_14_X_15 = 0;
    om_TabHCIDistrict_in_om_transitions_FOR_is_alive_X_true_X_false = 0;
    om_TabHCIDistrict_in_om_transitions_FOR_survived_early_years_X_false_X_true = 0;
    om_TabHCIDistrict_in_om_value_at_transitions_FOR_is_alive_X_true_X_adult_survival_X_false = 0;
    om_TabHCIDistrict_in_om_value_at_transitions_FOR_is_alive_X_true_X_ind_hci_X_false = 0;
    om_TabHCIDistrict_in_om_value_at_transitions_FOR_is_alive_X_true_X_is_stunted_X_false = 0;
    om_TabHCIDistrict_in_om_value_at_transitions_FOR_is_alive_X_true_X_quality_of_schooling_X_false = 0;
    om_TabHCIDistrict_in_om_value_at_transitions_FOR_is_alive_X_true_X_survived_early_years_X_false = 0;
    om_TabHCIDistrict_in_om_value_at_transitions_FOR_is_alive_X_true_X_years_of_schooling_X_false = 0;
    om_TabImmunizationChildren_in_om_duration = 0;
    om_TabImmunizationChildren_in_om_duration_FOR_is_immunized_X_true = 0;
    om_TabPopProvAgeEducSex_in_om_duration_FOR_is_aded0_X_true = 0;
    om_TabPopProvAgeEducSex_in_om_duration_FOR_is_aded1_X_true = 0;
    om_TabPopProvAgeEducSex_in_om_duration_FOR_is_aded2_X_true = 0;
    om_TabPopProvAgeEducSex_in_om_duration_FOR_is_child_X_true = 0;
    om_TabPopProvAgeEducSex_in_om_duration_FOR_is_old_X_true = 0;
    om_TabPrenatCare_in_om_duration = 0;
    om_TabPrenatCare_in_om_duration_FOR_got_prenat_care_X_GPC_YES = 0;
    om_TabPrimSchoolEntries_in_om_entrances_FOR_educ_one_grade_attended_X_1 = 0;
    om_TabPrimSchoolGraduations_in_om_entrances_FOR_has_passed_primary_X_true = 0;
    om_TabPrimSchoolOutOfSchool9to11_in_om_duration = 0;
    om_TabPrimSchoolOutOfSchool9to11_in_om_duration_FOR_tab_out_of_primary_X_true = 0;
    om_TabSchool2AttainmentsTab_in_om_duration = 0;
    om_TabSchool2AttainmentsTab_in_om_duration_FOR_educ_two_level_X_ETL_GRADUATE = 0;
    om_TabSchool2AttainmentsTab_in_om_duration_FOR_educ_two_level_X_ETL_INCOMPLETE = 0;
    om_TabSchool2AttainmentsTab_in_om_duration_FOR_educ_two_level_X_ETL_NEVER = 0;
    om_active_spell_duration_FOR_this_parity_spell_X_true.initialize( 0 );
    om_aggregate_FOR_ethnicity_X_ETHNICITY_SHORT.initialize( ES_00 );
    om_aggregate_FOR_geo_X_GEO_NAT.initialize( GEON_00 );
    om_aggregate_FOR_geo_X_REGION_INT.initialize( REGI_00 );
    om_aggregate_FOR_geo_birth_X_GEO_NAT.initialize( GEON_00 );
    om_aggregate_FOR_geo_birth_X_REGION_INT.initialize( REGI_00 );
    om_aggregate_FOR_region_birth_X_REGION_NAT.initialize( REGN_00 );
    om_aggregate_FOR_region_int_X_REGION_NAT.initialize( REGN_00 );
    om_aia_0.initialize( false );
    #line 76 "../code/TablesEducation.mpp"
    om_aia_1.initialize( false );
    om_aia_10.initialize( false );
    om_aia_11.initialize( false );
    om_aia_12.initialize( false );
    #line 115 "../code/TablesEducation.mpp"
    om_aia_13.initialize( false );
    #line 126 "../code/TablesEducation.mpp"
    om_aia_14.initialize( false );
    #line 139 "../code/TablesEducation.mpp"
    om_aia_15.initialize( false );
    om_aia_16.initialize( false );
    om_aia_17.initialize( false );
    om_aia_18.initialize( false );
    om_aia_19.initialize( false );
    om_aia_2.initialize( false );
    om_aia_20.initialize( false );
    #line 154 "../code/TablesEducation.mpp"
    om_aia_21.initialize( false );
    #line 165 "../code/TablesEducation.mpp"
    om_aia_22.initialize( false );
    #line 211 "../code/TablesEducation.mpp"
    om_aia_23.initialize( false );
    om_aia_24.initialize( false );
    #line 221 "../code/TablesEducation.mpp"
    om_aia_25.initialize( false );
    #line 231 "../code/TablesEducation.mpp"
    om_aia_26.initialize( false );
    om_aia_27.initialize( false );
    om_aia_28.initialize( false );
    om_aia_29.initialize( false );
    om_aia_3.initialize( false );
    #line 13 "../code/TablesFamily.mpp"
    om_aia_30.initialize( false );
    om_aia_31.initialize( false );
    om_aia_32.initialize( false );
    #line 17 "../code/TablesHumanCapital.mpp"
    om_aia_33.initialize( false );
    #line 45 "../code/TablesPopulation.mpp"
    om_aia_34.initialize( false );
    #line 65 "../code/TablesPopulation.mpp"
    om_aia_35.initialize( false );
    #line 17 "../code/TablesStunting.mpp"
    om_aia_36.initialize( false );
    #line 19 "../code/TablesVaccination.mpp"
    om_aia_37.initialize( false );
    om_aia_38.initialize( false );
    om_aia_39.initialize( false );
    om_aia_4.initialize( false );
    #line 46 "../code/TablesVaccination.mpp"
    om_aia_40.initialize( false );
    #line 88 "../code/TablesEducation.mpp"
    om_aia_5.initialize( false );
    om_aia_6.initialize( false );
    om_aia_7.initialize( false );
    om_aia_8.initialize( false );
    #line 101 "../code/TablesEducation.mpp"
    om_aia_9.initialize( false );
    om_asAllFertilePersonsForFertilityAlignmentByAge_cell = 0;
    #line 27 "../code/FertilityDetailed.mpp"
    om_asAllFertilePersonsForFertilityAlignmentByAge_filter.initialize( false );
    om_asAllFertilePersonsForFertilityAlignment_cell = 0;
    #line 31 "../code/FertilityDetailed.mpp"
    om_asAllFertilePersonsForFertilityAlignment_filter.initialize( false );
    om_asAllPerson_cell = 0;
    #line 40 "../code/ActorPerson.mpp"
    om_asAllPerson_filter.initialize( false );
    om_asAvailableMaleByTypeImmiScratch_cell = 0;
    #line 32 "../code/FamilyPartnerMatching.mpp"
    om_asAvailableMaleByTypeImmiScratch_filter.initialize( false );
    om_asAvailableMaleByType_cell = 0;
    #line 18 "../code/FamilyPartnerMatching.mpp"
    om_asAvailableMaleByType_filter.initialize( false );
    om_asAvailableMaleImmiScratch_cell = 0;
    #line 28 "../code/FamilyPartnerMatching.mpp"
    om_asAvailableMaleImmiScratch_filter.initialize( false );
    om_asAvailableMale_cell = 0;
    #line 14 "../code/FamilyPartnerMatching.mpp"
    om_asAvailableMale_filter.initialize( false );
    om_asFemaleInUnionByAgeAndPartnerAgeImmiScratch_cell = 0;
    #line 36 "../code/FamilyPartnerMatching.mpp"
    om_asFemaleInUnionByAgeAndPartnerAgeImmiScratch_filter.initialize( false );
    om_asFemaleInUnionByAgeAndPartnerAge_cell = 0;
    #line 22 "../code/FamilyPartnerMatching.mpp"
    om_asFemaleInUnionByAgeAndPartnerAge_filter.initialize( false );
    om_asPotentialImmigrantMothers_cell = 0;
    #line 9 "../code/ImmigrationFromScratch.mpp"
    om_asPotentialImmigrantMothers_filter.initialize( false );
    om_asPotentialSchoolOneStudentToProcess_cell = 0;
    #line 28 "../code/EducationPrimaryTracking.mpp"
    om_asPotentialSchoolOneStudentToProcess_filter.initialize( false );
    om_asPotentialSchoolOneStudent_cell = 0;
    #line 25 "../code/EducationPrimaryTracking.mpp"
    om_asPotentialSchoolOneStudent_filter.initialize( false );
    om_asPotentialSchoolTwoStudentToProcess_cell = 0;
    #line 29 "../code/EducationSecondaryBase.mpp"
    om_asPotentialSchoolTwoStudentToProcess_filter.initialize( false );
    om_asPotentialSchoolTwoStudent_cell = 0;
    #line 26 "../code/EducationSecondaryBase.mpp"
    om_asPotentialSchoolTwoStudent_filter.initialize( false );
    om_asResidentBabies_cell = 0;
    #line 18 "../code/ChildVaccination.mpp"
    om_asResidentBabies_filter.initialize( false );
    om_asResidentsAge0SexGeo_cell = 0;
    #line 27 "../code/EducationPrimaryBase.mpp"
    om_asResidentsAge0SexGeo_filter.initialize( false );
    om_asResidentsAge0Sex_cell = 0;
    #line 30 "../code/EducationPrimaryBase.mpp"
    om_asResidentsAge0Sex_filter.initialize( false );
    om_asSimBornAge0_cell = 0;
    #line 35 "../code/EducationPrimaryTransmission.mpp"
    om_asSimBornAge0_filter.initialize( false );
    om_asWantToMove_cell = 0;
    #line 11 "../code/MigrationGeneral.mpp"
    om_asWantToMove_filter.initialize( false );
    om_asWomenNoChildren_cell = 0;
    #line 27 "../code/FamilyFemalePartnershipStatus.mpp"
    om_asWomenNoChildren_filter.initialize( false );
    om_asWomenWithChildren_cell = 0;
    #line 22 "../code/FamilyFemalePartnershipStatus.mpp"
    om_asWomenWithChildren_filter.initialize( false );
    om_duration.initialize( 0 );
    om_duration_FOR_educ_one_fate_X_EOL_HIGH.initialize( 0 );
    om_duration_FOR_educ_one_fate_X_EOL_LOW.initialize( 0 );
    om_duration_FOR_educ_one_fate_X_EOL_MEDIUM.initialize( 0 );
    om_duration_FOR_educ_one_level_X_EOL_HIGH.initialize( 0 );
    om_duration_FOR_educ_one_level_X_EOL_LOW.initialize( 0 );
    om_duration_FOR_educ_one_level_X_EOL_MEDIUM.initialize( 0 );
    om_duration_FOR_educ_two_level_X_ETL_GRADUATE.initialize( 0 );
    om_duration_FOR_educ_two_level_X_ETL_INCOMPLETE.initialize( 0 );
    om_duration_FOR_educ_two_level_X_ETL_NEVER.initialize( 0 );
    om_duration_FOR_ever_union_X_true.initialize( 0 );
    om_duration_FOR_got_prenat_care_X_GPC_YES.initialize( 0 );
    om_duration_FOR_has_spouse_X_true.initialize( 0 );
    om_duration_FOR_is_aded0_X_true.initialize( 0 );
    om_duration_FOR_is_aded1_X_true.initialize( 0 );
    om_duration_FOR_is_aded2_X_true.initialize( 0 );
    om_duration_FOR_is_child_X_true.initialize( 0 );
    om_duration_FOR_is_immunized_X_true.initialize( 0 );
    om_duration_FOR_is_old_X_true.initialize( 0 );
    om_duration_FOR_tab_out_of_primary_X_true.initialize( 0 );
    om_duration_FOR_years_preschool_X_0.initialize( 0 );
    om_duration_FOR_years_preschool_X_1.initialize( 0 );
    om_duration_FOR_years_preschool_X_2.initialize( 0 );
    om_entrances_FOR_educ_one_grade_attended_X_1.initialize( 0 );
    om_entrances_FOR_has_passed_primary_X_true.initialize( 0 );
    om_mlHHFatherChildren_count.initialize( 0 );
    om_mlHHFatherChildren_sum_over_is_alive.initialize( 0 );
    om_mlHHMotherChildren_count.initialize( 0 );
    om_mlHHMotherChildren_min_over_integer_age.initialize( 0 );
    om_mlHHMotherChildren_sum_over_is_alive.initialize( 0 );
    om_self_scheduling_split_FOR_age_X_AGE_MIG_PART.initialize( 0 );
    om_self_scheduling_split_FOR_om_active_spell_duration_FOR_this_parity_spell_X_true_X_DUR_TIME_IN_PARITY.initialize( 0 );
    om_split_FOR_age_last_birth_X_MOTH_AGEGR_PART.initialize( 0 );
    om_split_FOR_age_youngest_child_X_CHILD_AGEGR_PART.initialize( 0 );
    om_split_FOR_integer_age_X_TAB_AGEC5.initialize( 0 );
    om_ss_time_om_self_scheduling_split_FOR_age_X_AGE_MIG_PART = time_infinite;
    om_ss_time_om_self_scheduling_split_FOR_om_active_spell_duration_FOR_this_parity_spell_X_true_X_DUR_TIME_IN_PARITY = time_infinite;
    om_ss_time_om_trigger_changes_FOR_calendar_year = time_infinite;
    om_ss_time_om_trigger_changes_FOR_geo = time_infinite;
    om_ss_time_om_trigger_entrances_FOR_is_ready_for_birthtables_X_true = time_infinite;
    om_tabBirthsYearPlace_in_om_transitions_FOR_is_alive_X_false_X_true = 0;
    om_tabEducationFateGeobirYob_in_om_duration = 0;
    om_tabEducationFateGeobirYob_in_om_duration_FOR_educ_one_fate_X_EOL_HIGH = 0;
    om_tabEducationFateGeobirYob_in_om_duration_FOR_educ_one_fate_X_EOL_LOW = 0;
    om_tabEducationFateGeobirYob_in_om_duration_FOR_educ_one_fate_X_EOL_MEDIUM = 0;
    om_tabHCI_in_om_transitions_FOR_integer_age_X_14_X_15 = 0;
    om_tabHCI_in_om_transitions_FOR_is_alive_X_true_X_false = 0;
    om_tabHCI_in_om_transitions_FOR_survived_early_years_X_false_X_true = 0;
    om_tabHCI_in_om_value_at_transitions_FOR_is_alive_X_true_X_adult_survival_X_false = 0;
    om_tabHCI_in_om_value_at_transitions_FOR_is_alive_X_true_X_ind_hci_X_false = 0;
    om_tabHCI_in_om_value_at_transitions_FOR_is_alive_X_true_X_is_stunted_X_false = 0;
    om_tabHCI_in_om_value_at_transitions_FOR_is_alive_X_true_X_quality_of_schooling_X_false = 0;
    om_tabHCI_in_om_value_at_transitions_FOR_is_alive_X_true_X_survived_early_years_X_false = 0;
    om_tabHCI_in_om_value_at_transitions_FOR_is_alive_X_true_X_years_of_schooling_X_false = 0;
    om_tabHavingSpouse_in_om_duration = 0;
    om_tabHavingSpouse_in_om_duration_FOR_ever_union_X_true = 0;
    om_tabHavingSpouse_in_om_duration_FOR_has_spouse_X_true = 0;
    om_tabMigrationOriginDestination_in_is_alive = false;
    om_tabPopulationYearPlace_in_om_duration = 0;
    om_tabPreSchool_in_om_duration = 0;
    om_tabPreSchool_in_om_duration_FOR_years_preschool_X_0 = 0;
    om_tabPreSchool_in_om_duration_FOR_years_preschool_X_1 = 0;
    om_tabPreSchool_in_om_duration_FOR_years_preschool_X_2 = 0;
    om_tabStuntingSexRegMotherYob_in_is_stunted = false;
    om_tabStuntingSexRegYob_in_is_stunted = false;
    om_transitions_FOR_integer_age_X_14_X_15.initialize( 0 );
    om_transitions_FOR_is_alive_X_false_X_true.initialize( 0 );
    om_transitions_FOR_is_alive_X_true_X_false.initialize( 0 );
    om_transitions_FOR_survived_early_years_X_false_X_true.initialize( 0 );
    om_trigger_changes_FOR_calendar_year.initialize( false );
    om_trigger_changes_FOR_geo.initialize( false );
    om_trigger_entrances_FOR_is_ready_for_birthtables_X_true.initialize( false );
    om_value_at_transitions_FOR_is_alive_X_true_X_adult_survival_X_false.initialize( 0 );
    om_value_at_transitions_FOR_is_alive_X_true_X_ind_hci_X_false.initialize( 0 );
    om_value_at_transitions_FOR_is_alive_X_true_X_is_stunted_X_false.initialize( 0 );
    om_value_at_transitions_FOR_is_alive_X_true_X_quality_of_schooling_X_false.initialize( 0 );
    om_value_at_transitions_FOR_is_alive_X_true_X_survived_early_years_X_false.initialize( 0 );
    om_value_at_transitions_FOR_is_alive_X_true_X_years_of_schooling_X_false.initialize( 0 );
    #line 101 "../code/FertilityDetailed.mpp"
    parity.initialize( 0 );
    #line 39 "../code/EducationPreSchool.mpp"
    preschool_is_decided.initialize( false );
    #line 91 "../code/HumanCapitalIndex.mpp"
    quality_adjusted_schooling.initialize( 0.0 );
    #line 88 "../code/HumanCapitalIndex.mpp"
    quality_of_schooling.initialize( 0.0 );
    #line 81 "../code/ActorPerson.mpp"
    ready_to_set_alive.initialize( false );
    #line 59 "../code/MigrationGeneral.mpp"
    region_birth.initialize( REGI_00 );
    #line 57 "../code/MigrationGeneral.mpp"
    region_int.initialize( REGI_00 );
    #line 58 "../code/MigrationGeneral.mpp"
    region_nat.initialize( REGN_00 );
    #line 39 "../code/_ContextABC.mpp"
    sel_years.initialize( TSY_2000 );
    #line 27 "../code/TablesPopulation.mpp"
    selected_year10.initialize( SY00 );
    #line 67 "../code/ActorPerson.mpp"
    sex.initialize( FEMALE );
    #line 24 "../code/TablesPopulation.mpp"
    sim_year.initialize( 2000 );
    #line 86 "../code/FamilyPartnerMatching.mpp"
    spouse_group.initialize( SMG_00 );
    #line 97 "../code/HumanCapitalIndex.mpp"
    survived_early_years.initialize( false );
    #line 28 "../code/TablesEducation.mpp"
    tab_out_of_primary.initialize( false );
    #line 19 "../code/TablesEducation.mpp"
    tab_sim_yob.initialize( 2000 );
    #line 54 "../code/FertilityGeneral.mpp"
    this_parity_spell.initialize( false );
    time.initialize( 0 );
    #line 45 "../code/MigrationGeneral.mpp"
    time_first_move.initialize( time_infinite );
    #line 103 "../code/FertilityDetailed.mpp"
    time_in_parity.initialize( 0 );
    #line 46 "../code/MigrationGeneral.mpp"
    time_last_move.initialize( time_infinite );
    #line 14 "../code/ClockEvents.mpp"
    time_next_birthday.initialize( time_infinite );
    #line 66 "../code/ActorPerson.mpp"
    time_of_birth.initialize( 0.0 );
    #line 50 "../code/MigrationGeneral.mpp"
    time_of_first_immigration.initialize( time_infinite );
    #line 88 "../code/FamilyFirstUnion.mpp"
    union1_group.initialize( U1G_00 );
    #line 88 "../code/ActorPerson.mpp"
    year_of_birth.initialize( 1899 );
    #line 52 "../code/ImmigrationFromScratch.mpp"
    year_of_first_immigration.initialize( 2000 );
    #line 85 "../code/HumanCapitalIndex.mpp"
    years_of_schooling.initialize( 0 );
    #line 37 "../code/EducationPreSchool.mpp"
    years_preschool.initialize( 0 );
    #line 64 "../code/ActorPerson.mpp"
    zzz_om_om_ss_event_om_event.initialize( time_infinite );
}
#line 9167 "C:/Users/Martin/Dropbox/openM++/models/Dynamis-Pop-3-06-ABC/ompp/src/om_definitions.cpp"
void Person::om_initialize_data_members0()
{
    #line 100 "../code/HumanCapitalIndex.mpp"
    adult_survival.initialize( 0.0 );
    age.initialize( 0 );
    #line 95 "../code/FamilyFemalePartnershipStatus.mpp"
    age_last_birth.initialize( 0.0 );
    #line 43 "../code/MigrationGeneral.mpp"
    age_mig.initialize( 0 );
    #line 84 "../code/FamilyFemalePartnershipStatus.mpp"
    age_youngest_child.initialize( 0.0 );
    #line 23 "../code/TablesPopulation.mpp"
    all_year.initialize( 1899 );
    #line 21 "../code/ClockEvents.mpp"
    calendar_year.initialize( 1899 );
    case_seed.initialize( 0.0 );
    #line 109 "../code/FamilyFemalePartnershipStatus.mpp"
    child_agegr.initialize( CA00 );
    #line 88 "../code/FamilyFemalePartnershipStatus.mpp"
    child_agegr_part.initialize( 0 );
    #line 57 "../code/MortalityDetailed.mpp"
    child_mortality.initialize( 0.0 );
    #line 70 "../code/MortalityDetailed.mpp"
    child_mortality_group.initialize( CMG_00 );
    #line 74 "../code/FamilyGeneral.mpp"
    children_in_household.initialize( 0 );
    #line 69 "../code/ActorPerson.mpp"
    creation_type.initialize( CT_START );
    #line 100 "../code/EducationPrimaryTransmission.mpp"
    educ1_group.initialize( E1G_00 );
    #line 97 "../code/EducationPrimaryTransmission.mpp"
    educ_mother.initialize( EOL_LOW );
    #line 97 "../code/EducationPrimaryTracking.mpp"
    educ_one_entry_age.initialize( 5 );
    #line 65 "../code/EducationPrimaryBase.mpp"
    educ_one_fate.initialize( EOL_LOW );
    #line 99 "../code/EducationPrimaryTracking.mpp"
    educ_one_geo.initialize( EOG_OO );
    #line 107 "../code/EducationPrimaryTracking.mpp"
    educ_one_grade.initialize( 1 );
    #line 94 "../code/EducationPrimaryTracking.mpp"
    educ_one_grade_attended.initialize( 0 );
    #line 98 "../code/EducationPrimaryTracking.mpp"
    educ_one_grade_fate.initialize( 1 );
    #line 95 "../code/EducationPrimaryTracking.mpp"
    educ_one_grade_passed.initialize( 0 );
    #line 100 "../code/EducationPrimaryTracking.mpp"
    educ_one_group.initialize( E1G_OO );
    #line 111 "../code/EducationPrimaryTracking.mpp"
    educ_one_level.initialize( EOL_LOW );
    #line 42 "../code/EducationPrimaryPlanning.mpp"
    educ_one_required_rooms.initialize( 0.0 );
    #line 38 "../code/EducationPrimaryPlanning.mpp"
    educ_one_required_teachers.initialize( 0.0 );
    #line 96 "../code/EducationPrimaryTracking.mpp"
    educ_one_status.initialize( EOS_NEVER );
    #line 93 "../code/EducationPrimaryTracking.mpp"
    educ_one_to_process.initialize( false );
    #line 107 "../code/EducationSecondaryBase.mpp"
    educ_two_delay.initialize( 0 );
    #line 118 "../code/EducationSecondaryBase.mpp"
    educ_two_geo.initialize( ETG_OO );
    #line 116 "../code/EducationSecondaryBase.mpp"
    educ_two_grade_attended.initialize( 0 );
    #line 117 "../code/EducationSecondaryBase.mpp"
    educ_two_grade_passed.initialize( 0 );
    #line 119 "../code/EducationSecondaryBase.mpp"
    educ_two_group.initialize( E2G_OO );
    #line 112 "../code/EducationSecondaryBase.mpp"
    educ_two_level.initialize( ETL_NEVER );
    #line 109 "../code/EducationSecondaryBase.mpp"
    educ_two_status.initialize( ETS_NEVER );
    #line 108 "../code/EducationSecondaryBase.mpp"
    educ_two_to_process.initialize( false );
    entity_id.initialize( 0 );
    #line 42 "../code/Ethnicity.mpp"
    ethnicity.initialize( ETHNO_00 );
    #line 52 "../code/ChildVaccination.mpp"
    ethnicity_short.initialize( ES_00 );
    events.initialize( 0 );
    #line 76 "../code/ActorPerson.mpp"
    ever_resident.initialize( false );
    #line 90 "../code/FamilyFirstUnion.mpp"
    ever_union.initialize( false );
    #line 71 "../code/FamilyGeneral.mpp"
    family_role.initialize( FR_HEAD );
    #line 81 "../code/FamilyPartnerMatching.mpp"
    female_spouse_age.initialize( 10 );
    #line 49 "../code/FertilityGeneral.mpp"
    fertile_age.initialize( 12 );
    #line 48 "../code/MigrationGeneral.mpp"
    first_move_done.initialize( false );
    #line 72 "../code/ActorPerson.mpp"
    geo.initialize( GEO_00 );
    #line 71 "../code/ActorPerson.mpp"
    geo_birth.initialize( GEO_00 );
    #line 55 "../code/MigrationGeneral.mpp"
    geo_nat.initialize( GEON_00 );
    #line 73 "../code/ActorPerson.mpp"
    geo_prev.initialize( GEO_00 );
    #line 53 "../code/MigrationGeneral.mpp"
    geo_want_to_move.initialize( GEO_00 );
    #line 54 "../code/ChildVaccination.mpp"
    got_prenat_care.initialize( GPC_NO );
    #line 25 "../code/TablesEducation.mpp"
    has_passed_primary.initialize( false );
    #line 83 "../code/FamilyPartnerMatching.mpp"
    has_spouse.initialize( false );
    #line 82 "../code/HumanCapitalIndex.mpp"
    in_hci_sample.initialize( false );
    #line 18 "../code/TablesEducation.mpp"
    in_projected_time.initialize( false );
    #line 34 "../code/_ContextABC.mpp"
    in_sel_years.initialize( false );
    #line 34 "../code/TablesPopulation.mpp"
    in_selected_year.initialize( false );
    #line 106 "../code/HumanCapitalIndex.mpp"
    ind_hci.initialize( 0.0 );
    #line 13 "../code/ClockEvents.mpp"
    integer_age.initialize( 0 );
    #line 22 "../code/TablesEducation.mpp"
    is_aded0.initialize( false );
    #line 23 "../code/TablesEducation.mpp"
    is_aded1.initialize( false );
    #line 24 "../code/TablesEducation.mpp"
    is_aded2.initialize( false );
    #line 103 "../code/HumanCapitalIndex.mpp"
    is_adult.initialize( false );
    #line 75 "../code/ActorPerson.mpp"
    is_alive.initialize( false );
    #line 116 "../code/FamilyFemalePartnershipStatus.mpp"
    is_blocked_from_marriage.initialize( false );
    #line 20 "../code/TablesEducation.mpp"
    is_child.initialize( false );
    #line 103 "../code/EducationPrimaryTracking.mpp"
    is_educ_one_student.initialize( false );
    #line 44 "../code/FertilityGeneral.mpp"
    is_fertile.initialize( false );
    #line 53 "../code/ChildVaccination.mpp"
    is_immunized.initialize( false );
    #line 42 "../code/MortalityGeneral.mpp"
    is_mortal.initialize( false );
    #line 21 "../code/TablesEducation.mpp"
    is_old.initialize( false );
    #line 77 "../code/ActorPerson.mpp"
    is_ready_for_birthtables.initialize( false );
    #line 79 "../code/ActorPerson.mpp"
    is_resident.initialize( false );
    #line 30 "../code/Stunting.mpp"
    is_stunted.initialize( false );
    #line 21 "../code/FamilyGeneral.mpp"
    lBioFather.initialize( nullptr );
    #line 22 "../code/FamilyGeneral.mpp"
    lBioMother.initialize( nullptr );
    #line 22 "../code/ActorCalibrator.mpp"
    lCalibrator.initialize( nullptr );
    #line 24 "../code/FamilyGeneral.mpp"
    lHHFather.initialize( nullptr );
    #line 25 "../code/FamilyGeneral.mpp"
    lHHMother.initialize( nullptr );
    #line 27 "../code/FamilyGeneral.mpp"
    lSpouse.initialize( nullptr );
    #line 14 "../code/ActorStartpopValues.mpp"
    lStartValues.initialize( nullptr );
    #line 91 "../code/FamilyFemalePartnershipStatus.mpp"
    lives_with_dependent_child.initialize( false );
    #line 78 "../code/FamilyPartnerMatching.mpp"
    male_age.initialize( 15 );
    #line 75 "../code/FamilyPartnerMatching.mpp"
    male_spouse_age.initialize( 15 );
    #line 21 "../code/FamilyGeneral.mpp"
    mlBioFatherChildren.initialize( nullptr );
    #line 22 "../code/FamilyGeneral.mpp"
    mlBioMotherChildren.initialize( nullptr );
    #line 24 "../code/FamilyGeneral.mpp"
    mlHHFatherChildren.initialize( nullptr );
    #line 25 "../code/FamilyGeneral.mpp"
    mlHHMotherChildren.initialize( nullptr );
    #line 102 "../code/FamilyFemalePartnershipStatus.mpp"
    moth_agegr.initialize( CMA20 );
    #line 99 "../code/FamilyFemalePartnershipStatus.mpp"
    moth_agegr_part.initialize( 0 );
    #line 81 "../code/MortalityDetailed.mpp"
    mother_age_at_birth.initialize( 0.0 );
    #line 29 "../code/ImmigrationBackMigration.mpp"
    om_BackMigrationEvent_om_event.initialize( time_infinite );
    #line 15 "../code/ClockEvents.mpp"
    om_BirthdayEvent_om_event.initialize( time_infinite );
    #line 52 "../code/MortalityGeneral.mpp"
    om_DeathAtMaxLifespanEvent_om_event.initialize( time_infinite );
    #line 37 "../code/EmigrationBase.mpp"
    om_EmigrationEvent_om_event.initialize( time_infinite );
    #line 36 "../code/FertilityBase.mpp"
    om_FertilityBaseEvent_om_event.initialize( time_infinite );
    #line 105 "../code/FertilityDetailed.mpp"
    om_FertilityDetailedEvent_om_event.initialize( time_infinite );
    #line 32 "../code/ImmigrationFromPool.mpp"
    om_FirstImmigrationFromPoolEvent_om_event.initialize( time_infinite );
    #line 64 "../code/ImmigrationFromScratch.mpp"
    om_FirstImmigrationFromScratchEvent_om_event.initialize( time_infinite );
    #line 91 "../code/FamilyFirstUnion.mpp"
    om_FirstUnionFormationEvent_om_event.initialize( time_infinite );
    #line 27 "../code/FamilyLeavingHome.mpp"
    om_LeavingHomeEvent_om_event.initialize( time_infinite );
    #line 30 "../code/MigrationBase.mpp"
    om_MigrationEvent_om_event.initialize( time_infinite );
    #line 33 "../code/MortalityBase.mpp"
    om_MortalityBaseEvent_om_event.initialize( time_infinite );
    #line 82 "../code/MortalityDetailed.mpp"
    om_MortalityDetailedEvent_om_event.initialize( time_infinite );
    om_PopPyramidByEduc_in_om_duration_FOR_educ_one_level_X_EOL_HIGH = 0;
    om_PopPyramidByEduc_in_om_duration_FOR_educ_one_level_X_EOL_LOW = 0;
    om_PopPyramidByEduc_in_om_duration_FOR_educ_one_level_X_EOL_MEDIUM = 0;
    #line 82 "../code/ActorPerson.mpp"
    om_SetAliveEvent_om_event.initialize( time_infinite );
    #line 40 "../code/EducationPreSchool.mpp"
    om_SetPreschoolYearsEvent_om_event.initialize( time_infinite );
    om_TabChildVaccination_in_om_duration = 0;
    om_TabChildVaccination_in_om_duration_FOR_is_immunized_X_true = 0;
    om_TabEduc15ByDistrictBirth_in_om_duration = 0;
    om_TabEduc15ByDistrictBirth_in_om_duration_FOR_educ_one_fate_X_EOL_HIGH = 0;
    om_TabEduc15ByDistrictBirth_in_om_duration_FOR_educ_one_fate_X_EOL_LOW = 0;
    om_TabEduc15ByDistrictBirth_in_om_duration_FOR_educ_one_fate_X_EOL_MEDIUM = 0;
    om_TabEduc15ByDistrict_in_om_duration = 0;
    om_TabEduc15ByDistrict_in_om_duration_FOR_educ_one_fate_X_EOL_HIGH = 0;
    om_TabEduc15ByDistrict_in_om_duration_FOR_educ_one_fate_X_EOL_LOW = 0;
    om_TabEduc15ByDistrict_in_om_duration_FOR_educ_one_fate_X_EOL_MEDIUM = 0;
    om_TabHCIDistrict_in_om_transitions_FOR_integer_age_X_14_X_15 = 0;
    om_TabHCIDistrict_in_om_transitions_FOR_is_alive_X_true_X_false = 0;
    om_TabHCIDistrict_in_om_transitions_FOR_survived_early_years_X_false_X_true = 0;
    om_TabHCIDistrict_in_om_value_at_transitions_FOR_is_alive_X_true_X_adult_survival_X_false = 0;
    om_TabHCIDistrict_in_om_value_at_transitions_FOR_is_alive_X_true_X_ind_hci_X_false = 0;
    om_TabHCIDistrict_in_om_value_at_transitions_FOR_is_alive_X_true_X_is_stunted_X_false = 0;
    om_TabHCIDistrict_in_om_value_at_transitions_FOR_is_alive_X_true_X_quality_of_schooling_X_false = 0;
    om_TabHCIDistrict_in_om_value_at_transitions_FOR_is_alive_X_true_X_survived_early_years_X_false = 0;
    om_TabHCIDistrict_in_om_value_at_transitions_FOR_is_alive_X_true_X_years_of_schooling_X_false = 0;
    om_TabImmunizationChildren_in_om_duration = 0;
    om_TabImmunizationChildren_in_om_duration_FOR_is_immunized_X_true = 0;
    om_TabPopProvAgeEducSex_in_om_duration_FOR_is_aded0_X_true = 0;
    om_TabPopProvAgeEducSex_in_om_duration_FOR_is_aded1_X_true = 0;
    om_TabPopProvAgeEducSex_in_om_duration_FOR_is_aded2_X_true = 0;
    om_TabPopProvAgeEducSex_in_om_duration_FOR_is_child_X_true = 0;
    om_TabPopProvAgeEducSex_in_om_duration_FOR_is_old_X_true = 0;
    om_TabPrenatCare_in_om_duration = 0;
    om_TabPrenatCare_in_om_duration_FOR_got_prenat_care_X_GPC_YES = 0;
    om_TabPrimSchoolEntries_in_om_entrances_FOR_educ_one_grade_attended_X_1 = 0;
    om_TabPrimSchoolGraduations_in_om_entrances_FOR_has_passed_primary_X_true = 0;
    om_TabPrimSchoolOutOfSchool9to11_in_om_duration = 0;
    om_TabPrimSchoolOutOfSchool9to11_in_om_duration_FOR_tab_out_of_primary_X_true = 0;
    om_TabSchool2AttainmentsTab_in_om_duration = 0;
    om_TabSchool2AttainmentsTab_in_om_duration_FOR_educ_two_level_X_ETL_GRADUATE = 0;
    om_TabSchool2AttainmentsTab_in_om_duration_FOR_educ_two_level_X_ETL_INCOMPLETE = 0;
    om_TabSchool2AttainmentsTab_in_om_duration_FOR_educ_two_level_X_ETL_NEVER = 0;
    om_active_spell_duration_FOR_this_parity_spell_X_true.initialize( 0 );
    om_aggregate_FOR_ethnicity_X_ETHNICITY_SHORT.initialize( ES_00 );
    om_aggregate_FOR_geo_X_GEO_NAT.initialize( GEON_00 );
    om_aggregate_FOR_geo_X_REGION_INT.initialize( REGI_00 );
    om_aggregate_FOR_geo_birth_X_GEO_NAT.initialize( GEON_00 );
    om_aggregate_FOR_geo_birth_X_REGION_INT.initialize( REGI_00 );
    om_aggregate_FOR_region_birth_X_REGION_NAT.initialize( REGN_00 );
    om_aggregate_FOR_region_int_X_REGION_NAT.initialize( REGN_00 );
    om_aia_0.initialize( false );
    #line 76 "../code/TablesEducation.mpp"
    om_aia_1.initialize( false );
    om_aia_10.initialize( false );
    om_aia_11.initialize( false );
    om_aia_12.initialize( false );
    #line 115 "../code/TablesEducation.mpp"
    om_aia_13.initialize( false );
    #line 126 "../code/TablesEducation.mpp"
    om_aia_14.initialize( false );
    #line 139 "../code/TablesEducation.mpp"
    om_aia_15.initialize( false );
    om_aia_16.initialize( false );
    om_aia_17.initialize( false );
    om_aia_18.initialize( false );
    om_aia_19.initialize( false );
    om_aia_2.initialize( false );
    om_aia_20.initialize( false );
    #line 154 "../code/TablesEducation.mpp"
    om_aia_21.initialize( false );
    #line 165 "../code/TablesEducation.mpp"
    om_aia_22.initialize( false );
    #line 211 "../code/TablesEducation.mpp"
    om_aia_23.initialize( false );
    om_aia_24.initialize( false );
    #line 221 "../code/TablesEducation.mpp"
    om_aia_25.initialize( false );
    #line 231 "../code/TablesEducation.mpp"
    om_aia_26.initialize( false );
    om_aia_27.initialize( false );
    om_aia_28.initialize( false );
    om_aia_29.initialize( false );
    om_aia_3.initialize( false );
    #line 13 "../code/TablesFamily.mpp"
    om_aia_30.initialize( false );
    om_aia_31.initialize( false );
    om_aia_32.initialize( false );
    #line 17 "../code/TablesHumanCapital.mpp"
    om_aia_33.initialize( false );
    #line 45 "../code/TablesPopulation.mpp"
    om_aia_34.initialize( false );
    #line 65 "../code/TablesPopulation.mpp"
    om_aia_35.initialize( false );
    #line 17 "../code/TablesStunting.mpp"
    om_aia_36.initialize( false );
    #line 19 "../code/TablesVaccination.mpp"
    om_aia_37.initialize( false );
    om_aia_38.initialize( false );
    om_aia_39.initialize( false );
    om_aia_4.initialize( false );
    #line 46 "../code/TablesVaccination.mpp"
    om_aia_40.initialize( false );
    #line 88 "../code/TablesEducation.mpp"
    om_aia_5.initialize( false );
    om_aia_6.initialize( false );
    om_aia_7.initialize( false );
    om_aia_8.initialize( false );
    #line 101 "../code/TablesEducation.mpp"
    om_aia_9.initialize( false );
    om_asAllFertilePersonsForFertilityAlignmentByAge_cell = 0;
    #line 27 "../code/FertilityDetailed.mpp"
    om_asAllFertilePersonsForFertilityAlignmentByAge_filter.initialize( false );
    om_asAllFertilePersonsForFertilityAlignment_cell = 0;
    #line 31 "../code/FertilityDetailed.mpp"
    om_asAllFertilePersonsForFertilityAlignment_filter.initialize( false );
    om_asAllPerson_cell = 0;
    #line 40 "../code/ActorPerson.mpp"
    om_asAllPerson_filter.initialize( false );
    om_asAvailableMaleByTypeImmiScratch_cell = 0;
    #line 32 "../code/FamilyPartnerMatching.mpp"
    om_asAvailableMaleByTypeImmiScratch_filter.initialize( false );
    om_asAvailableMaleByType_cell = 0;
    #line 18 "../code/FamilyPartnerMatching.mpp"
    om_asAvailableMaleByType_filter.initialize( false );
    om_asAvailableMaleImmiScratch_cell = 0;
    #line 28 "../code/FamilyPartnerMatching.mpp"
    om_asAvailableMaleImmiScratch_filter.initialize( false );
    om_asAvailableMale_cell = 0;
    #line 14 "../code/FamilyPartnerMatching.mpp"
    om_asAvailableMale_filter.initialize( false );
    om_asFemaleInUnionByAgeAndPartnerAgeImmiScratch_cell = 0;
    #line 36 "../code/FamilyPartnerMatching.mpp"
    om_asFemaleInUnionByAgeAndPartnerAgeImmiScratch_filter.initialize( false );
    om_asFemaleInUnionByAgeAndPartnerAge_cell = 0;
    #line 22 "../code/FamilyPartnerMatching.mpp"
    om_asFemaleInUnionByAgeAndPartnerAge_filter.initialize( false );
    om_asPotentialImmigrantMothers_cell = 0;
    #line 9 "../code/ImmigrationFromScratch.mpp"
    om_asPotentialImmigrantMothers_filter.initialize( false );
    om_asPotentialSchoolOneStudentToProcess_cell = 0;
    #line 28 "../code/EducationPrimaryTracking.mpp"
    om_asPotentialSchoolOneStudentToProcess_filter.initialize( false );
    om_asPotentialSchoolOneStudent_cell = 0;
    #line 25 "../code/EducationPrimaryTracking.mpp"
    om_asPotentialSchoolOneStudent_filter.initialize( false );
    om_asPotentialSchoolTwoStudentToProcess_cell = 0;
    #line 29 "../code/EducationSecondaryBase.mpp"
    om_asPotentialSchoolTwoStudentToProcess_filter.initialize( false );
    om_asPotentialSchoolTwoStudent_cell = 0;
    #line 26 "../code/EducationSecondaryBase.mpp"
    om_asPotentialSchoolTwoStudent_filter.initialize( false );
    om_asResidentBabies_cell = 0;
    #line 18 "../code/ChildVaccination.mpp"
    om_asResidentBabies_filter.initialize( false );
    om_asResidentsAge0SexGeo_cell = 0;
    #line 27 "../code/EducationPrimaryBase.mpp"
    om_asResidentsAge0SexGeo_filter.initialize( false );
    om_asResidentsAge0Sex_cell = 0;
    #line 30 "../code/EducationPrimaryBase.mpp"
    om_asResidentsAge0Sex_filter.initialize( false );
    om_asSimBornAge0_cell = 0;
    #line 35 "../code/EducationPrimaryTransmission.mpp"
    om_asSimBornAge0_filter.initialize( false );
    om_asWantToMove_cell = 0;
    #line 11 "../code/MigrationGeneral.mpp"
    om_asWantToMove_filter.initialize( false );
    om_asWomenNoChildren_cell = 0;
    #line 27 "../code/FamilyFemalePartnershipStatus.mpp"
    om_asWomenNoChildren_filter.initialize( false );
    om_asWomenWithChildren_cell = 0;
    #line 22 "../code/FamilyFemalePartnershipStatus.mpp"
    om_asWomenWithChildren_filter.initialize( false );
    om_duration.initialize( 0 );
    om_duration_FOR_educ_one_fate_X_EOL_HIGH.initialize( 0 );
    om_duration_FOR_educ_one_fate_X_EOL_LOW.initialize( 0 );
    om_duration_FOR_educ_one_fate_X_EOL_MEDIUM.initialize( 0 );
    om_duration_FOR_educ_one_level_X_EOL_HIGH.initialize( 0 );
    om_duration_FOR_educ_one_level_X_EOL_LOW.initialize( 0 );
    om_duration_FOR_educ_one_level_X_EOL_MEDIUM.initialize( 0 );
    om_duration_FOR_educ_two_level_X_ETL_GRADUATE.initialize( 0 );
    om_duration_FOR_educ_two_level_X_ETL_INCOMPLETE.initialize( 0 );
    om_duration_FOR_educ_two_level_X_ETL_NEVER.initialize( 0 );
    om_duration_FOR_ever_union_X_true.initialize( 0 );
    om_duration_FOR_got_prenat_care_X_GPC_YES.initialize( 0 );
    om_duration_FOR_has_spouse_X_true.initialize( 0 );
    om_duration_FOR_is_aded0_X_true.initialize( 0 );
    om_duration_FOR_is_aded1_X_true.initialize( 0 );
    om_duration_FOR_is_aded2_X_true.initialize( 0 );
    om_duration_FOR_is_child_X_true.initialize( 0 );
    om_duration_FOR_is_immunized_X_true.initialize( 0 );
    om_duration_FOR_is_old_X_true.initialize( 0 );
    om_duration_FOR_tab_out_of_primary_X_true.initialize( 0 );
    om_duration_FOR_years_preschool_X_0.initialize( 0 );
    om_duration_FOR_years_preschool_X_1.initialize( 0 );
    om_duration_FOR_years_preschool_X_2.initialize( 0 );
    om_entrances_FOR_educ_one_grade_attended_X_1.initialize( 0 );
    om_entrances_FOR_has_passed_primary_X_true.initialize( 0 );
    om_mlHHFatherChildren_count.initialize( 0 );
    om_mlHHFatherChildren_sum_over_is_alive.initialize( 0 );
    om_mlHHMotherChildren_count.initialize( 0 );
    om_mlHHMotherChildren_min_over_integer_age.initialize( 0 );
    om_mlHHMotherChildren_sum_over_is_alive.initialize( 0 );
    om_self_scheduling_split_FOR_age_X_AGE_MIG_PART.initialize( 0 );
    om_self_scheduling_split_FOR_om_active_spell_duration_FOR_this_parity_spell_X_true_X_DUR_TIME_IN_PARITY.initialize( 0 );
    om_split_FOR_age_last_birth_X_MOTH_AGEGR_PART.initialize( 0 );
    om_split_FOR_age_youngest_child_X_CHILD_AGEGR_PART.initialize( 0 );
    om_split_FOR_integer_age_X_TAB_AGEC5.initialize( 0 );
    om_ss_time_om_self_scheduling_split_FOR_age_X_AGE_MIG_PART = 0;
    om_ss_time_om_self_scheduling_split_FOR_om_active_spell_duration_FOR_this_parity_spell_X_true_X_DUR_TIME_IN_PARITY = 0;
    om_ss_time_om_trigger_changes_FOR_calendar_year = 0;
    om_ss_time_om_trigger_changes_FOR_geo = 0;
    om_ss_time_om_trigger_entrances_FOR_is_ready_for_birthtables_X_true = 0;
    om_tabBirthsYearPlace_in_om_transitions_FOR_is_alive_X_false_X_true = 0;
    om_tabEducationFateGeobirYob_in_om_duration = 0;
    om_tabEducationFateGeobirYob_in_om_duration_FOR_educ_one_fate_X_EOL_HIGH = 0;
    om_tabEducationFateGeobirYob_in_om_duration_FOR_educ_one_fate_X_EOL_LOW = 0;
    om_tabEducationFateGeobirYob_in_om_duration_FOR_educ_one_fate_X_EOL_MEDIUM = 0;
    om_tabHCI_in_om_transitions_FOR_integer_age_X_14_X_15 = 0;
    om_tabHCI_in_om_transitions_FOR_is_alive_X_true_X_false = 0;
    om_tabHCI_in_om_transitions_FOR_survived_early_years_X_false_X_true = 0;
    om_tabHCI_in_om_value_at_transitions_FOR_is_alive_X_true_X_adult_survival_X_false = 0;
    om_tabHCI_in_om_value_at_transitions_FOR_is_alive_X_true_X_ind_hci_X_false = 0;
    om_tabHCI_in_om_value_at_transitions_FOR_is_alive_X_true_X_is_stunted_X_false = 0;
    om_tabHCI_in_om_value_at_transitions_FOR_is_alive_X_true_X_quality_of_schooling_X_false = 0;
    om_tabHCI_in_om_value_at_transitions_FOR_is_alive_X_true_X_survived_early_years_X_false = 0;
    om_tabHCI_in_om_value_at_transitions_FOR_is_alive_X_true_X_years_of_schooling_X_false = 0;
    om_tabHavingSpouse_in_om_duration = 0;
    om_tabHavingSpouse_in_om_duration_FOR_ever_union_X_true = 0;
    om_tabHavingSpouse_in_om_duration_FOR_has_spouse_X_true = 0;
    om_tabMigrationOriginDestination_in_is_alive = false;
    om_tabPopulationYearPlace_in_om_duration = 0;
    om_tabPreSchool_in_om_duration = 0;
    om_tabPreSchool_in_om_duration_FOR_years_preschool_X_0 = 0;
    om_tabPreSchool_in_om_duration_FOR_years_preschool_X_1 = 0;
    om_tabPreSchool_in_om_duration_FOR_years_preschool_X_2 = 0;
    om_tabStuntingSexRegMotherYob_in_is_stunted = false;
    om_tabStuntingSexRegYob_in_is_stunted = false;
    om_transitions_FOR_integer_age_X_14_X_15.initialize( 0 );
    om_transitions_FOR_is_alive_X_false_X_true.initialize( 0 );
    om_transitions_FOR_is_alive_X_true_X_false.initialize( 0 );
    om_transitions_FOR_survived_early_years_X_false_X_true.initialize( 0 );
    om_trigger_changes_FOR_calendar_year.initialize( false );
    om_trigger_changes_FOR_geo.initialize( false );
    om_trigger_entrances_FOR_is_ready_for_birthtables_X_true.initialize( false );
    om_value_at_transitions_FOR_is_alive_X_true_X_adult_survival_X_false.initialize( 0 );
    om_value_at_transitions_FOR_is_alive_X_true_X_ind_hci_X_false.initialize( 0 );
    om_value_at_transitions_FOR_is_alive_X_true_X_is_stunted_X_false.initialize( 0 );
    om_value_at_transitions_FOR_is_alive_X_true_X_quality_of_schooling_X_false.initialize( 0 );
    om_value_at_transitions_FOR_is_alive_X_true_X_survived_early_years_X_false.initialize( 0 );
    om_value_at_transitions_FOR_is_alive_X_true_X_years_of_schooling_X_false.initialize( 0 );
    #line 101 "../code/FertilityDetailed.mpp"
    parity.initialize( 0 );
    #line 39 "../code/EducationPreSchool.mpp"
    preschool_is_decided.initialize( false );
    #line 91 "../code/HumanCapitalIndex.mpp"
    quality_adjusted_schooling.initialize( 0.0 );
    #line 88 "../code/HumanCapitalIndex.mpp"
    quality_of_schooling.initialize( 0.0 );
    #line 81 "../code/ActorPerson.mpp"
    ready_to_set_alive.initialize( false );
    #line 59 "../code/MigrationGeneral.mpp"
    region_birth.initialize( REGI_00 );
    #line 57 "../code/MigrationGeneral.mpp"
    region_int.initialize( REGI_00 );
    #line 58 "../code/MigrationGeneral.mpp"
    region_nat.initialize( REGN_00 );
    #line 39 "../code/_ContextABC.mpp"
    sel_years.initialize( TSY_2000 );
    #line 27 "../code/TablesPopulation.mpp"
    selected_year10.initialize( SY00 );
    #line 67 "../code/ActorPerson.mpp"
    sex.initialize( FEMALE );
    #line 24 "../code/TablesPopulation.mpp"
    sim_year.initialize( 2000 );
    #line 86 "../code/FamilyPartnerMatching.mpp"
    spouse_group.initialize( SMG_00 );
    #line 97 "../code/HumanCapitalIndex.mpp"
    survived_early_years.initialize( false );
    #line 28 "../code/TablesEducation.mpp"
    tab_out_of_primary.initialize( false );
    #line 19 "../code/TablesEducation.mpp"
    tab_sim_yob.initialize( 2000 );
    #line 54 "../code/FertilityGeneral.mpp"
    this_parity_spell.initialize( false );
    time.initialize( 0 );
    #line 45 "../code/MigrationGeneral.mpp"
    time_first_move.initialize( 0 );
    #line 103 "../code/FertilityDetailed.mpp"
    time_in_parity.initialize( 0 );
    #line 46 "../code/MigrationGeneral.mpp"
    time_last_move.initialize( 0 );
    #line 14 "../code/ClockEvents.mpp"
    time_next_birthday.initialize( 0 );
    #line 66 "../code/ActorPerson.mpp"
    time_of_birth.initialize( 0 );
    #line 50 "../code/MigrationGeneral.mpp"
    time_of_first_immigration.initialize( 0 );
    #line 88 "../code/FamilyFirstUnion.mpp"
    union1_group.initialize( U1G_00 );
    #line 88 "../code/ActorPerson.mpp"
    year_of_birth.initialize( 1899 );
    #line 52 "../code/ImmigrationFromScratch.mpp"
    year_of_first_immigration.initialize( 2000 );
    #line 85 "../code/HumanCapitalIndex.mpp"
    years_of_schooling.initialize( 0 );
    #line 37 "../code/EducationPreSchool.mpp"
    years_preschool.initialize( 0 );
    #line 64 "../code/ActorPerson.mpp"
    zzz_om_om_ss_event_om_event.initialize( time_infinite );
}
#line 9689 "C:/Users/Martin/Dropbox/openM++/models/Dynamis-Pop-3-06-ABC/ompp/src/om_definitions.cpp"
void Person::om_initialize_derived_attributes()
{

    // Code Injection: group=5, injector=aggregate(ethnicity, ETHNICITY_SHORT)
    {
        // Set initial value based on dependent attribute
        om_aggregate_FOR_ethnicity_X_ETHNICITY_SHORT.set(om_aggregation_ETHNICITY_om_ETHNICITY_SHORT.find(ethnicity)->second);
    }

    // Code Injection: group=5, injector=aggregate(geo, GEO_NAT)
    {
        // Set initial value based on dependent attribute
        om_aggregate_FOR_geo_X_GEO_NAT.set(om_aggregation_GEO_om_GEO_NAT.find(geo)->second);
    }

    // Code Injection: group=5, injector=aggregate(geo, REGION_INT)
    {
        // Set initial value based on dependent attribute
        om_aggregate_FOR_geo_X_REGION_INT.set(om_aggregation_GEO_om_REGION_INT.find(geo)->second);
    }

    // Code Injection: group=5, injector=aggregate(geo_birth, GEO_NAT)
    {
        // Set initial value based on dependent attribute
        om_aggregate_FOR_geo_birth_X_GEO_NAT.set(om_aggregation_GEO_om_GEO_NAT.find(geo_birth)->second);
    }

    // Code Injection: group=5, injector=aggregate(geo_birth, REGION_INT)
    {
        // Set initial value based on dependent attribute
        om_aggregate_FOR_geo_birth_X_REGION_INT.set(om_aggregation_GEO_om_REGION_INT.find(geo_birth)->second);
    }

    // Code Injection: group=5, injector=aggregate(region_birth, REGION_NAT)
    {
        // Set initial value based on dependent attribute
        om_aggregate_FOR_region_birth_X_REGION_NAT.set(om_aggregation_REGION_INT_om_REGION_NAT.find(region_birth)->second);
    }

    // Code Injection: group=5, injector=aggregate(region_int, REGION_NAT)
    {
        // Set initial value based on dependent attribute
        om_aggregate_FOR_region_int_X_REGION_NAT.set(om_aggregation_REGION_INT_om_REGION_NAT.find(region_int)->second);
    }

    // Code Injection: group=5, injector=split(age_last_birth, MOTH_AGEGR_PART)
    {
        // Set initial value based on dependent attribute
        om_split_FOR_age_last_birth_X_MOTH_AGEGR_PART.set(MOTH_AGEGR_PART::value_to_interval((real)age_last_birth));
    }

    // Code Injection: group=5, injector=split(age_youngest_child, CHILD_AGEGR_PART)
    {
        // Set initial value based on dependent attribute
        om_split_FOR_age_youngest_child_X_CHILD_AGEGR_PART.set(CHILD_AGEGR_PART::value_to_interval((real)age_youngest_child));
    }

    // Code Injection: group=5, injector=split(integer_age, TAB_AGEC5)
    {
        // Set initial value based on dependent attribute
        om_split_FOR_integer_age_X_TAB_AGEC5.set(TAB_AGEC5::value_to_interval((real)integer_age));
    }
}
void Person::om_initialize_entity_sets()
{
    // asAllFertilePersonsForFertilityAlignment
    if (om_asAllFertilePersonsForFertilityAlignment_filter) {
        om_asAllFertilePersonsForFertilityAlignment_update_cell();
        om_asAllFertilePersonsForFertilityAlignment_insert();
    }

    // asAllFertilePersonsForFertilityAlignmentByAge
    if (om_asAllFertilePersonsForFertilityAlignmentByAge_filter) {
        om_asAllFertilePersonsForFertilityAlignmentByAge_update_cell();
        om_asAllFertilePersonsForFertilityAlignmentByAge_insert();
    }

    // asAllPerson
    if (om_asAllPerson_filter) {
        om_asAllPerson_update_cell();
        om_asAllPerson_insert();
    }

    // asAvailableMale
    if (om_asAvailableMale_filter) {
        om_asAvailableMale_update_cell();
        om_asAvailableMale_insert();
    }

    // asAvailableMaleByType
    if (om_asAvailableMaleByType_filter) {
        om_asAvailableMaleByType_update_cell();
        om_asAvailableMaleByType_insert();
    }

    // asAvailableMaleByTypeImmiScratch
    if (om_asAvailableMaleByTypeImmiScratch_filter) {
        om_asAvailableMaleByTypeImmiScratch_update_cell();
        om_asAvailableMaleByTypeImmiScratch_insert();
    }

    // asAvailableMaleImmiScratch
    if (om_asAvailableMaleImmiScratch_filter) {
        om_asAvailableMaleImmiScratch_update_cell();
        om_asAvailableMaleImmiScratch_insert();
    }

    // asFemaleInUnionByAgeAndPartnerAge
    if (om_asFemaleInUnionByAgeAndPartnerAge_filter) {
        om_asFemaleInUnionByAgeAndPartnerAge_update_cell();
        om_asFemaleInUnionByAgeAndPartnerAge_insert();
    }

    // asFemaleInUnionByAgeAndPartnerAgeImmiScratch
    if (om_asFemaleInUnionByAgeAndPartnerAgeImmiScratch_filter) {
        om_asFemaleInUnionByAgeAndPartnerAgeImmiScratch_update_cell();
        om_asFemaleInUnionByAgeAndPartnerAgeImmiScratch_insert();
    }

    // asPotentialImmigrantMothers
    if (om_asPotentialImmigrantMothers_filter) {
        om_asPotentialImmigrantMothers_update_cell();
        om_asPotentialImmigrantMothers_insert();
    }

    // asPotentialSchoolOneStudent
    if (om_asPotentialSchoolOneStudent_filter) {
        om_asPotentialSchoolOneStudent_update_cell();
        om_asPotentialSchoolOneStudent_insert();
    }

    // asPotentialSchoolOneStudentToProcess
    if (om_asPotentialSchoolOneStudentToProcess_filter) {
        om_asPotentialSchoolOneStudentToProcess_update_cell();
        om_asPotentialSchoolOneStudentToProcess_insert();
    }

    // asPotentialSchoolTwoStudent
    if (om_asPotentialSchoolTwoStudent_filter) {
        om_asPotentialSchoolTwoStudent_update_cell();
        om_asPotentialSchoolTwoStudent_insert();
    }

    // asPotentialSchoolTwoStudentToProcess
    if (om_asPotentialSchoolTwoStudentToProcess_filter) {
        om_asPotentialSchoolTwoStudentToProcess_update_cell();
        om_asPotentialSchoolTwoStudentToProcess_insert();
    }

    // asResidentBabies
    if (om_asResidentBabies_filter) {
        om_asResidentBabies_update_cell();
        om_asResidentBabies_insert();
    }

    // asResidentsAge0Sex
    if (om_asResidentsAge0Sex_filter) {
        om_asResidentsAge0Sex_update_cell();
        om_asResidentsAge0Sex_insert();
    }

    // asResidentsAge0SexGeo
    if (om_asResidentsAge0SexGeo_filter) {
        om_asResidentsAge0SexGeo_update_cell();
        om_asResidentsAge0SexGeo_insert();
    }

    // asSimBornAge0
    if (om_asSimBornAge0_filter) {
        om_asSimBornAge0_update_cell();
        om_asSimBornAge0_insert();
    }

    // asWantToMove
    if (om_asWantToMove_filter) {
        om_asWantToMove_update_cell();
        om_asWantToMove_insert();
    }

    // asWomenNoChildren
    if (om_asWomenNoChildren_filter) {
        om_asWomenNoChildren_update_cell();
        om_asWomenNoChildren_insert();
    }

    // asWomenWithChildren
    if (om_asWomenWithChildren_filter) {
        om_asWomenWithChildren_update_cell();
        om_asWomenWithChildren_insert();
    }

}
void Person::om_initialize_events()
{
    om_BackMigrationEvent_om_event.make_dirty();
    om_BirthdayEvent_om_event.make_dirty();
    om_DeathAtMaxLifespanEvent_om_event.make_dirty();
    om_EmigrationEvent_om_event.make_dirty();
    om_FertilityBaseEvent_om_event.make_dirty();
    om_FertilityDetailedEvent_om_event.make_dirty();
    om_FirstImmigrationFromPoolEvent_om_event.make_dirty();
    om_FirstImmigrationFromScratchEvent_om_event.make_dirty();
    om_FirstUnionFormationEvent_om_event.make_dirty();
    om_LeavingHomeEvent_om_event.make_dirty();
    om_MigrationEvent_om_event.make_dirty();
    om_MortalityBaseEvent_om_event.make_dirty();
    om_MortalityDetailedEvent_om_event.make_dirty();
    om_SetAliveEvent_om_event.make_dirty();
    om_SetPreschoolYearsEvent_om_event.make_dirty();
    zzz_om_om_ss_event_om_event.make_dirty();
}
void Person::om_initialize_identity_attributes()
{

    // Code Injection: group=8, injector=age_last_birth
    // Initialize 'age_last_birth' to correct value based on expression.
    age_last_birth_update_identity();

    // Code Injection: group=8, injector=age_mig
    // Initialize 'age_mig' to correct value based on expression.
    age_mig_update_identity();

    // Code Injection: group=8, injector=age_youngest_child
    // Initialize 'age_youngest_child' to correct value based on expression.
    age_youngest_child_update_identity();

    // Code Injection: group=8, injector=all_year
    // Initialize 'all_year' to correct value based on expression.
    all_year_update_identity();

    // Code Injection: group=8, injector=child_agegr
    // Initialize 'child_agegr' to correct value based on expression.
    child_agegr_update_identity();

    // Code Injection: group=8, injector=child_agegr_part
    // Initialize 'child_agegr_part' to correct value based on expression.
    child_agegr_part_update_identity();

    // Code Injection: group=8, injector=child_mortality
    // Initialize 'child_mortality' to correct value based on expression.
    child_mortality_update_identity();

    // Code Injection: group=8, injector=child_mortality_group
    // Initialize 'child_mortality_group' to correct value based on expression.
    child_mortality_group_update_identity();

    // Code Injection: group=8, injector=children_in_household
    // Initialize 'children_in_household' to correct value based on expression.
    children_in_household_update_identity();

    // Code Injection: group=8, injector=educ1_group
    // Initialize 'educ1_group' to correct value based on expression.
    educ1_group_update_identity();

    // Code Injection: group=8, injector=educ_one_grade
    // Initialize 'educ_one_grade' to correct value based on expression.
    educ_one_grade_update_identity();

    // Code Injection: group=8, injector=educ_one_level
    // Initialize 'educ_one_level' to correct value based on expression.
    educ_one_level_update_identity();

    // Code Injection: group=8, injector=educ_one_required_rooms
    // Initialize 'educ_one_required_rooms' to correct value based on expression.
    educ_one_required_rooms_update_identity();

    // Code Injection: group=8, injector=educ_one_required_teachers
    // Initialize 'educ_one_required_teachers' to correct value based on expression.
    educ_one_required_teachers_update_identity();

    // Code Injection: group=8, injector=educ_two_level
    // Initialize 'educ_two_level' to correct value based on expression.
    educ_two_level_update_identity();

    // Code Injection: group=8, injector=ethnicity_short
    // Initialize 'ethnicity_short' to correct value based on expression.
    ethnicity_short_update_identity();

    // Code Injection: group=8, injector=family_role
    // Initialize 'family_role' to correct value based on expression.
    family_role_update_identity();

    // Code Injection: group=8, injector=female_spouse_age
    // Initialize 'female_spouse_age' to correct value based on expression.
    female_spouse_age_update_identity();

    // Code Injection: group=8, injector=fertile_age
    // Initialize 'fertile_age' to correct value based on expression.
    fertile_age_update_identity();

    // Code Injection: group=8, injector=geo_nat
    // Initialize 'geo_nat' to correct value based on expression.
    geo_nat_update_identity();

    // Code Injection: group=8, injector=has_passed_primary
    // Initialize 'has_passed_primary' to correct value based on expression.
    has_passed_primary_update_identity();

    // Code Injection: group=8, injector=has_spouse
    // Initialize 'has_spouse' to correct value based on expression.
    has_spouse_update_identity();

    // Code Injection: group=8, injector=in_hci_sample
    // Initialize 'in_hci_sample' to correct value based on expression.
    in_hci_sample_update_identity();

    // Code Injection: group=8, injector=in_projected_time
    // Initialize 'in_projected_time' to correct value based on expression.
    in_projected_time_update_identity();

    // Code Injection: group=8, injector=in_sel_years
    // Initialize 'in_sel_years' to correct value based on expression.
    in_sel_years_update_identity();

    // Code Injection: group=8, injector=in_selected_year
    // Initialize 'in_selected_year' to correct value based on expression.
    in_selected_year_update_identity();

    // Code Injection: group=8, injector=is_aded0
    // Initialize 'is_aded0' to correct value based on expression.
    is_aded0_update_identity();

    // Code Injection: group=8, injector=is_aded1
    // Initialize 'is_aded1' to correct value based on expression.
    is_aded1_update_identity();

    // Code Injection: group=8, injector=is_aded2
    // Initialize 'is_aded2' to correct value based on expression.
    is_aded2_update_identity();

    // Code Injection: group=8, injector=is_adult
    // Initialize 'is_adult' to correct value based on expression.
    is_adult_update_identity();

    // Code Injection: group=8, injector=is_child
    // Initialize 'is_child' to correct value based on expression.
    is_child_update_identity();

    // Code Injection: group=8, injector=is_educ_one_student
    // Initialize 'is_educ_one_student' to correct value based on expression.
    is_educ_one_student_update_identity();

    // Code Injection: group=8, injector=is_fertile
    // Initialize 'is_fertile' to correct value based on expression.
    is_fertile_update_identity();

    // Code Injection: group=8, injector=is_mortal
    // Initialize 'is_mortal' to correct value based on expression.
    is_mortal_update_identity();

    // Code Injection: group=8, injector=is_old
    // Initialize 'is_old' to correct value based on expression.
    is_old_update_identity();

    // Code Injection: group=8, injector=is_resident
    // Initialize 'is_resident' to correct value based on expression.
    is_resident_update_identity();

    // Code Injection: group=8, injector=lives_with_dependent_child
    // Initialize 'lives_with_dependent_child' to correct value based on expression.
    lives_with_dependent_child_update_identity();

    // Code Injection: group=8, injector=male_age
    // Initialize 'male_age' to correct value based on expression.
    male_age_update_identity();

    // Code Injection: group=8, injector=male_spouse_age
    // Initialize 'male_spouse_age' to correct value based on expression.
    male_spouse_age_update_identity();

    // Code Injection: group=8, injector=moth_agegr
    // Initialize 'moth_agegr' to correct value based on expression.
    moth_agegr_update_identity();

    // Code Injection: group=8, injector=moth_agegr_part
    // Initialize 'moth_agegr_part' to correct value based on expression.
    moth_agegr_part_update_identity();

    // Code Injection: group=8, injector=om_aia_0
    // Initialize 'om_aia_0' to correct value based on expression.
    om_aia_0_update_identity();

    // Code Injection: group=8, injector=om_aia_1
    // Initialize 'om_aia_1' to correct value based on expression.
    om_aia_1_update_identity();

    // Code Injection: group=8, injector=om_aia_10
    // Initialize 'om_aia_10' to correct value based on expression.
    om_aia_10_update_identity();

    // Code Injection: group=8, injector=om_aia_11
    // Initialize 'om_aia_11' to correct value based on expression.
    om_aia_11_update_identity();

    // Code Injection: group=8, injector=om_aia_12
    // Initialize 'om_aia_12' to correct value based on expression.
    om_aia_12_update_identity();

    // Code Injection: group=8, injector=om_aia_13
    // Initialize 'om_aia_13' to correct value based on expression.
    om_aia_13_update_identity();

    // Code Injection: group=8, injector=om_aia_14
    // Initialize 'om_aia_14' to correct value based on expression.
    om_aia_14_update_identity();

    // Code Injection: group=8, injector=om_aia_15
    // Initialize 'om_aia_15' to correct value based on expression.
    om_aia_15_update_identity();

    // Code Injection: group=8, injector=om_aia_16
    // Initialize 'om_aia_16' to correct value based on expression.
    om_aia_16_update_identity();

    // Code Injection: group=8, injector=om_aia_17
    // Initialize 'om_aia_17' to correct value based on expression.
    om_aia_17_update_identity();

    // Code Injection: group=8, injector=om_aia_18
    // Initialize 'om_aia_18' to correct value based on expression.
    om_aia_18_update_identity();

    // Code Injection: group=8, injector=om_aia_19
    // Initialize 'om_aia_19' to correct value based on expression.
    om_aia_19_update_identity();

    // Code Injection: group=8, injector=om_aia_2
    // Initialize 'om_aia_2' to correct value based on expression.
    om_aia_2_update_identity();

    // Code Injection: group=8, injector=om_aia_20
    // Initialize 'om_aia_20' to correct value based on expression.
    om_aia_20_update_identity();

    // Code Injection: group=8, injector=om_aia_21
    // Initialize 'om_aia_21' to correct value based on expression.
    om_aia_21_update_identity();

    // Code Injection: group=8, injector=om_aia_22
    // Initialize 'om_aia_22' to correct value based on expression.
    om_aia_22_update_identity();

    // Code Injection: group=8, injector=om_aia_23
    // Initialize 'om_aia_23' to correct value based on expression.
    om_aia_23_update_identity();

    // Code Injection: group=8, injector=om_aia_24
    // Initialize 'om_aia_24' to correct value based on expression.
    om_aia_24_update_identity();

    // Code Injection: group=8, injector=om_aia_25
    // Initialize 'om_aia_25' to correct value based on expression.
    om_aia_25_update_identity();

    // Code Injection: group=8, injector=om_aia_26
    // Initialize 'om_aia_26' to correct value based on expression.
    om_aia_26_update_identity();

    // Code Injection: group=8, injector=om_aia_27
    // Initialize 'om_aia_27' to correct value based on expression.
    om_aia_27_update_identity();

    // Code Injection: group=8, injector=om_aia_28
    // Initialize 'om_aia_28' to correct value based on expression.
    om_aia_28_update_identity();

    // Code Injection: group=8, injector=om_aia_29
    // Initialize 'om_aia_29' to correct value based on expression.
    om_aia_29_update_identity();

    // Code Injection: group=8, injector=om_aia_3
    // Initialize 'om_aia_3' to correct value based on expression.
    om_aia_3_update_identity();

    // Code Injection: group=8, injector=om_aia_30
    // Initialize 'om_aia_30' to correct value based on expression.
    om_aia_30_update_identity();

    // Code Injection: group=8, injector=om_aia_31
    // Initialize 'om_aia_31' to correct value based on expression.
    om_aia_31_update_identity();

    // Code Injection: group=8, injector=om_aia_32
    // Initialize 'om_aia_32' to correct value based on expression.
    om_aia_32_update_identity();

    // Code Injection: group=8, injector=om_aia_33
    // Initialize 'om_aia_33' to correct value based on expression.
    om_aia_33_update_identity();

    // Code Injection: group=8, injector=om_aia_34
    // Initialize 'om_aia_34' to correct value based on expression.
    om_aia_34_update_identity();

    // Code Injection: group=8, injector=om_aia_35
    // Initialize 'om_aia_35' to correct value based on expression.
    om_aia_35_update_identity();

    // Code Injection: group=8, injector=om_aia_36
    // Initialize 'om_aia_36' to correct value based on expression.
    om_aia_36_update_identity();

    // Code Injection: group=8, injector=om_aia_37
    // Initialize 'om_aia_37' to correct value based on expression.
    om_aia_37_update_identity();

    // Code Injection: group=8, injector=om_aia_38
    // Initialize 'om_aia_38' to correct value based on expression.
    om_aia_38_update_identity();

    // Code Injection: group=8, injector=om_aia_39
    // Initialize 'om_aia_39' to correct value based on expression.
    om_aia_39_update_identity();

    // Code Injection: group=8, injector=om_aia_4
    // Initialize 'om_aia_4' to correct value based on expression.
    om_aia_4_update_identity();

    // Code Injection: group=8, injector=om_aia_40
    // Initialize 'om_aia_40' to correct value based on expression.
    om_aia_40_update_identity();

    // Code Injection: group=8, injector=om_aia_5
    // Initialize 'om_aia_5' to correct value based on expression.
    om_aia_5_update_identity();

    // Code Injection: group=8, injector=om_aia_6
    // Initialize 'om_aia_6' to correct value based on expression.
    om_aia_6_update_identity();

    // Code Injection: group=8, injector=om_aia_7
    // Initialize 'om_aia_7' to correct value based on expression.
    om_aia_7_update_identity();

    // Code Injection: group=8, injector=om_aia_8
    // Initialize 'om_aia_8' to correct value based on expression.
    om_aia_8_update_identity();

    // Code Injection: group=8, injector=om_aia_9
    // Initialize 'om_aia_9' to correct value based on expression.
    om_aia_9_update_identity();

    // Code Injection: group=8, injector=om_asAllFertilePersonsForFertilityAlignmentByAge_filter
    // Initialize 'om_asAllFertilePersonsForFertilityAlignmentByAge_filter' to correct value based on expression.
    om_asAllFertilePersonsForFertilityAlignmentByAge_filter_update_identity();

    // Code Injection: group=8, injector=om_asAllFertilePersonsForFertilityAlignment_filter
    // Initialize 'om_asAllFertilePersonsForFertilityAlignment_filter' to correct value based on expression.
    om_asAllFertilePersonsForFertilityAlignment_filter_update_identity();

    // Code Injection: group=8, injector=om_asAllPerson_filter
    // Initialize 'om_asAllPerson_filter' to correct value based on expression.
    om_asAllPerson_filter_update_identity();

    // Code Injection: group=8, injector=om_asAvailableMaleByTypeImmiScratch_filter
    // Initialize 'om_asAvailableMaleByTypeImmiScratch_filter' to correct value based on expression.
    om_asAvailableMaleByTypeImmiScratch_filter_update_identity();

    // Code Injection: group=8, injector=om_asAvailableMaleByType_filter
    // Initialize 'om_asAvailableMaleByType_filter' to correct value based on expression.
    om_asAvailableMaleByType_filter_update_identity();

    // Code Injection: group=8, injector=om_asAvailableMaleImmiScratch_filter
    // Initialize 'om_asAvailableMaleImmiScratch_filter' to correct value based on expression.
    om_asAvailableMaleImmiScratch_filter_update_identity();

    // Code Injection: group=8, injector=om_asAvailableMale_filter
    // Initialize 'om_asAvailableMale_filter' to correct value based on expression.
    om_asAvailableMale_filter_update_identity();

    // Code Injection: group=8, injector=om_asFemaleInUnionByAgeAndPartnerAgeImmiScratch_filter
    // Initialize 'om_asFemaleInUnionByAgeAndPartnerAgeImmiScratch_filter' to correct value based on expression.
    om_asFemaleInUnionByAgeAndPartnerAgeImmiScratch_filter_update_identity();

    // Code Injection: group=8, injector=om_asFemaleInUnionByAgeAndPartnerAge_filter
    // Initialize 'om_asFemaleInUnionByAgeAndPartnerAge_filter' to correct value based on expression.
    om_asFemaleInUnionByAgeAndPartnerAge_filter_update_identity();

    // Code Injection: group=8, injector=om_asPotentialImmigrantMothers_filter
    // Initialize 'om_asPotentialImmigrantMothers_filter' to correct value based on expression.
    om_asPotentialImmigrantMothers_filter_update_identity();

    // Code Injection: group=8, injector=om_asPotentialSchoolOneStudentToProcess_filter
    // Initialize 'om_asPotentialSchoolOneStudentToProcess_filter' to correct value based on expression.
    om_asPotentialSchoolOneStudentToProcess_filter_update_identity();

    // Code Injection: group=8, injector=om_asPotentialSchoolOneStudent_filter
    // Initialize 'om_asPotentialSchoolOneStudent_filter' to correct value based on expression.
    om_asPotentialSchoolOneStudent_filter_update_identity();

    // Code Injection: group=8, injector=om_asPotentialSchoolTwoStudentToProcess_filter
    // Initialize 'om_asPotentialSchoolTwoStudentToProcess_filter' to correct value based on expression.
    om_asPotentialSchoolTwoStudentToProcess_filter_update_identity();

    // Code Injection: group=8, injector=om_asPotentialSchoolTwoStudent_filter
    // Initialize 'om_asPotentialSchoolTwoStudent_filter' to correct value based on expression.
    om_asPotentialSchoolTwoStudent_filter_update_identity();

    // Code Injection: group=8, injector=om_asResidentBabies_filter
    // Initialize 'om_asResidentBabies_filter' to correct value based on expression.
    om_asResidentBabies_filter_update_identity();

    // Code Injection: group=8, injector=om_asResidentsAge0SexGeo_filter
    // Initialize 'om_asResidentsAge0SexGeo_filter' to correct value based on expression.
    om_asResidentsAge0SexGeo_filter_update_identity();

    // Code Injection: group=8, injector=om_asResidentsAge0Sex_filter
    // Initialize 'om_asResidentsAge0Sex_filter' to correct value based on expression.
    om_asResidentsAge0Sex_filter_update_identity();

    // Code Injection: group=8, injector=om_asSimBornAge0_filter
    // Initialize 'om_asSimBornAge0_filter' to correct value based on expression.
    om_asSimBornAge0_filter_update_identity();

    // Code Injection: group=8, injector=om_asWantToMove_filter
    // Initialize 'om_asWantToMove_filter' to correct value based on expression.
    om_asWantToMove_filter_update_identity();

    // Code Injection: group=8, injector=om_asWomenNoChildren_filter
    // Initialize 'om_asWomenNoChildren_filter' to correct value based on expression.
    om_asWomenNoChildren_filter_update_identity();

    // Code Injection: group=8, injector=om_asWomenWithChildren_filter
    // Initialize 'om_asWomenWithChildren_filter' to correct value based on expression.
    om_asWomenWithChildren_filter_update_identity();

    // Code Injection: group=8, injector=region_birth
    // Initialize 'region_birth' to correct value based on expression.
    region_birth_update_identity();

    // Code Injection: group=8, injector=region_int
    // Initialize 'region_int' to correct value based on expression.
    region_int_update_identity();

    // Code Injection: group=8, injector=region_nat
    // Initialize 'region_nat' to correct value based on expression.
    region_nat_update_identity();

    // Code Injection: group=8, injector=sel_years
    // Initialize 'sel_years' to correct value based on expression.
    sel_years_update_identity();

    // Code Injection: group=8, injector=selected_year10
    // Initialize 'selected_year10' to correct value based on expression.
    selected_year10_update_identity();

    // Code Injection: group=8, injector=sim_year
    // Initialize 'sim_year' to correct value based on expression.
    sim_year_update_identity();

    // Code Injection: group=8, injector=spouse_group
    // Initialize 'spouse_group' to correct value based on expression.
    spouse_group_update_identity();

    // Code Injection: group=8, injector=survived_early_years
    // Initialize 'survived_early_years' to correct value based on expression.
    survived_early_years_update_identity();

    // Code Injection: group=8, injector=tab_out_of_primary
    // Initialize 'tab_out_of_primary' to correct value based on expression.
    tab_out_of_primary_update_identity();

    // Code Injection: group=8, injector=tab_sim_yob
    // Initialize 'tab_sim_yob' to correct value based on expression.
    tab_sim_yob_update_identity();

    // Code Injection: group=8, injector=time_in_parity
    // Initialize 'time_in_parity' to correct value based on expression.
    time_in_parity_update_identity();

    // Code Injection: group=8, injector=union1_group
    // Initialize 'union1_group' to correct value based on expression.
    union1_group_update_identity();

    // Code Injection: group=8, injector=year_of_birth
    // Initialize 'year_of_birth' to correct value based on expression.
    year_of_birth_update_identity();

    // Code Injection: group=8, injector=year_of_first_immigration
    // Initialize 'year_of_first_immigration' to correct value based on expression.
    year_of_first_immigration_update_identity();

    // Code Injection: group=8, injector=years_of_schooling
    // Initialize 'years_of_schooling' to correct value based on expression.
    years_of_schooling_update_identity();
}
void Person::om_initialize_tables()
{
    // PopPyramidByEduc
    if (thePopPyramidByEduc) {
        auto & filter = om_aia_9;
        auto cell = om_PopPyramidByEduc_current_cell();

        auto & incr = om_PopPyramidByEduc_incr;
        incr.set_filter(filter);
        incr.set_cell(cell);
        incr.initialize_increment();
    }

    // TabChildVaccination
    if (theTabChildVaccination) {
        auto & filter = om_aia_40;
        auto cell = om_TabChildVaccination_current_cell();

        auto & incr = om_TabChildVaccination_incr;
        incr.set_filter(filter);
        incr.set_cell(cell);
        incr.initialize_increment();
    }

    // TabEduc15ByDistrict
    if (theTabEduc15ByDistrict) {
        auto & filter = om_aia_22;
        auto cell = om_TabEduc15ByDistrict_current_cell();

        auto & incr = om_TabEduc15ByDistrict_incr;
        incr.set_filter(filter);
        incr.set_cell(cell);
        incr.initialize_increment();
    }

    // TabEduc15ByDistrictBirth
    if (theTabEduc15ByDistrictBirth) {
        auto & filter = om_aia_22;
        auto cell = om_TabEduc15ByDistrictBirth_current_cell();

        auto & incr = om_TabEduc15ByDistrictBirth_incr;
        incr.set_filter(filter);
        incr.set_cell(cell);
        incr.initialize_increment();
    }

    // TabEducFateByGroup
    if (theTabEducFateByGroup) {
        auto & filter = om_aia_13;
        auto cell = om_TabEducFateByGroup_current_cell();

        auto & incr = om_TabEducFateByGroup_incr;
        incr.set_filter(filter);
        incr.set_cell(cell);
        incr.initialize_increment();
    }

    // TabEducFateDistrYob
    if (theTabEducFateDistrYob) {
        auto & filter = om_aia_21;
        auto cell = om_TabEducFateDistrYob_current_cell();

        auto & incr = om_TabEducFateDistrYob_incr;
        incr.set_filter(filter);
        incr.set_cell(cell);
        incr.initialize_increment();
    }

    // TabHCIDistrict
    if (theTabHCIDistrict) {
        auto & filter = om_aia_33;
        auto cell = om_TabHCIDistrict_current_cell();

        auto & incr = om_TabHCIDistrict_incr;
        incr.set_filter(filter);
        incr.set_cell(cell);
        incr.initialize_increment();
    }

    // TabImmunizationChildren
    if (theTabImmunizationChildren) {
        auto & filter = om_aia_37;
        auto cell = om_TabImmunizationChildren_current_cell();

        auto & incr = om_TabImmunizationChildren_incr;
        incr.set_filter(filter);
        incr.set_cell(cell);
        incr.initialize_increment();
    }

    // TabPopProvAgeEducSex
    if (theTabPopProvAgeEducSex) {
        auto & filter = om_aia_15;
        auto cell = om_TabPopProvAgeEducSex_current_cell();

        auto & incr = om_TabPopProvAgeEducSex_incr;
        incr.set_filter(filter);
        incr.set_cell(cell);
        incr.initialize_increment();
    }

    // TabPrenatCare
    if (theTabPrenatCare) {
        auto & filter = om_aia_37;
        auto cell = om_TabPrenatCare_current_cell();

        auto & incr = om_TabPrenatCare_incr;
        incr.set_filter(filter);
        incr.set_cell(cell);
        incr.initialize_increment();
    }

    // TabPrimSchoolEntries
    if (theTabPrimSchoolEntries) {
        auto & filter = om_aia_15;
        auto cell = om_TabPrimSchoolEntries_current_cell();

        auto & incr = om_TabPrimSchoolEntries_incr;
        incr.set_filter(filter);
        incr.set_cell(cell);
        incr.initialize_increment();
    }

    // TabPrimSchoolGraduations
    if (theTabPrimSchoolGraduations) {
        auto & filter = om_aia_15;
        auto cell = om_TabPrimSchoolGraduations_current_cell();

        auto & incr = om_TabPrimSchoolGraduations_incr;
        incr.set_filter(filter);
        incr.set_cell(cell);
        incr.initialize_increment();
    }

    // TabPrimSchoolOutOfSchool9to11
    if (theTabPrimSchoolOutOfSchool9to11) {
        auto & filter = om_aia_23;
        auto cell = om_TabPrimSchoolOutOfSchool9to11_current_cell();

        auto & incr = om_TabPrimSchoolOutOfSchool9to11_incr;
        incr.set_filter(filter);
        incr.set_cell(cell);
        incr.initialize_increment();
    }

    // TabPrimarySchoolPlanning
    if (theTabPrimarySchoolPlanning) {
        auto & filter = om_aia_14;
        auto cell = om_TabPrimarySchoolPlanning_current_cell();

        auto & incr = om_TabPrimarySchoolPlanning_incr;
        incr.set_filter(filter);
        incr.set_cell(cell);
        incr.initialize_increment();
    }

    // TabSchool2AttainmentsTab
    if (theTabSchool2AttainmentsTab) {
        auto & filter = om_aia_26;
        auto cell = om_TabSchool2AttainmentsTab_current_cell();

        auto & incr = om_TabSchool2AttainmentsTab_incr;
        incr.set_filter(filter);
        incr.set_cell(cell);
        incr.initialize_increment();
    }

    // TabSchool2TrackTab
    if (theTabSchool2TrackTab) {
        auto & filter = om_aia_25;
        auto cell = om_TabSchool2TrackTab_current_cell();

        auto & incr = om_TabSchool2TrackTab_incr;
        incr.set_filter(filter);
        incr.set_cell(cell);
        incr.initialize_increment();
    }

    // tabBirthsYearPlace
    if (thetabBirthsYearPlace) {
        auto & filter = om_aia_34;
        auto cell = om_tabBirthsYearPlace_current_cell();

        auto & incr = om_tabBirthsYearPlace_incr;
        incr.set_filter(filter);
        incr.set_cell(cell);
        incr.initialize_increment();
    }

    // tabEducationFateGeobirYob
    if (thetabEducationFateGeobirYob) {
        auto & filter = om_aia_5;
        auto cell = om_tabEducationFateGeobirYob_current_cell();

        auto & incr = om_tabEducationFateGeobirYob_incr;
        incr.set_filter(filter);
        incr.set_cell(cell);
        incr.initialize_increment();
    }

    // tabHCI
    if (thetabHCI) {
        auto & filter = om_aia_33;
        auto cell = om_tabHCI_current_cell();

        auto & incr = om_tabHCI_incr;
        incr.set_filter(filter);
        incr.set_cell(cell);
        incr.initialize_increment();
    }

    // tabHavingSpouse
    if (thetabHavingSpouse) {
        auto & filter = om_aia_30;
        auto cell = om_tabHavingSpouse_current_cell();

        auto & incr = om_tabHavingSpouse_incr;
        incr.set_filter(filter);
        incr.set_cell(cell);
        incr.initialize_increment();
    }

    // tabMigrationOriginDestination
    if (thetabMigrationOriginDestination) {
        auto & filter = om_aia_35;
        auto cell = om_tabMigrationOriginDestination_current_cell();

        auto & incr = om_tabMigrationOriginDestination_incr;
        incr.set_filter(filter);
        incr.set_cell(cell);
        incr.initialize_increment();
    }

    // tabPopulationYearPlace
    if (thetabPopulationYearPlace) {
        auto & filter = om_aia_34;
        auto cell = om_tabPopulationYearPlace_current_cell();

        auto & incr = om_tabPopulationYearPlace_incr;
        incr.set_filter(filter);
        incr.set_cell(cell);
        incr.initialize_increment();
    }

    // tabPreSchool
    if (thetabPreSchool) {
        auto & filter = om_aia_1;
        auto cell = om_tabPreSchool_current_cell();

        auto & incr = om_tabPreSchool_incr;
        incr.set_filter(filter);
        incr.set_cell(cell);
        incr.initialize_increment();
    }

    // tabStuntingSexRegMotherYob
    if (thetabStuntingSexRegMotherYob) {
        auto & filter = om_aia_36;
        auto cell = om_tabStuntingSexRegMotherYob_current_cell();

        auto & incr = om_tabStuntingSexRegMotherYob_incr;
        incr.set_filter(filter);
        incr.set_cell(cell);
        incr.initialize_increment();
    }

    // tabStuntingSexRegYob
    if (thetabStuntingSexRegYob) {
        auto & filter = om_aia_36;
        auto cell = om_tabStuntingSexRegYob_current_cell();

        auto & incr = om_tabStuntingSexRegYob_incr;
        incr.set_filter(filter);
        incr.set_cell(cell);
        incr.initialize_increment();
    }

}
void Person::om_initialize_time_and_age()
{
    // Calling initialize() to set the values of time and age to time_infinite
    // ensures that their associated side-effects functions will be invoked
    // when set() is called immediately after.  This ensures that identity attributes
    // and derived attributes which depend on time and age have correct values
    // if they are used by model developer code in the Start() function before the
    // entity enters the simulation.
    time.initialize(time_infinite);
    time.set(BaseEvent::get_global_time());
    age.initialize(time_infinite);
    age.set(0);
}
void Person::om_mlBioFatherChildren_erase(entity_ptr<Person> lnk)
{
    if (lnk->lBioFather.get().get() == this) lnk->lBioFather = nullptr;
}
void Person::om_mlBioFatherChildren_insert(entity_ptr<Person> lnk)
{
    if (lnk.get() != nullptr) lnk->lBioFather = this;
}
void Person::om_mlBioFatherChildren_side_effects()
{
}
void Person::om_mlBioMotherChildren_erase(entity_ptr<Person> lnk)
{
    if (lnk->lBioMother.get().get() == this) lnk->lBioMother = nullptr;
}
void Person::om_mlBioMotherChildren_insert(entity_ptr<Person> lnk)
{
    if (lnk.get() != nullptr) lnk->lBioMother = this;
}
void Person::om_mlBioMotherChildren_side_effects()
{
}
void Person::om_mlHHFatherChildren_count_evaluate()
{
    om_mlHHFatherChildren_count.set(mlHHFatherChildren.size());
}
void Person::om_mlHHFatherChildren_erase(entity_ptr<Person> lnk)
{
    if (lnk->lHHFather.get().get() == this) lnk->lHHFather = nullptr;
}
void Person::om_mlHHFatherChildren_insert(entity_ptr<Person> lnk)
{
    if (lnk.get() != nullptr) lnk->lHHFather = this;
}
void Person::om_mlHHFatherChildren_side_effects()
{

    // Code Injection: group=10, injector=om_mlHHFatherChildren_count
    // Re-evaluate multilink agentvar om_mlHHFatherChildren_count
    om_mlHHFatherChildren_count_evaluate();


    // Code Injection: group=10, injector=om_mlHHFatherChildren_sum_over_is_alive
    // Re-evaluate multilink agentvar om_mlHHFatherChildren_sum_over_is_alive
    om_mlHHFatherChildren_sum_over_is_alive_evaluate();

}
void Person::om_mlHHFatherChildren_sum_over_is_alive_evaluate()
{
    integer val_result = 0;
    for (auto &item : mlHHFatherChildren.storage) {
        if (item.get() != nullptr) {
            integer val_item = item->is_alive; 
            val_result += val_item;
        }
    }
    om_mlHHFatherChildren_sum_over_is_alive.set(val_result);
}
void Person::om_mlHHMotherChildren_count_evaluate()
{
    om_mlHHMotherChildren_count.set(mlHHMotherChildren.size());
}
void Person::om_mlHHMotherChildren_erase(entity_ptr<Person> lnk)
{
    if (lnk->lHHMother.get().get() == this) lnk->lHHMother = nullptr;
}
void Person::om_mlHHMotherChildren_insert(entity_ptr<Person> lnk)
{
    if (lnk.get() != nullptr) lnk->lHHMother = this;
}
void Person::om_mlHHMotherChildren_min_over_integer_age_evaluate()
{
    AGE_RANGE val_result = 0;  // default value for the type
    bool found = false;
    for (auto &item : mlHHMotherChildren.storage) {
        if (item.get() != nullptr) {
            AGE_RANGE val_item = item->integer_age; 
            if (!found) {
                val_result = val_item;
                found = true;
            }
            else {
                if (val_item < val_result) val_result = val_item;
            }
        }
    }
    om_mlHHMotherChildren_min_over_integer_age.set(val_result);
}
void Person::om_mlHHMotherChildren_side_effects()
{

    // Code Injection: group=10, injector=om_mlHHMotherChildren_count
    // Re-evaluate multilink agentvar om_mlHHMotherChildren_count
    om_mlHHMotherChildren_count_evaluate();


    // Code Injection: group=10, injector=om_mlHHMotherChildren_min_over_integer_age
    // Re-evaluate multilink agentvar om_mlHHMotherChildren_min_over_integer_age
    om_mlHHMotherChildren_min_over_integer_age_evaluate();


    // Code Injection: group=10, injector=om_mlHHMotherChildren_sum_over_is_alive
    // Re-evaluate multilink agentvar om_mlHHMotherChildren_sum_over_is_alive
    om_mlHHMotherChildren_sum_over_is_alive_evaluate();

}
void Person::om_mlHHMotherChildren_sum_over_is_alive_evaluate()
{
    integer val_result = 0;
    for (auto &item : mlHHMotherChildren.storage) {
        if (item.get() != nullptr) {
            integer val_item = item->is_alive; 
            val_result += val_item;
        }
    }
    om_mlHHMotherChildren_sum_over_is_alive.set(val_result);
}
void Person::om_notify_adult_survival()
{
}
void Person::om_notify_age()
{
}
void Person::om_notify_age_last_birth()
{
}
void Person::om_notify_age_mig()
{
}
void Person::om_notify_age_youngest_child()
{
}
void Person::om_notify_all_year()
{
}
void Person::om_notify_calendar_year()
{
}
void Person::om_notify_case_seed()
{
}
void Person::om_notify_child_agegr()
{
}
void Person::om_notify_child_agegr_part()
{
}
void Person::om_notify_child_mortality()
{
}
void Person::om_notify_child_mortality_group()
{
}
void Person::om_notify_children_in_household()
{
}
void Person::om_notify_creation_type()
{
}
void Person::om_notify_educ1_group()
{

    // Code Injection: group=10, injector=TabEducFateByGroup
    // Check for and finish pending increment in entity table TabEducFateByGroup
    if (om_active && theTabEducFateByGroup) {
        auto & incr = om_TabEducFateByGroup_incr;
        incr.finish_pending();
    }
}
void Person::om_notify_educ_mother()
{

    // Code Injection: group=10, injector=TabImmunizationChildren
    // Check for and finish pending increment in entity table TabImmunizationChildren
    if (om_active && theTabImmunizationChildren) {
        auto & incr = om_TabImmunizationChildren_incr;
        incr.finish_pending();
    }

    // Code Injection: group=10, injector=TabPrenatCare
    // Check for and finish pending increment in entity table TabPrenatCare
    if (om_active && theTabPrenatCare) {
        auto & incr = om_TabPrenatCare_incr;
        incr.finish_pending();
    }

    // Code Injection: group=10, injector=tabStuntingSexRegMotherYob
    // Check for and finish pending increment in entity table tabStuntingSexRegMotherYob
    if (om_active && thetabStuntingSexRegMotherYob) {
        auto & incr = om_tabStuntingSexRegMotherYob_incr;
        incr.finish_pending();
    }
}
void Person::om_notify_educ_one_entry_age()
{
}
void Person::om_notify_educ_one_fate()
{

    // Code Injection: group=10, injector=TabEducFateByGroup
    // Check for and finish pending increment in entity table TabEducFateByGroup
    if (om_active && theTabEducFateByGroup) {
        auto & incr = om_TabEducFateByGroup_incr;
        incr.finish_pending();
    }

    // Code Injection: group=10, injector=TabEducFateDistrYob
    // Check for and finish pending increment in entity table TabEducFateDistrYob
    if (om_active && theTabEducFateDistrYob) {
        auto & incr = om_TabEducFateDistrYob_incr;
        incr.finish_pending();
    }
}
void Person::om_notify_educ_one_geo()
{
}
void Person::om_notify_educ_one_grade()
{

    // Code Injection: group=10, injector=TabPrimarySchoolPlanning
    // Check for and finish pending increment in entity table TabPrimarySchoolPlanning
    if (om_active && theTabPrimarySchoolPlanning) {
        auto & incr = om_TabPrimarySchoolPlanning_incr;
        incr.finish_pending();
    }
}
void Person::om_notify_educ_one_grade_attended()
{
}
void Person::om_notify_educ_one_grade_fate()
{
}
void Person::om_notify_educ_one_grade_passed()
{
}
void Person::om_notify_educ_one_group()
{
}
void Person::om_notify_educ_one_level()
{
}
void Person::om_notify_educ_one_required_rooms()
{

    // Code Injection: group=10, injector=TabPrimarySchoolPlanning
    // Check for and finish pending increment in entity table TabPrimarySchoolPlanning
    if (om_active && theTabPrimarySchoolPlanning) {
        auto & incr = om_TabPrimarySchoolPlanning_incr;
        incr.finish_pending();
    }
}
void Person::om_notify_educ_one_required_teachers()
{

    // Code Injection: group=10, injector=TabPrimarySchoolPlanning
    // Check for and finish pending increment in entity table TabPrimarySchoolPlanning
    if (om_active && theTabPrimarySchoolPlanning) {
        auto & incr = om_TabPrimarySchoolPlanning_incr;
        incr.finish_pending();
    }
}
void Person::om_notify_educ_one_status()
{
}
void Person::om_notify_educ_one_to_process()
{
}
void Person::om_notify_educ_two_delay()
{
}
void Person::om_notify_educ_two_geo()
{
}
void Person::om_notify_educ_two_grade_attended()
{

    // Code Injection: group=10, injector=TabSchool2TrackTab
    // Check for and finish pending increment in entity table TabSchool2TrackTab
    if (om_active && theTabSchool2TrackTab) {
        auto & incr = om_TabSchool2TrackTab_incr;
        incr.finish_pending();
    }
}
void Person::om_notify_educ_two_grade_passed()
{
}
void Person::om_notify_educ_two_group()
{
}
void Person::om_notify_educ_two_level()
{
}
void Person::om_notify_educ_two_status()
{
}
void Person::om_notify_educ_two_to_process()
{
}
void Person::om_notify_entity_id()
{
}
void Person::om_notify_ethnicity()
{
}
void Person::om_notify_ethnicity_short()
{

    // Code Injection: group=10, injector=TabImmunizationChildren
    // Check for and finish pending increment in entity table TabImmunizationChildren
    if (om_active && theTabImmunizationChildren) {
        auto & incr = om_TabImmunizationChildren_incr;
        incr.finish_pending();
    }
}
void Person::om_notify_events()
{
}
void Person::om_notify_ever_resident()
{
}
void Person::om_notify_ever_union()
{
}
void Person::om_notify_family_role()
{
}
void Person::om_notify_female_spouse_age()
{
}
void Person::om_notify_fertile_age()
{
}
void Person::om_notify_first_move_done()
{
}
void Person::om_notify_geo()
{

    // Code Injection: group=10, injector=tabBirthsYearPlace
    // Check for and finish pending increment in entity table tabBirthsYearPlace
    if (om_active && thetabBirthsYearPlace) {
        auto & incr = om_tabBirthsYearPlace_incr;
        incr.finish_pending();
    }

    // Code Injection: group=10, injector=tabMigrationOriginDestination
    // Check for and finish pending increment in entity table tabMigrationOriginDestination
    if (om_active && thetabMigrationOriginDestination) {
        auto & incr = om_tabMigrationOriginDestination_incr;
        incr.finish_pending();
    }

    // Code Injection: group=10, injector=tabPopulationYearPlace
    // Check for and finish pending increment in entity table tabPopulationYearPlace
    if (om_active && thetabPopulationYearPlace) {
        auto & incr = om_tabPopulationYearPlace_incr;
        incr.finish_pending();
    }

    // Code Injection: group=10, injector=tabPreSchool
    // Check for and finish pending increment in entity table tabPreSchool
    if (om_active && thetabPreSchool) {
        auto & incr = om_tabPreSchool_incr;
        incr.finish_pending();
    }
}
void Person::om_notify_geo_birth()
{

    // Code Injection: group=10, injector=TabEduc15ByDistrictBirth
    // Check for and finish pending increment in entity table TabEduc15ByDistrictBirth
    if (om_active && theTabEduc15ByDistrictBirth) {
        auto & incr = om_TabEduc15ByDistrictBirth_incr;
        incr.finish_pending();
    }

    // Code Injection: group=10, injector=tabEducationFateGeobirYob
    // Check for and finish pending increment in entity table tabEducationFateGeobirYob
    if (om_active && thetabEducationFateGeobirYob) {
        auto & incr = om_tabEducationFateGeobirYob_incr;
        incr.finish_pending();
    }
}
void Person::om_notify_geo_nat()
{

    // Code Injection: group=10, injector=PopPyramidByEduc
    // Check for and finish pending increment in entity table PopPyramidByEduc
    if (om_active && thePopPyramidByEduc) {
        auto & incr = om_PopPyramidByEduc_incr;
        incr.finish_pending();
    }

    // Code Injection: group=10, injector=TabEduc15ByDistrict
    // Check for and finish pending increment in entity table TabEduc15ByDistrict
    if (om_active && theTabEduc15ByDistrict) {
        auto & incr = om_TabEduc15ByDistrict_incr;
        incr.finish_pending();
    }

    // Code Injection: group=10, injector=TabPopProvAgeEducSex
    // Check for and finish pending increment in entity table TabPopProvAgeEducSex
    if (om_active && theTabPopProvAgeEducSex) {
        auto & incr = om_TabPopProvAgeEducSex_incr;
        incr.finish_pending();
    }

    // Code Injection: group=10, injector=TabPrimSchoolEntries
    // Check for and finish pending increment in entity table TabPrimSchoolEntries
    if (om_active && theTabPrimSchoolEntries) {
        auto & incr = om_TabPrimSchoolEntries_incr;
        incr.finish_pending();
    }

    // Code Injection: group=10, injector=TabPrimSchoolGraduations
    // Check for and finish pending increment in entity table TabPrimSchoolGraduations
    if (om_active && theTabPrimSchoolGraduations) {
        auto & incr = om_TabPrimSchoolGraduations_incr;
        incr.finish_pending();
    }

    // Code Injection: group=10, injector=TabPrimSchoolOutOfSchool9to11
    // Check for and finish pending increment in entity table TabPrimSchoolOutOfSchool9to11
    if (om_active && theTabPrimSchoolOutOfSchool9to11) {
        auto & incr = om_TabPrimSchoolOutOfSchool9to11_incr;
        incr.finish_pending();
    }

    // Code Injection: group=10, injector=TabPrimarySchoolPlanning
    // Check for and finish pending increment in entity table TabPrimarySchoolPlanning
    if (om_active && theTabPrimarySchoolPlanning) {
        auto & incr = om_TabPrimarySchoolPlanning_incr;
        incr.finish_pending();
    }
}
void Person::om_notify_geo_prev()
{

    // Code Injection: group=10, injector=tabMigrationOriginDestination
    // Check for and finish pending increment in entity table tabMigrationOriginDestination
    if (om_active && thetabMigrationOriginDestination) {
        auto & incr = om_tabMigrationOriginDestination_incr;
        incr.finish_pending();
    }
}
void Person::om_notify_geo_want_to_move()
{
}
void Person::om_notify_got_prenat_care()
{

    // Code Injection: group=10, injector=TabImmunizationChildren
    // Check for and finish pending increment in entity table TabImmunizationChildren
    if (om_active && theTabImmunizationChildren) {
        auto & incr = om_TabImmunizationChildren_incr;
        incr.finish_pending();
    }
}
void Person::om_notify_has_passed_primary()
{
}
void Person::om_notify_has_spouse()
{
}
void Person::om_notify_in_hci_sample()
{
}
void Person::om_notify_in_projected_time()
{
}
void Person::om_notify_in_sel_years()
{
}
void Person::om_notify_in_selected_year()
{
}
void Person::om_notify_ind_hci()
{
}
void Person::om_notify_integer_age()
{

    // Code Injection: group=10, injector=tabHavingSpouse
    // Check for and finish pending increment in entity table tabHavingSpouse
    if (om_active && thetabHavingSpouse) {
        auto & incr = om_tabHavingSpouse_incr;
        incr.finish_pending();
    }
}
void Person::om_notify_is_aded0()
{
}
void Person::om_notify_is_aded1()
{
}
void Person::om_notify_is_aded2()
{
}
void Person::om_notify_is_adult()
{
}
void Person::om_notify_is_alive()
{

    // Code Injection: group=10, injector=tabMigrationOriginDestination
    // Check for and finish pending increment in entity table tabMigrationOriginDestination
    if (om_active && thetabMigrationOriginDestination) {
        auto & incr = om_tabMigrationOriginDestination_incr;
        incr.finish_pending();
    }
}
void Person::om_notify_is_blocked_from_marriage()
{
}
void Person::om_notify_is_child()
{
}
void Person::om_notify_is_educ_one_student()
{
}
void Person::om_notify_is_fertile()
{
}
void Person::om_notify_is_immunized()
{
}
void Person::om_notify_is_mortal()
{
}
void Person::om_notify_is_old()
{
}
void Person::om_notify_is_ready_for_birthtables()
{
}
void Person::om_notify_is_resident()
{
}
void Person::om_notify_is_stunted()
{

    // Code Injection: group=10, injector=tabStuntingSexRegMotherYob
    // Check for and finish pending increment in entity table tabStuntingSexRegMotherYob
    if (om_active && thetabStuntingSexRegMotherYob) {
        auto & incr = om_tabStuntingSexRegMotherYob_incr;
        incr.finish_pending();
    }

    // Code Injection: group=10, injector=tabStuntingSexRegYob
    // Check for and finish pending increment in entity table tabStuntingSexRegYob
    if (om_active && thetabStuntingSexRegYob) {
        auto & incr = om_tabStuntingSexRegYob_incr;
        incr.finish_pending();
    }
}
void Person::om_notify_lBioFather()
{
}
void Person::om_notify_lBioMother()
{
}
void Person::om_notify_lCalibrator()
{
}
void Person::om_notify_lHHFather()
{
}
void Person::om_notify_lHHMother()
{
}
void Person::om_notify_lSpouse()
{
}
void Person::om_notify_lStartValues()
{
}
void Person::om_notify_lives_with_dependent_child()
{
}
void Person::om_notify_male_age()
{
}
void Person::om_notify_male_spouse_age()
{
}
void Person::om_notify_moth_agegr()
{
}
void Person::om_notify_moth_agegr_part()
{
}
void Person::om_notify_mother_age_at_birth()
{
}
void Person::om_notify_om_active_spell_duration_FOR_this_parity_spell_X_true()
{
}
void Person::om_notify_om_aggregate_FOR_ethnicity_X_ETHNICITY_SHORT()
{
}
void Person::om_notify_om_aggregate_FOR_geo_X_GEO_NAT()
{
}
void Person::om_notify_om_aggregate_FOR_geo_X_REGION_INT()
{
}
void Person::om_notify_om_aggregate_FOR_geo_birth_X_GEO_NAT()
{

    // Code Injection: group=10, injector=TabHCIDistrict
    // Check for and finish pending increment in entity table TabHCIDistrict
    if (om_active && theTabHCIDistrict) {
        auto & incr = om_TabHCIDistrict_incr;
        incr.finish_pending();
    }
}
void Person::om_notify_om_aggregate_FOR_geo_birth_X_REGION_INT()
{
}
void Person::om_notify_om_aggregate_FOR_region_birth_X_REGION_NAT()
{

    // Code Injection: group=10, injector=TabEducFateDistrYob
    // Check for and finish pending increment in entity table TabEducFateDistrYob
    if (om_active && theTabEducFateDistrYob) {
        auto & incr = om_TabEducFateDistrYob_incr;
        incr.finish_pending();
    }

    // Code Injection: group=10, injector=tabHCI
    // Check for and finish pending increment in entity table tabHCI
    if (om_active && thetabHCI) {
        auto & incr = om_tabHCI_incr;
        incr.finish_pending();
    }
}
void Person::om_notify_om_aggregate_FOR_region_int_X_REGION_NAT()
{
}
void Person::om_notify_om_aia_0()
{
}
void Person::om_notify_om_aia_1()
{

    // Code Injection: group=10, injector=tabPreSchool
    // Check for and finish pending increment in entity table tabPreSchool
    if (om_active && thetabPreSchool) {
        auto & incr = om_tabPreSchool_incr;
        incr.finish_pending();
    }
}
void Person::om_notify_om_aia_10()
{
}
void Person::om_notify_om_aia_11()
{
}
void Person::om_notify_om_aia_12()
{
}
void Person::om_notify_om_aia_13()
{

    // Code Injection: group=10, injector=TabEducFateByGroup
    // Check for and finish pending increment in entity table TabEducFateByGroup
    if (om_active && theTabEducFateByGroup) {
        auto & incr = om_TabEducFateByGroup_incr;
        incr.finish_pending();
    }
}
void Person::om_notify_om_aia_14()
{

    // Code Injection: group=10, injector=TabPrimarySchoolPlanning
    // Check for and finish pending increment in entity table TabPrimarySchoolPlanning
    if (om_active && theTabPrimarySchoolPlanning) {
        auto & incr = om_TabPrimarySchoolPlanning_incr;
        incr.finish_pending();
    }
}
void Person::om_notify_om_aia_15()
{

    // Code Injection: group=10, injector=TabPopProvAgeEducSex
    // Check for and finish pending increment in entity table TabPopProvAgeEducSex
    if (om_active && theTabPopProvAgeEducSex) {
        auto & incr = om_TabPopProvAgeEducSex_incr;
        incr.finish_pending();
    }

    // Code Injection: group=10, injector=TabPrimSchoolEntries
    // Check for and finish pending increment in entity table TabPrimSchoolEntries
    if (om_active && theTabPrimSchoolEntries) {
        auto & incr = om_TabPrimSchoolEntries_incr;
        incr.finish_pending();
    }

    // Code Injection: group=10, injector=TabPrimSchoolGraduations
    // Check for and finish pending increment in entity table TabPrimSchoolGraduations
    if (om_active && theTabPrimSchoolGraduations) {
        auto & incr = om_TabPrimSchoolGraduations_incr;
        incr.finish_pending();
    }
}
void Person::om_notify_om_aia_16()
{
}
void Person::om_notify_om_aia_17()
{
}
void Person::om_notify_om_aia_18()
{
}
void Person::om_notify_om_aia_19()
{
}
void Person::om_notify_om_aia_2()
{
}
void Person::om_notify_om_aia_20()
{
}
void Person::om_notify_om_aia_21()
{

    // Code Injection: group=10, injector=TabEducFateDistrYob
    // Check for and finish pending increment in entity table TabEducFateDistrYob
    if (om_active && theTabEducFateDistrYob) {
        auto & incr = om_TabEducFateDistrYob_incr;
        incr.finish_pending();
    }
}
void Person::om_notify_om_aia_22()
{

    // Code Injection: group=10, injector=TabEduc15ByDistrict
    // Check for and finish pending increment in entity table TabEduc15ByDistrict
    if (om_active && theTabEduc15ByDistrict) {
        auto & incr = om_TabEduc15ByDistrict_incr;
        incr.finish_pending();
    }

    // Code Injection: group=10, injector=TabEduc15ByDistrictBirth
    // Check for and finish pending increment in entity table TabEduc15ByDistrictBirth
    if (om_active && theTabEduc15ByDistrictBirth) {
        auto & incr = om_TabEduc15ByDistrictBirth_incr;
        incr.finish_pending();
    }
}
void Person::om_notify_om_aia_23()
{

    // Code Injection: group=10, injector=TabPrimSchoolOutOfSchool9to11
    // Check for and finish pending increment in entity table TabPrimSchoolOutOfSchool9to11
    if (om_active && theTabPrimSchoolOutOfSchool9to11) {
        auto & incr = om_TabPrimSchoolOutOfSchool9to11_incr;
        incr.finish_pending();
    }
}
void Person::om_notify_om_aia_24()
{
}
void Person::om_notify_om_aia_25()
{

    // Code Injection: group=10, injector=TabSchool2TrackTab
    // Check for and finish pending increment in entity table TabSchool2TrackTab
    if (om_active && theTabSchool2TrackTab) {
        auto & incr = om_TabSchool2TrackTab_incr;
        incr.finish_pending();
    }
}
void Person::om_notify_om_aia_26()
{

    // Code Injection: group=10, injector=TabSchool2AttainmentsTab
    // Check for and finish pending increment in entity table TabSchool2AttainmentsTab
    if (om_active && theTabSchool2AttainmentsTab) {
        auto & incr = om_TabSchool2AttainmentsTab_incr;
        incr.finish_pending();
    }
}
void Person::om_notify_om_aia_27()
{
}
void Person::om_notify_om_aia_28()
{
}
void Person::om_notify_om_aia_29()
{
}
void Person::om_notify_om_aia_3()
{
}
void Person::om_notify_om_aia_30()
{

    // Code Injection: group=10, injector=tabHavingSpouse
    // Check for and finish pending increment in entity table tabHavingSpouse
    if (om_active && thetabHavingSpouse) {
        auto & incr = om_tabHavingSpouse_incr;
        incr.finish_pending();
    }
}
void Person::om_notify_om_aia_31()
{
}
void Person::om_notify_om_aia_32()
{
}
void Person::om_notify_om_aia_33()
{

    // Code Injection: group=10, injector=TabHCIDistrict
    // Check for and finish pending increment in entity table TabHCIDistrict
    if (om_active && theTabHCIDistrict) {
        auto & incr = om_TabHCIDistrict_incr;
        incr.finish_pending();
    }

    // Code Injection: group=10, injector=tabHCI
    // Check for and finish pending increment in entity table tabHCI
    if (om_active && thetabHCI) {
        auto & incr = om_tabHCI_incr;
        incr.finish_pending();
    }
}
void Person::om_notify_om_aia_34()
{

    // Code Injection: group=10, injector=tabBirthsYearPlace
    // Check for and finish pending increment in entity table tabBirthsYearPlace
    if (om_active && thetabBirthsYearPlace) {
        auto & incr = om_tabBirthsYearPlace_incr;
        incr.finish_pending();
    }

    // Code Injection: group=10, injector=tabPopulationYearPlace
    // Check for and finish pending increment in entity table tabPopulationYearPlace
    if (om_active && thetabPopulationYearPlace) {
        auto & incr = om_tabPopulationYearPlace_incr;
        incr.finish_pending();
    }
}
void Person::om_notify_om_aia_35()
{

    // Code Injection: group=10, injector=tabMigrationOriginDestination
    // Check for and finish pending increment in entity table tabMigrationOriginDestination
    if (om_active && thetabMigrationOriginDestination) {
        auto & incr = om_tabMigrationOriginDestination_incr;
        incr.finish_pending();
    }
}
void Person::om_notify_om_aia_36()
{

    // Code Injection: group=10, injector=tabStuntingSexRegMotherYob
    // Check for and finish pending increment in entity table tabStuntingSexRegMotherYob
    if (om_active && thetabStuntingSexRegMotherYob) {
        auto & incr = om_tabStuntingSexRegMotherYob_incr;
        incr.finish_pending();
    }

    // Code Injection: group=10, injector=tabStuntingSexRegYob
    // Check for and finish pending increment in entity table tabStuntingSexRegYob
    if (om_active && thetabStuntingSexRegYob) {
        auto & incr = om_tabStuntingSexRegYob_incr;
        incr.finish_pending();
    }
}
void Person::om_notify_om_aia_37()
{

    // Code Injection: group=10, injector=TabImmunizationChildren
    // Check for and finish pending increment in entity table TabImmunizationChildren
    if (om_active && theTabImmunizationChildren) {
        auto & incr = om_TabImmunizationChildren_incr;
        incr.finish_pending();
    }

    // Code Injection: group=10, injector=TabPrenatCare
    // Check for and finish pending increment in entity table TabPrenatCare
    if (om_active && theTabPrenatCare) {
        auto & incr = om_TabPrenatCare_incr;
        incr.finish_pending();
    }
}
void Person::om_notify_om_aia_38()
{
}
void Person::om_notify_om_aia_39()
{
}
void Person::om_notify_om_aia_4()
{
}
void Person::om_notify_om_aia_40()
{

    // Code Injection: group=10, injector=TabChildVaccination
    // Check for and finish pending increment in entity table TabChildVaccination
    if (om_active && theTabChildVaccination) {
        auto & incr = om_TabChildVaccination_incr;
        incr.finish_pending();
    }
}
void Person::om_notify_om_aia_5()
{

    // Code Injection: group=10, injector=tabEducationFateGeobirYob
    // Check for and finish pending increment in entity table tabEducationFateGeobirYob
    if (om_active && thetabEducationFateGeobirYob) {
        auto & incr = om_tabEducationFateGeobirYob_incr;
        incr.finish_pending();
    }
}
void Person::om_notify_om_aia_6()
{
}
void Person::om_notify_om_aia_7()
{
}
void Person::om_notify_om_aia_8()
{
}
void Person::om_notify_om_aia_9()
{

    // Code Injection: group=10, injector=PopPyramidByEduc
    // Check for and finish pending increment in entity table PopPyramidByEduc
    if (om_active && thePopPyramidByEduc) {
        auto & incr = om_PopPyramidByEduc_incr;
        incr.finish_pending();
    }
}
void Person::om_notify_om_asAllFertilePersonsForFertilityAlignmentByAge_filter()
{
}
void Person::om_notify_om_asAllFertilePersonsForFertilityAlignment_filter()
{
}
void Person::om_notify_om_asAllPerson_filter()
{
}
void Person::om_notify_om_asAvailableMaleByTypeImmiScratch_filter()
{
}
void Person::om_notify_om_asAvailableMaleByType_filter()
{
}
void Person::om_notify_om_asAvailableMaleImmiScratch_filter()
{
}
void Person::om_notify_om_asAvailableMale_filter()
{
}
void Person::om_notify_om_asFemaleInUnionByAgeAndPartnerAgeImmiScratch_filter()
{
}
void Person::om_notify_om_asFemaleInUnionByAgeAndPartnerAge_filter()
{
}
void Person::om_notify_om_asPotentialImmigrantMothers_filter()
{
}
void Person::om_notify_om_asPotentialSchoolOneStudentToProcess_filter()
{
}
void Person::om_notify_om_asPotentialSchoolOneStudent_filter()
{
}
void Person::om_notify_om_asPotentialSchoolTwoStudentToProcess_filter()
{
}
void Person::om_notify_om_asPotentialSchoolTwoStudent_filter()
{
}
void Person::om_notify_om_asResidentBabies_filter()
{
}
void Person::om_notify_om_asResidentsAge0SexGeo_filter()
{
}
void Person::om_notify_om_asResidentsAge0Sex_filter()
{
}
void Person::om_notify_om_asSimBornAge0_filter()
{
}
void Person::om_notify_om_asWantToMove_filter()
{
}
void Person::om_notify_om_asWomenNoChildren_filter()
{
}
void Person::om_notify_om_asWomenWithChildren_filter()
{
}
void Person::om_notify_om_duration()
{

    // Code Injection: group=10, injector=TabChildVaccination
    // Check for and finish pending increment in entity table TabChildVaccination
    if (om_active && theTabChildVaccination) {
        auto & incr = om_TabChildVaccination_incr;
        incr.finish_pending();
    }

    // Code Injection: group=10, injector=TabEduc15ByDistrict
    // Check for and finish pending increment in entity table TabEduc15ByDistrict
    if (om_active && theTabEduc15ByDistrict) {
        auto & incr = om_TabEduc15ByDistrict_incr;
        incr.finish_pending();
    }

    // Code Injection: group=10, injector=TabEduc15ByDistrictBirth
    // Check for and finish pending increment in entity table TabEduc15ByDistrictBirth
    if (om_active && theTabEduc15ByDistrictBirth) {
        auto & incr = om_TabEduc15ByDistrictBirth_incr;
        incr.finish_pending();
    }

    // Code Injection: group=10, injector=TabImmunizationChildren
    // Check for and finish pending increment in entity table TabImmunizationChildren
    if (om_active && theTabImmunizationChildren) {
        auto & incr = om_TabImmunizationChildren_incr;
        incr.finish_pending();
    }

    // Code Injection: group=10, injector=TabPrenatCare
    // Check for and finish pending increment in entity table TabPrenatCare
    if (om_active && theTabPrenatCare) {
        auto & incr = om_TabPrenatCare_incr;
        incr.finish_pending();
    }

    // Code Injection: group=10, injector=TabPrimSchoolOutOfSchool9to11
    // Check for and finish pending increment in entity table TabPrimSchoolOutOfSchool9to11
    if (om_active && theTabPrimSchoolOutOfSchool9to11) {
        auto & incr = om_TabPrimSchoolOutOfSchool9to11_incr;
        incr.finish_pending();
    }

    // Code Injection: group=10, injector=TabSchool2AttainmentsTab
    // Check for and finish pending increment in entity table TabSchool2AttainmentsTab
    if (om_active && theTabSchool2AttainmentsTab) {
        auto & incr = om_TabSchool2AttainmentsTab_incr;
        incr.finish_pending();
    }

    // Code Injection: group=10, injector=tabEducationFateGeobirYob
    // Check for and finish pending increment in entity table tabEducationFateGeobirYob
    if (om_active && thetabEducationFateGeobirYob) {
        auto & incr = om_tabEducationFateGeobirYob_incr;
        incr.finish_pending();
    }

    // Code Injection: group=10, injector=tabHavingSpouse
    // Check for and finish pending increment in entity table tabHavingSpouse
    if (om_active && thetabHavingSpouse) {
        auto & incr = om_tabHavingSpouse_incr;
        incr.finish_pending();
    }

    // Code Injection: group=10, injector=tabPopulationYearPlace
    // Check for and finish pending increment in entity table tabPopulationYearPlace
    if (om_active && thetabPopulationYearPlace) {
        auto & incr = om_tabPopulationYearPlace_incr;
        incr.finish_pending();
    }

    // Code Injection: group=10, injector=tabPreSchool
    // Check for and finish pending increment in entity table tabPreSchool
    if (om_active && thetabPreSchool) {
        auto & incr = om_tabPreSchool_incr;
        incr.finish_pending();
    }
}
void Person::om_notify_om_duration_FOR_educ_one_fate_X_EOL_HIGH()
{

    // Code Injection: group=10, injector=TabEduc15ByDistrict
    // Check for and finish pending increment in entity table TabEduc15ByDistrict
    if (om_active && theTabEduc15ByDistrict) {
        auto & incr = om_TabEduc15ByDistrict_incr;
        incr.finish_pending();
    }

    // Code Injection: group=10, injector=TabEduc15ByDistrictBirth
    // Check for and finish pending increment in entity table TabEduc15ByDistrictBirth
    if (om_active && theTabEduc15ByDistrictBirth) {
        auto & incr = om_TabEduc15ByDistrictBirth_incr;
        incr.finish_pending();
    }

    // Code Injection: group=10, injector=tabEducationFateGeobirYob
    // Check for and finish pending increment in entity table tabEducationFateGeobirYob
    if (om_active && thetabEducationFateGeobirYob) {
        auto & incr = om_tabEducationFateGeobirYob_incr;
        incr.finish_pending();
    }
}
void Person::om_notify_om_duration_FOR_educ_one_fate_X_EOL_LOW()
{

    // Code Injection: group=10, injector=TabEduc15ByDistrict
    // Check for and finish pending increment in entity table TabEduc15ByDistrict
    if (om_active && theTabEduc15ByDistrict) {
        auto & incr = om_TabEduc15ByDistrict_incr;
        incr.finish_pending();
    }

    // Code Injection: group=10, injector=TabEduc15ByDistrictBirth
    // Check for and finish pending increment in entity table TabEduc15ByDistrictBirth
    if (om_active && theTabEduc15ByDistrictBirth) {
        auto & incr = om_TabEduc15ByDistrictBirth_incr;
        incr.finish_pending();
    }

    // Code Injection: group=10, injector=tabEducationFateGeobirYob
    // Check for and finish pending increment in entity table tabEducationFateGeobirYob
    if (om_active && thetabEducationFateGeobirYob) {
        auto & incr = om_tabEducationFateGeobirYob_incr;
        incr.finish_pending();
    }
}
void Person::om_notify_om_duration_FOR_educ_one_fate_X_EOL_MEDIUM()
{

    // Code Injection: group=10, injector=TabEduc15ByDistrict
    // Check for and finish pending increment in entity table TabEduc15ByDistrict
    if (om_active && theTabEduc15ByDistrict) {
        auto & incr = om_TabEduc15ByDistrict_incr;
        incr.finish_pending();
    }

    // Code Injection: group=10, injector=TabEduc15ByDistrictBirth
    // Check for and finish pending increment in entity table TabEduc15ByDistrictBirth
    if (om_active && theTabEduc15ByDistrictBirth) {
        auto & incr = om_TabEduc15ByDistrictBirth_incr;
        incr.finish_pending();
    }

    // Code Injection: group=10, injector=tabEducationFateGeobirYob
    // Check for and finish pending increment in entity table tabEducationFateGeobirYob
    if (om_active && thetabEducationFateGeobirYob) {
        auto & incr = om_tabEducationFateGeobirYob_incr;
        incr.finish_pending();
    }
}
void Person::om_notify_om_duration_FOR_educ_one_level_X_EOL_HIGH()
{

    // Code Injection: group=10, injector=PopPyramidByEduc
    // Check for and finish pending increment in entity table PopPyramidByEduc
    if (om_active && thePopPyramidByEduc) {
        auto & incr = om_PopPyramidByEduc_incr;
        incr.finish_pending();
    }
}
void Person::om_notify_om_duration_FOR_educ_one_level_X_EOL_LOW()
{

    // Code Injection: group=10, injector=PopPyramidByEduc
    // Check for and finish pending increment in entity table PopPyramidByEduc
    if (om_active && thePopPyramidByEduc) {
        auto & incr = om_PopPyramidByEduc_incr;
        incr.finish_pending();
    }
}
void Person::om_notify_om_duration_FOR_educ_one_level_X_EOL_MEDIUM()
{

    // Code Injection: group=10, injector=PopPyramidByEduc
    // Check for and finish pending increment in entity table PopPyramidByEduc
    if (om_active && thePopPyramidByEduc) {
        auto & incr = om_PopPyramidByEduc_incr;
        incr.finish_pending();
    }
}
void Person::om_notify_om_duration_FOR_educ_two_level_X_ETL_GRADUATE()
{

    // Code Injection: group=10, injector=TabSchool2AttainmentsTab
    // Check for and finish pending increment in entity table TabSchool2AttainmentsTab
    if (om_active && theTabSchool2AttainmentsTab) {
        auto & incr = om_TabSchool2AttainmentsTab_incr;
        incr.finish_pending();
    }
}
void Person::om_notify_om_duration_FOR_educ_two_level_X_ETL_INCOMPLETE()
{

    // Code Injection: group=10, injector=TabSchool2AttainmentsTab
    // Check for and finish pending increment in entity table TabSchool2AttainmentsTab
    if (om_active && theTabSchool2AttainmentsTab) {
        auto & incr = om_TabSchool2AttainmentsTab_incr;
        incr.finish_pending();
    }
}
void Person::om_notify_om_duration_FOR_educ_two_level_X_ETL_NEVER()
{

    // Code Injection: group=10, injector=TabSchool2AttainmentsTab
    // Check for and finish pending increment in entity table TabSchool2AttainmentsTab
    if (om_active && theTabSchool2AttainmentsTab) {
        auto & incr = om_TabSchool2AttainmentsTab_incr;
        incr.finish_pending();
    }
}
void Person::om_notify_om_duration_FOR_ever_union_X_true()
{

    // Code Injection: group=10, injector=tabHavingSpouse
    // Check for and finish pending increment in entity table tabHavingSpouse
    if (om_active && thetabHavingSpouse) {
        auto & incr = om_tabHavingSpouse_incr;
        incr.finish_pending();
    }
}
void Person::om_notify_om_duration_FOR_got_prenat_care_X_GPC_YES()
{

    // Code Injection: group=10, injector=TabPrenatCare
    // Check for and finish pending increment in entity table TabPrenatCare
    if (om_active && theTabPrenatCare) {
        auto & incr = om_TabPrenatCare_incr;
        incr.finish_pending();
    }
}
void Person::om_notify_om_duration_FOR_has_spouse_X_true()
{

    // Code Injection: group=10, injector=tabHavingSpouse
    // Check for and finish pending increment in entity table tabHavingSpouse
    if (om_active && thetabHavingSpouse) {
        auto & incr = om_tabHavingSpouse_incr;
        incr.finish_pending();
    }
}
void Person::om_notify_om_duration_FOR_is_aded0_X_true()
{

    // Code Injection: group=10, injector=TabPopProvAgeEducSex
    // Check for and finish pending increment in entity table TabPopProvAgeEducSex
    if (om_active && theTabPopProvAgeEducSex) {
        auto & incr = om_TabPopProvAgeEducSex_incr;
        incr.finish_pending();
    }
}
void Person::om_notify_om_duration_FOR_is_aded1_X_true()
{

    // Code Injection: group=10, injector=TabPopProvAgeEducSex
    // Check for and finish pending increment in entity table TabPopProvAgeEducSex
    if (om_active && theTabPopProvAgeEducSex) {
        auto & incr = om_TabPopProvAgeEducSex_incr;
        incr.finish_pending();
    }
}
void Person::om_notify_om_duration_FOR_is_aded2_X_true()
{

    // Code Injection: group=10, injector=TabPopProvAgeEducSex
    // Check for and finish pending increment in entity table TabPopProvAgeEducSex
    if (om_active && theTabPopProvAgeEducSex) {
        auto & incr = om_TabPopProvAgeEducSex_incr;
        incr.finish_pending();
    }
}
void Person::om_notify_om_duration_FOR_is_child_X_true()
{

    // Code Injection: group=10, injector=TabPopProvAgeEducSex
    // Check for and finish pending increment in entity table TabPopProvAgeEducSex
    if (om_active && theTabPopProvAgeEducSex) {
        auto & incr = om_TabPopProvAgeEducSex_incr;
        incr.finish_pending();
    }
}
void Person::om_notify_om_duration_FOR_is_immunized_X_true()
{

    // Code Injection: group=10, injector=TabChildVaccination
    // Check for and finish pending increment in entity table TabChildVaccination
    if (om_active && theTabChildVaccination) {
        auto & incr = om_TabChildVaccination_incr;
        incr.finish_pending();
    }

    // Code Injection: group=10, injector=TabImmunizationChildren
    // Check for and finish pending increment in entity table TabImmunizationChildren
    if (om_active && theTabImmunizationChildren) {
        auto & incr = om_TabImmunizationChildren_incr;
        incr.finish_pending();
    }
}
void Person::om_notify_om_duration_FOR_is_old_X_true()
{

    // Code Injection: group=10, injector=TabPopProvAgeEducSex
    // Check for and finish pending increment in entity table TabPopProvAgeEducSex
    if (om_active && theTabPopProvAgeEducSex) {
        auto & incr = om_TabPopProvAgeEducSex_incr;
        incr.finish_pending();
    }
}
void Person::om_notify_om_duration_FOR_tab_out_of_primary_X_true()
{

    // Code Injection: group=10, injector=TabPrimSchoolOutOfSchool9to11
    // Check for and finish pending increment in entity table TabPrimSchoolOutOfSchool9to11
    if (om_active && theTabPrimSchoolOutOfSchool9to11) {
        auto & incr = om_TabPrimSchoolOutOfSchool9to11_incr;
        incr.finish_pending();
    }
}
void Person::om_notify_om_duration_FOR_years_preschool_X_0()
{

    // Code Injection: group=10, injector=tabPreSchool
    // Check for and finish pending increment in entity table tabPreSchool
    if (om_active && thetabPreSchool) {
        auto & incr = om_tabPreSchool_incr;
        incr.finish_pending();
    }
}
void Person::om_notify_om_duration_FOR_years_preschool_X_1()
{

    // Code Injection: group=10, injector=tabPreSchool
    // Check for and finish pending increment in entity table tabPreSchool
    if (om_active && thetabPreSchool) {
        auto & incr = om_tabPreSchool_incr;
        incr.finish_pending();
    }
}
void Person::om_notify_om_duration_FOR_years_preschool_X_2()
{

    // Code Injection: group=10, injector=tabPreSchool
    // Check for and finish pending increment in entity table tabPreSchool
    if (om_active && thetabPreSchool) {
        auto & incr = om_tabPreSchool_incr;
        incr.finish_pending();
    }
}
void Person::om_notify_om_entrances_FOR_educ_one_grade_attended_X_1()
{

    // Code Injection: group=10, injector=TabPrimSchoolEntries
    // Check for and finish pending increment in entity table TabPrimSchoolEntries
    if (om_active && theTabPrimSchoolEntries) {
        auto & incr = om_TabPrimSchoolEntries_incr;
        incr.finish_pending();
    }
}
void Person::om_notify_om_entrances_FOR_has_passed_primary_X_true()
{

    // Code Injection: group=10, injector=TabPrimSchoolGraduations
    // Check for and finish pending increment in entity table TabPrimSchoolGraduations
    if (om_active && theTabPrimSchoolGraduations) {
        auto & incr = om_TabPrimSchoolGraduations_incr;
        incr.finish_pending();
    }
}
void Person::om_notify_om_mlHHFatherChildren_count()
{
}
void Person::om_notify_om_mlHHFatherChildren_sum_over_is_alive()
{
}
void Person::om_notify_om_mlHHMotherChildren_count()
{
}
void Person::om_notify_om_mlHHMotherChildren_min_over_integer_age()
{
}
void Person::om_notify_om_mlHHMotherChildren_sum_over_is_alive()
{
}
void Person::om_notify_om_self_scheduling_split_FOR_age_X_AGE_MIG_PART()
{
}
void Person::om_notify_om_self_scheduling_split_FOR_om_active_spell_duration_FOR_this_parity_spell_X_true_X_DUR_TIME_IN_PARITY()
{
}
void Person::om_notify_om_split_FOR_age_last_birth_X_MOTH_AGEGR_PART()
{
}
void Person::om_notify_om_split_FOR_age_youngest_child_X_CHILD_AGEGR_PART()
{
}
void Person::om_notify_om_split_FOR_integer_age_X_TAB_AGEC5()
{

    // Code Injection: group=10, injector=PopPyramidByEduc
    // Check for and finish pending increment in entity table PopPyramidByEduc
    if (om_active && thePopPyramidByEduc) {
        auto & incr = om_PopPyramidByEduc_incr;
        incr.finish_pending();
    }
}
void Person::om_notify_om_transitions_FOR_integer_age_X_14_X_15()
{

    // Code Injection: group=10, injector=TabHCIDistrict
    // Check for and finish pending increment in entity table TabHCIDistrict
    if (om_active && theTabHCIDistrict) {
        auto & incr = om_TabHCIDistrict_incr;
        incr.finish_pending();
    }

    // Code Injection: group=10, injector=tabHCI
    // Check for and finish pending increment in entity table tabHCI
    if (om_active && thetabHCI) {
        auto & incr = om_tabHCI_incr;
        incr.finish_pending();
    }
}
void Person::om_notify_om_transitions_FOR_is_alive_X_false_X_true()
{

    // Code Injection: group=10, injector=tabBirthsYearPlace
    // Check for and finish pending increment in entity table tabBirthsYearPlace
    if (om_active && thetabBirthsYearPlace) {
        auto & incr = om_tabBirthsYearPlace_incr;
        incr.finish_pending();
    }
}
void Person::om_notify_om_transitions_FOR_is_alive_X_true_X_false()
{

    // Code Injection: group=10, injector=TabHCIDistrict
    // Check for and finish pending increment in entity table TabHCIDistrict
    if (om_active && theTabHCIDistrict) {
        auto & incr = om_TabHCIDistrict_incr;
        incr.finish_pending();
    }

    // Code Injection: group=10, injector=tabHCI
    // Check for and finish pending increment in entity table tabHCI
    if (om_active && thetabHCI) {
        auto & incr = om_tabHCI_incr;
        incr.finish_pending();
    }
}
void Person::om_notify_om_transitions_FOR_survived_early_years_X_false_X_true()
{

    // Code Injection: group=10, injector=TabHCIDistrict
    // Check for and finish pending increment in entity table TabHCIDistrict
    if (om_active && theTabHCIDistrict) {
        auto & incr = om_TabHCIDistrict_incr;
        incr.finish_pending();
    }

    // Code Injection: group=10, injector=tabHCI
    // Check for and finish pending increment in entity table tabHCI
    if (om_active && thetabHCI) {
        auto & incr = om_tabHCI_incr;
        incr.finish_pending();
    }
}
void Person::om_notify_om_trigger_changes_FOR_calendar_year()
{
}
void Person::om_notify_om_trigger_changes_FOR_geo()
{
}
void Person::om_notify_om_trigger_entrances_FOR_is_ready_for_birthtables_X_true()
{
}
void Person::om_notify_om_value_at_transitions_FOR_is_alive_X_true_X_adult_survival_X_false()
{

    // Code Injection: group=10, injector=TabHCIDistrict
    // Check for and finish pending increment in entity table TabHCIDistrict
    if (om_active && theTabHCIDistrict) {
        auto & incr = om_TabHCIDistrict_incr;
        incr.finish_pending();
    }

    // Code Injection: group=10, injector=tabHCI
    // Check for and finish pending increment in entity table tabHCI
    if (om_active && thetabHCI) {
        auto & incr = om_tabHCI_incr;
        incr.finish_pending();
    }
}
void Person::om_notify_om_value_at_transitions_FOR_is_alive_X_true_X_ind_hci_X_false()
{

    // Code Injection: group=10, injector=TabHCIDistrict
    // Check for and finish pending increment in entity table TabHCIDistrict
    if (om_active && theTabHCIDistrict) {
        auto & incr = om_TabHCIDistrict_incr;
        incr.finish_pending();
    }

    // Code Injection: group=10, injector=tabHCI
    // Check for and finish pending increment in entity table tabHCI
    if (om_active && thetabHCI) {
        auto & incr = om_tabHCI_incr;
        incr.finish_pending();
    }
}
void Person::om_notify_om_value_at_transitions_FOR_is_alive_X_true_X_is_stunted_X_false()
{

    // Code Injection: group=10, injector=TabHCIDistrict
    // Check for and finish pending increment in entity table TabHCIDistrict
    if (om_active && theTabHCIDistrict) {
        auto & incr = om_TabHCIDistrict_incr;
        incr.finish_pending();
    }

    // Code Injection: group=10, injector=tabHCI
    // Check for and finish pending increment in entity table tabHCI
    if (om_active && thetabHCI) {
        auto & incr = om_tabHCI_incr;
        incr.finish_pending();
    }
}
void Person::om_notify_om_value_at_transitions_FOR_is_alive_X_true_X_quality_of_schooling_X_false()
{

    // Code Injection: group=10, injector=TabHCIDistrict
    // Check for and finish pending increment in entity table TabHCIDistrict
    if (om_active && theTabHCIDistrict) {
        auto & incr = om_TabHCIDistrict_incr;
        incr.finish_pending();
    }

    // Code Injection: group=10, injector=tabHCI
    // Check for and finish pending increment in entity table tabHCI
    if (om_active && thetabHCI) {
        auto & incr = om_tabHCI_incr;
        incr.finish_pending();
    }
}
void Person::om_notify_om_value_at_transitions_FOR_is_alive_X_true_X_survived_early_years_X_false()
{

    // Code Injection: group=10, injector=TabHCIDistrict
    // Check for and finish pending increment in entity table TabHCIDistrict
    if (om_active && theTabHCIDistrict) {
        auto & incr = om_TabHCIDistrict_incr;
        incr.finish_pending();
    }

    // Code Injection: group=10, injector=tabHCI
    // Check for and finish pending increment in entity table tabHCI
    if (om_active && thetabHCI) {
        auto & incr = om_tabHCI_incr;
        incr.finish_pending();
    }
}
void Person::om_notify_om_value_at_transitions_FOR_is_alive_X_true_X_years_of_schooling_X_false()
{

    // Code Injection: group=10, injector=TabHCIDistrict
    // Check for and finish pending increment in entity table TabHCIDistrict
    if (om_active && theTabHCIDistrict) {
        auto & incr = om_TabHCIDistrict_incr;
        incr.finish_pending();
    }

    // Code Injection: group=10, injector=tabHCI
    // Check for and finish pending increment in entity table tabHCI
    if (om_active && thetabHCI) {
        auto & incr = om_tabHCI_incr;
        incr.finish_pending();
    }
}
void Person::om_notify_parity()
{
}
void Person::om_notify_preschool_is_decided()
{
}
void Person::om_notify_quality_adjusted_schooling()
{
}
void Person::om_notify_quality_of_schooling()
{
}
void Person::om_notify_ready_to_set_alive()
{
}
void Person::om_notify_region_birth()
{
}
void Person::om_notify_region_int()
{
}
void Person::om_notify_region_nat()
{

    // Code Injection: group=10, injector=TabChildVaccination
    // Check for and finish pending increment in entity table TabChildVaccination
    if (om_active && theTabChildVaccination) {
        auto & incr = om_TabChildVaccination_incr;
        incr.finish_pending();
    }

    // Code Injection: group=10, injector=TabImmunizationChildren
    // Check for and finish pending increment in entity table TabImmunizationChildren
    if (om_active && theTabImmunizationChildren) {
        auto & incr = om_TabImmunizationChildren_incr;
        incr.finish_pending();
    }

    // Code Injection: group=10, injector=TabPrenatCare
    // Check for and finish pending increment in entity table TabPrenatCare
    if (om_active && theTabPrenatCare) {
        auto & incr = om_TabPrenatCare_incr;
        incr.finish_pending();
    }

    // Code Injection: group=10, injector=tabStuntingSexRegMotherYob
    // Check for and finish pending increment in entity table tabStuntingSexRegMotherYob
    if (om_active && thetabStuntingSexRegMotherYob) {
        auto & incr = om_tabStuntingSexRegMotherYob_incr;
        incr.finish_pending();
    }

    // Code Injection: group=10, injector=tabStuntingSexRegYob
    // Check for and finish pending increment in entity table tabStuntingSexRegYob
    if (om_active && thetabStuntingSexRegYob) {
        auto & incr = om_tabStuntingSexRegYob_incr;
        incr.finish_pending();
    }
}
void Person::om_notify_sel_years()
{

    // Code Injection: group=10, injector=PopPyramidByEduc
    // Check for and finish pending increment in entity table PopPyramidByEduc
    if (om_active && thePopPyramidByEduc) {
        auto & incr = om_PopPyramidByEduc_incr;
        incr.finish_pending();
    }
}
void Person::om_notify_selected_year10()
{

    // Code Injection: group=10, injector=tabMigrationOriginDestination
    // Check for and finish pending increment in entity table tabMigrationOriginDestination
    if (om_active && thetabMigrationOriginDestination) {
        auto & incr = om_tabMigrationOriginDestination_incr;
        incr.finish_pending();
    }
}
void Person::om_notify_sex()
{

    // Code Injection: group=10, injector=PopPyramidByEduc
    // Check for and finish pending increment in entity table PopPyramidByEduc
    if (om_active && thePopPyramidByEduc) {
        auto & incr = om_PopPyramidByEduc_incr;
        incr.finish_pending();
    }

    // Code Injection: group=10, injector=TabEduc15ByDistrict
    // Check for and finish pending increment in entity table TabEduc15ByDistrict
    if (om_active && theTabEduc15ByDistrict) {
        auto & incr = om_TabEduc15ByDistrict_incr;
        incr.finish_pending();
    }

    // Code Injection: group=10, injector=TabEduc15ByDistrictBirth
    // Check for and finish pending increment in entity table TabEduc15ByDistrictBirth
    if (om_active && theTabEduc15ByDistrictBirth) {
        auto & incr = om_TabEduc15ByDistrictBirth_incr;
        incr.finish_pending();
    }

    // Code Injection: group=10, injector=TabHCIDistrict
    // Check for and finish pending increment in entity table TabHCIDistrict
    if (om_active && theTabHCIDistrict) {
        auto & incr = om_TabHCIDistrict_incr;
        incr.finish_pending();
    }

    // Code Injection: group=10, injector=TabImmunizationChildren
    // Check for and finish pending increment in entity table TabImmunizationChildren
    if (om_active && theTabImmunizationChildren) {
        auto & incr = om_TabImmunizationChildren_incr;
        incr.finish_pending();
    }

    // Code Injection: group=10, injector=TabPopProvAgeEducSex
    // Check for and finish pending increment in entity table TabPopProvAgeEducSex
    if (om_active && theTabPopProvAgeEducSex) {
        auto & incr = om_TabPopProvAgeEducSex_incr;
        incr.finish_pending();
    }

    // Code Injection: group=10, injector=TabSchool2AttainmentsTab
    // Check for and finish pending increment in entity table TabSchool2AttainmentsTab
    if (om_active && theTabSchool2AttainmentsTab) {
        auto & incr = om_TabSchool2AttainmentsTab_incr;
        incr.finish_pending();
    }

    // Code Injection: group=10, injector=tabEducationFateGeobirYob
    // Check for and finish pending increment in entity table tabEducationFateGeobirYob
    if (om_active && thetabEducationFateGeobirYob) {
        auto & incr = om_tabEducationFateGeobirYob_incr;
        incr.finish_pending();
    }

    // Code Injection: group=10, injector=tabHCI
    // Check for and finish pending increment in entity table tabHCI
    if (om_active && thetabHCI) {
        auto & incr = om_tabHCI_incr;
        incr.finish_pending();
    }

    // Code Injection: group=10, injector=tabHavingSpouse
    // Check for and finish pending increment in entity table tabHavingSpouse
    if (om_active && thetabHavingSpouse) {
        auto & incr = om_tabHavingSpouse_incr;
        incr.finish_pending();
    }

    // Code Injection: group=10, injector=tabStuntingSexRegMotherYob
    // Check for and finish pending increment in entity table tabStuntingSexRegMotherYob
    if (om_active && thetabStuntingSexRegMotherYob) {
        auto & incr = om_tabStuntingSexRegMotherYob_incr;
        incr.finish_pending();
    }
}
void Person::om_notify_sim_year()
{

    // Code Injection: group=10, injector=TabChildVaccination
    // Check for and finish pending increment in entity table TabChildVaccination
    if (om_active && theTabChildVaccination) {
        auto & incr = om_TabChildVaccination_incr;
        incr.finish_pending();
    }

    // Code Injection: group=10, injector=TabEduc15ByDistrict
    // Check for and finish pending increment in entity table TabEduc15ByDistrict
    if (om_active && theTabEduc15ByDistrict) {
        auto & incr = om_TabEduc15ByDistrict_incr;
        incr.finish_pending();
    }

    // Code Injection: group=10, injector=TabEduc15ByDistrictBirth
    // Check for and finish pending increment in entity table TabEduc15ByDistrictBirth
    if (om_active && theTabEduc15ByDistrictBirth) {
        auto & incr = om_TabEduc15ByDistrictBirth_incr;
        incr.finish_pending();
    }

    // Code Injection: group=10, injector=TabImmunizationChildren
    // Check for and finish pending increment in entity table TabImmunizationChildren
    if (om_active && theTabImmunizationChildren) {
        auto & incr = om_TabImmunizationChildren_incr;
        incr.finish_pending();
    }

    // Code Injection: group=10, injector=TabPopProvAgeEducSex
    // Check for and finish pending increment in entity table TabPopProvAgeEducSex
    if (om_active && theTabPopProvAgeEducSex) {
        auto & incr = om_TabPopProvAgeEducSex_incr;
        incr.finish_pending();
    }

    // Code Injection: group=10, injector=TabPrenatCare
    // Check for and finish pending increment in entity table TabPrenatCare
    if (om_active && theTabPrenatCare) {
        auto & incr = om_TabPrenatCare_incr;
        incr.finish_pending();
    }

    // Code Injection: group=10, injector=TabPrimSchoolEntries
    // Check for and finish pending increment in entity table TabPrimSchoolEntries
    if (om_active && theTabPrimSchoolEntries) {
        auto & incr = om_TabPrimSchoolEntries_incr;
        incr.finish_pending();
    }

    // Code Injection: group=10, injector=TabPrimSchoolGraduations
    // Check for and finish pending increment in entity table TabPrimSchoolGraduations
    if (om_active && theTabPrimSchoolGraduations) {
        auto & incr = om_TabPrimSchoolGraduations_incr;
        incr.finish_pending();
    }

    // Code Injection: group=10, injector=TabPrimSchoolOutOfSchool9to11
    // Check for and finish pending increment in entity table TabPrimSchoolOutOfSchool9to11
    if (om_active && theTabPrimSchoolOutOfSchool9to11) {
        auto & incr = om_TabPrimSchoolOutOfSchool9to11_incr;
        incr.finish_pending();
    }

    // Code Injection: group=10, injector=TabPrimarySchoolPlanning
    // Check for and finish pending increment in entity table TabPrimarySchoolPlanning
    if (om_active && theTabPrimarySchoolPlanning) {
        auto & incr = om_TabPrimarySchoolPlanning_incr;
        incr.finish_pending();
    }

    // Code Injection: group=10, injector=TabSchool2AttainmentsTab
    // Check for and finish pending increment in entity table TabSchool2AttainmentsTab
    if (om_active && theTabSchool2AttainmentsTab) {
        auto & incr = om_TabSchool2AttainmentsTab_incr;
        incr.finish_pending();
    }

    // Code Injection: group=10, injector=TabSchool2TrackTab
    // Check for and finish pending increment in entity table TabSchool2TrackTab
    if (om_active && theTabSchool2TrackTab) {
        auto & incr = om_TabSchool2TrackTab_incr;
        incr.finish_pending();
    }

    // Code Injection: group=10, injector=tabBirthsYearPlace
    // Check for and finish pending increment in entity table tabBirthsYearPlace
    if (om_active && thetabBirthsYearPlace) {
        auto & incr = om_tabBirthsYearPlace_incr;
        incr.finish_pending();
    }

    // Code Injection: group=10, injector=tabHavingSpouse
    // Check for and finish pending increment in entity table tabHavingSpouse
    if (om_active && thetabHavingSpouse) {
        auto & incr = om_tabHavingSpouse_incr;
        incr.finish_pending();
    }

    // Code Injection: group=10, injector=tabPopulationYearPlace
    // Check for and finish pending increment in entity table tabPopulationYearPlace
    if (om_active && thetabPopulationYearPlace) {
        auto & incr = om_tabPopulationYearPlace_incr;
        incr.finish_pending();
    }

    // Code Injection: group=10, injector=tabStuntingSexRegMotherYob
    // Check for and finish pending increment in entity table tabStuntingSexRegMotherYob
    if (om_active && thetabStuntingSexRegMotherYob) {
        auto & incr = om_tabStuntingSexRegMotherYob_incr;
        incr.finish_pending();
    }

    // Code Injection: group=10, injector=tabStuntingSexRegYob
    // Check for and finish pending increment in entity table tabStuntingSexRegYob
    if (om_active && thetabStuntingSexRegYob) {
        auto & incr = om_tabStuntingSexRegYob_incr;
        incr.finish_pending();
    }
}
void Person::om_notify_spouse_group()
{
}
void Person::om_notify_survived_early_years()
{
}
void Person::om_notify_tab_out_of_primary()
{
}
void Person::om_notify_tab_sim_yob()
{

    // Code Injection: group=10, injector=TabEducFateByGroup
    // Check for and finish pending increment in entity table TabEducFateByGroup
    if (om_active && theTabEducFateByGroup) {
        auto & incr = om_TabEducFateByGroup_incr;
        incr.finish_pending();
    }

    // Code Injection: group=10, injector=TabHCIDistrict
    // Check for and finish pending increment in entity table TabHCIDistrict
    if (om_active && theTabHCIDistrict) {
        auto & incr = om_TabHCIDistrict_incr;
        incr.finish_pending();
    }

    // Code Injection: group=10, injector=tabHCI
    // Check for and finish pending increment in entity table tabHCI
    if (om_active && thetabHCI) {
        auto & incr = om_tabHCI_incr;
        incr.finish_pending();
    }

    // Code Injection: group=10, injector=tabPreSchool
    // Check for and finish pending increment in entity table tabPreSchool
    if (om_active && thetabPreSchool) {
        auto & incr = om_tabPreSchool_incr;
        incr.finish_pending();
    }
}
void Person::om_notify_this_parity_spell()
{
}
void Person::om_notify_time()
{
}
void Person::om_notify_time_first_move()
{
}
void Person::om_notify_time_in_parity()
{
}
void Person::om_notify_time_last_move()
{
}
void Person::om_notify_time_next_birthday()
{
}
void Person::om_notify_time_of_birth()
{
}
void Person::om_notify_time_of_first_immigration()
{
}
void Person::om_notify_union1_group()
{
}
void Person::om_notify_year_of_birth()
{

    // Code Injection: group=10, injector=TabEducFateDistrYob
    // Check for and finish pending increment in entity table TabEducFateDistrYob
    if (om_active && theTabEducFateDistrYob) {
        auto & incr = om_TabEducFateDistrYob_incr;
        incr.finish_pending();
    }

    // Code Injection: group=10, injector=tabEducationFateGeobirYob
    // Check for and finish pending increment in entity table tabEducationFateGeobirYob
    if (om_active && thetabEducationFateGeobirYob) {
        auto & incr = om_tabEducationFateGeobirYob_incr;
        incr.finish_pending();
    }
}
void Person::om_notify_year_of_first_immigration()
{
}
void Person::om_notify_years_of_schooling()
{
}
void Person::om_notify_years_preschool()
{
}
void Person::om_reset_derived_attributes()
{

    // Code Injection: group=1, injector=trigger_changes(calendar_year)
    {
        auto & ss_attr = om_trigger_changes_FOR_calendar_year; // the self-scheduling attribute being maintained
        auto & ss_time = om_ss_time_om_trigger_changes_FOR_calendar_year; // The scheduled time of maintenance of this self-scheduling attribute

        // There is no change in the triggering condition when the entity enters the simulation.
        ss_time = time_infinite;
        ss_attr.set(false);
    }

    // Code Injection: group=1, injector=trigger_changes(geo)
    {
        auto & ss_attr = om_trigger_changes_FOR_geo; // the self-scheduling attribute being maintained
        auto & ss_time = om_ss_time_om_trigger_changes_FOR_geo; // The scheduled time of maintenance of this self-scheduling attribute

        // There is no change in the triggering condition when the entity enters the simulation.
        ss_time = time_infinite;
        ss_attr.set(false);
    }

    // Code Injection: group=1, injector=trigger_entrances(is_ready_for_birthtables, true)
    {
        auto & ss_attr = om_trigger_entrances_FOR_is_ready_for_birthtables_X_true; // the self-scheduling attribute being maintained
        auto & ss_time = om_ss_time_om_trigger_entrances_FOR_is_ready_for_birthtables_X_true; // The scheduled time of maintenance of this self-scheduling attribute

        // There is no change in the triggering condition when the entity enters the simulation.
        ss_time = time_infinite;
        ss_attr.set(false);
    }

    // Code Injection: group=5, injector=entrances(educ_one_grade_attended, 1)
    // Re-assign starting value for simulation entry
    om_entrances_FOR_educ_one_grade_attended_X_1.initialize( 0 );

    // Code Injection: group=5, injector=entrances(has_passed_primary, true)
    // Re-assign starting value for simulation entry
    om_entrances_FOR_has_passed_primary_X_true.initialize( 0 );

    // Code Injection: group=5, injector=self_scheduling_split(active_spell_duration(this_parity_spell, true), DUR_TIME_IN_PARITY)
    {
        auto & ss_attr = om_self_scheduling_split_FOR_om_active_spell_duration_FOR_this_parity_spell_X_true_X_DUR_TIME_IN_PARITY;
        auto & ss_time = om_ss_time_om_self_scheduling_split_FOR_om_active_spell_duration_FOR_this_parity_spell_X_true_X_DUR_TIME_IN_PARITY;
        auto part = ss_attr.get(); // working copy of partition
        // No spells are active at simulation entry
        ss_time = time_infinite;
        // Set the partitioned duration to the interval containing zero.
        part.set_from_value(0);
        ss_attr.set(part);
    }

    // Code Injection: group=5, injector=transitions(integer_age, 14, 15)
    // Re-assign starting value for simulation entry
    om_transitions_FOR_integer_age_X_14_X_15.initialize( 0 );

    // Code Injection: group=5, injector=transitions(is_alive, false, true)
    // Re-assign starting value for simulation entry
    om_transitions_FOR_is_alive_X_false_X_true.initialize( 0 );

    // Code Injection: group=5, injector=transitions(is_alive, true, false)
    // Re-assign starting value for simulation entry
    om_transitions_FOR_is_alive_X_true_X_false.initialize( 0 );

    // Code Injection: group=5, injector=transitions(survived_early_years, false, true)
    // Re-assign starting value for simulation entry
    om_transitions_FOR_survived_early_years_X_false_X_true.initialize( 0 );

    // Code Injection: group=5, injector=value_at_transitions(is_alive, true, false, adult_survival)
    // Re-assign starting value for simulation entry
    om_value_at_transitions_FOR_is_alive_X_true_X_adult_survival_X_false.initialize( 0 );

    // Code Injection: group=5, injector=value_at_transitions(is_alive, true, false, ind_hci)
    // Re-assign starting value for simulation entry
    om_value_at_transitions_FOR_is_alive_X_true_X_ind_hci_X_false.initialize( 0 );

    // Code Injection: group=5, injector=value_at_transitions(is_alive, true, false, is_stunted)
    // Re-assign starting value for simulation entry
    om_value_at_transitions_FOR_is_alive_X_true_X_is_stunted_X_false.initialize( 0 );

    // Code Injection: group=5, injector=value_at_transitions(is_alive, true, false, quality_of_schooling)
    // Re-assign starting value for simulation entry
    om_value_at_transitions_FOR_is_alive_X_true_X_quality_of_schooling_X_false.initialize( 0 );

    // Code Injection: group=5, injector=value_at_transitions(is_alive, true, false, survived_early_years)
    // Re-assign starting value for simulation entry
    om_value_at_transitions_FOR_is_alive_X_true_X_survived_early_years_X_false.initialize( 0 );

    // Code Injection: group=5, injector=value_at_transitions(is_alive, true, false, years_of_schooling)
    // Re-assign starting value for simulation entry
    om_value_at_transitions_FOR_is_alive_X_true_X_years_of_schooling_X_false.initialize( 0 );
}
void Person::om_set_entity_id()
{
    entity_id.set(get_next_entity_id());
}
void Person::om_side_effects_adult_survival(double om_old, double om_new)
{
}
void Person::om_side_effects_age(Time om_old, Time om_new)
{

    // Code Injection: group=5, injector=self_scheduling_split(age, AGE_MIG_PART)
    if (!om_active) {
        // Initial values are being assigned.
        auto & ss_attr = om_self_scheduling_split_FOR_age_X_AGE_MIG_PART;
        auto & ss_time = om_ss_time_om_self_scheduling_split_FOR_age_X_AGE_MIG_PART;
        auto part = ss_attr.get(); // working copy of partition
        // Initial value is the corresponding partition interval.
        part.set_from_value(age.get());
        ss_attr.set(part);
        // Time to wait for next change is the remaining time to get to upper bound of current interval in partition.
        if (part.upper() == REAL_MAX) ss_time = time_infinite;
        else ss_time = time + (part.upper() - age.get());
    }
}
void Person::om_side_effects_age_last_birth(double om_old, double om_new)
{

    // Code Injection: group=5, injector=split(age_last_birth, MOTH_AGEGR_PART)
    {
        // Maintain split(age_last_birth, MOTH_AGEGR_PART)
        om_split_FOR_age_last_birth_X_MOTH_AGEGR_PART.set(MOTH_AGEGR_PART::value_to_interval((real)age_last_birth));
    }
}
void Person::om_side_effects_age_mig(AGE_MIG om_old, AGE_MIG om_new)
{

    // Code Injection: group=10, injector=om_EmigrationEvent_om_event
    // Recalculate time to event EmigrationEvent
    if (om_active) om_EmigrationEvent_om_event.make_dirty();

    // Code Injection: group=10, injector=om_MigrationEvent_om_event
    // Recalculate time to event MigrationEvent
    if (om_active) om_MigrationEvent_om_event.make_dirty();

    // Code Injection: group=10, injector=asWantToMove
    // cell change in asWantToMove
    if (om_active) {
        if (om_asWantToMove_filter) {
            om_asWantToMove_erase();
            om_asWantToMove_update_cell();
            om_asWantToMove_insert();
        }
    }
}
void Person::om_side_effects_age_youngest_child(double om_old, double om_new)
{

    // Code Injection: group=5, injector=split(age_youngest_child, CHILD_AGEGR_PART)
    {
        // Maintain split(age_youngest_child, CHILD_AGEGR_PART)
        om_split_FOR_age_youngest_child_X_CHILD_AGEGR_PART.set(CHILD_AGEGR_PART::value_to_interval((real)age_youngest_child));
    }

    // Code Injection: group=8, injector=age_last_birth
    // Maintain identity for 'age_last_birth'
    age_last_birth_update_identity();
}
void Person::om_side_effects_all_year(ALL_YEAR_RANGE om_old, ALL_YEAR_RANGE om_new)
{
}
void Person::om_side_effects_calendar_year(ALL_YEAR_RANGE om_old, ALL_YEAR_RANGE om_new)
{

    // Code Injection: group=1, injector=trigger_changes(calendar_year)
    if (om_active) {
        auto & ss_attr = om_trigger_changes_FOR_calendar_year; // the self-scheduling attribute being maintained
        auto & ss_time = om_ss_time_om_trigger_changes_FOR_calendar_year; // the scheduled time of maintenance of this self-scheduling attribute
        auto & ss_event = zzz_om_om_ss_event_om_event; // the single event in the entity which maintains all self-scheduling attributes

        // Activate trigger trigger_changes(calendar_year)
        ss_attr.set(true);
        // Set the self-scheduling event to reset the trigger immediately
        ss_time = time;
        // Mark the entity's self-scheduling event for recalculation
        ss_event.make_dirty();
    }

    // Code Injection: group=8, injector=all_year
    // Maintain identity for 'all_year'
    all_year_update_identity();

    // Code Injection: group=8, injector=educ_one_required_rooms
    // Maintain identity for 'educ_one_required_rooms'
    educ_one_required_rooms_update_identity();

    // Code Injection: group=8, injector=educ_one_required_teachers
    // Maintain identity for 'educ_one_required_teachers'
    educ_one_required_teachers_update_identity();

    // Code Injection: group=8, injector=in_projected_time
    // Maintain identity for 'in_projected_time'
    in_projected_time_update_identity();

    // Code Injection: group=8, injector=in_sel_years
    // Maintain identity for 'in_sel_years'
    in_sel_years_update_identity();

    // Code Injection: group=8, injector=in_selected_year
    // Maintain identity for 'in_selected_year'
    in_selected_year_update_identity();

    // Code Injection: group=8, injector=is_fertile
    // Maintain identity for 'is_fertile'
    is_fertile_update_identity();

    // Code Injection: group=8, injector=is_mortal
    // Maintain identity for 'is_mortal'
    is_mortal_update_identity();

    // Code Injection: group=8, injector=om_aia_30
    // Maintain identity for 'om_aia_30'
    om_aia_30_update_identity();

    // Code Injection: group=8, injector=om_aia_34
    // Maintain identity for 'om_aia_34'
    om_aia_34_update_identity();

    // Code Injection: group=8, injector=om_aia_35
    // Maintain identity for 'om_aia_35'
    om_aia_35_update_identity();

    // Code Injection: group=8, injector=sel_years
    // Maintain identity for 'sel_years'
    sel_years_update_identity();

    // Code Injection: group=8, injector=selected_year10
    // Maintain identity for 'selected_year10'
    selected_year10_update_identity();

    // Code Injection: group=8, injector=sim_year
    // Maintain identity for 'sim_year'
    sim_year_update_identity();

    // Code Injection: group=10, injector=om_BackMigrationEvent_om_event
    // Recalculate time to event BackMigrationEvent
    if (om_active) om_BackMigrationEvent_om_event.make_dirty();

    // Code Injection: group=10, injector=om_FertilityBaseEvent_om_event
    // Recalculate time to event FertilityBaseEvent
    if (om_active) om_FertilityBaseEvent_om_event.make_dirty();

    // Code Injection: group=10, injector=om_FertilityDetailedEvent_om_event
    // Recalculate time to event FertilityDetailedEvent
    if (om_active) om_FertilityDetailedEvent_om_event.make_dirty();

    // Code Injection: group=10, injector=om_FirstUnionFormationEvent_om_event
    // Recalculate time to event FirstUnionFormationEvent
    if (om_active) om_FirstUnionFormationEvent_om_event.make_dirty();

    // Code Injection: group=10, injector=om_MigrationEvent_om_event
    // Recalculate time to event MigrationEvent
    if (om_active) om_MigrationEvent_om_event.make_dirty();

    // Code Injection: group=10, injector=om_MortalityBaseEvent_om_event
    // Recalculate time to event MortalityBaseEvent
    if (om_active) om_MortalityBaseEvent_om_event.make_dirty();

    // Code Injection: group=10, injector=om_MortalityDetailedEvent_om_event
    // Recalculate time to event MortalityDetailedEvent
    if (om_active) om_MortalityDetailedEvent_om_event.make_dirty();
}
void Person::om_side_effects_case_seed(double om_old, double om_new)
{
}
void Person::om_side_effects_child_agegr(CHILD_AGEGR om_old, CHILD_AGEGR om_new)
{

    // Code Injection: group=10, injector=asWomenWithChildren
    // cell change in asWomenWithChildren
    if (om_active) {
        if (om_asWomenWithChildren_filter) {
            om_asWomenWithChildren_erase();
            om_asWomenWithChildren_update_cell();
            om_asWomenWithChildren_insert();
        }
    }
}
void Person::om_side_effects_child_agegr_part(int om_old, int om_new)
{

    // Code Injection: group=8, injector=child_agegr
    // Maintain identity for 'child_agegr'
    child_agegr_update_identity();
}
void Person::om_side_effects_child_mortality(double om_old, double om_new)
{

    // Code Injection: group=10, injector=om_MortalityDetailedEvent_om_event
    // Recalculate time to event MortalityDetailedEvent
    if (om_active) om_MortalityDetailedEvent_om_event.make_dirty();
}
void Person::om_side_effects_child_mortality_group(CHILD_MORTALITY_GROUP om_old, CHILD_MORTALITY_GROUP om_new)
{

    // Code Injection: group=10, injector=om_MortalityDetailedEvent_om_event
    // Recalculate time to event MortalityDetailedEvent
    if (om_active) om_MortalityDetailedEvent_om_event.make_dirty();
}
void Person::om_side_effects_children_in_household(short om_old, short om_new)
{
}
void Person::om_side_effects_creation_type(CREATION_TYPE om_old, CREATION_TYPE om_new)
{

    // Code Injection: group=8, injector=in_hci_sample
    // Maintain identity for 'in_hci_sample'
    in_hci_sample_update_identity();

    // Code Injection: group=8, injector=is_fertile
    // Maintain identity for 'is_fertile'
    is_fertile_update_identity();

    // Code Injection: group=8, injector=is_mortal
    // Maintain identity for 'is_mortal'
    is_mortal_update_identity();

    // Code Injection: group=8, injector=om_aia_13
    // Maintain identity for 'om_aia_13'
    om_aia_13_update_identity();

    // Code Injection: group=8, injector=om_aia_36
    // Maintain identity for 'om_aia_36'
    om_aia_36_update_identity();

    // Code Injection: group=8, injector=om_aia_37
    // Maintain identity for 'om_aia_37'
    om_aia_37_update_identity();

    // Code Injection: group=8, injector=om_aia_40
    // Maintain identity for 'om_aia_40'
    om_aia_40_update_identity();

    // Code Injection: group=8, injector=om_asAvailableMaleByTypeImmiScratch_filter
    // Maintain identity for 'om_asAvailableMaleByTypeImmiScratch_filter'
    om_asAvailableMaleByTypeImmiScratch_filter_update_identity();

    // Code Injection: group=8, injector=om_asAvailableMaleImmiScratch_filter
    // Maintain identity for 'om_asAvailableMaleImmiScratch_filter'
    om_asAvailableMaleImmiScratch_filter_update_identity();

    // Code Injection: group=8, injector=om_asFemaleInUnionByAgeAndPartnerAgeImmiScratch_filter
    // Maintain identity for 'om_asFemaleInUnionByAgeAndPartnerAgeImmiScratch_filter'
    om_asFemaleInUnionByAgeAndPartnerAgeImmiScratch_filter_update_identity();

    // Code Injection: group=8, injector=om_asPotentialImmigrantMothers_filter
    // Maintain identity for 'om_asPotentialImmigrantMothers_filter'
    om_asPotentialImmigrantMothers_filter_update_identity();

    // Code Injection: group=8, injector=om_asResidentBabies_filter
    // Maintain identity for 'om_asResidentBabies_filter'
    om_asResidentBabies_filter_update_identity();

    // Code Injection: group=8, injector=om_asSimBornAge0_filter
    // Maintain identity for 'om_asSimBornAge0_filter'
    om_asSimBornAge0_filter_update_identity();

    // Code Injection: group=10, injector=om_FirstImmigrationFromPoolEvent_om_event
    // Recalculate time to event FirstImmigrationFromPoolEvent
    if (om_active) om_FirstImmigrationFromPoolEvent_om_event.make_dirty();

    // Code Injection: group=10, injector=om_FirstImmigrationFromScratchEvent_om_event
    // Recalculate time to event FirstImmigrationFromScratchEvent
    if (om_active) om_FirstImmigrationFromScratchEvent_om_event.make_dirty();

    // Code Injection: group=10, injector=om_FirstUnionFormationEvent_om_event
    // Recalculate time to event FirstUnionFormationEvent
    if (om_active) om_FirstUnionFormationEvent_om_event.make_dirty();

    // Code Injection: group=10, injector=om_SetPreschoolYearsEvent_om_event
    // Recalculate time to event SetPreschoolYearsEvent
    if (om_active) om_SetPreschoolYearsEvent_om_event.make_dirty();
}
void Person::om_side_effects_educ1_group(EDUC1_GROUP om_old, EDUC1_GROUP om_new)
{

    // Code Injection: group=10, injector=TabEducFateByGroup
    // Cell change in TabEducFateByGroup
    if (om_active && theTabEducFateByGroup) {
        // Check and start pending increment in entity table TabEducFateByGroup
        auto cell = om_TabEducFateByGroup_current_cell();
        auto & incr = om_TabEducFateByGroup_incr;
        incr.set_cell(cell);
        incr.start_pending();
    }

    // Code Injection: group=10, injector=asSimBornAge0
    // cell change in asSimBornAge0
    if (om_active) {
        if (om_asSimBornAge0_filter) {
            om_asSimBornAge0_erase();
            om_asSimBornAge0_update_cell();
            om_asSimBornAge0_insert();
        }
    }
}
void Person::om_side_effects_educ_mother(EDUC_ONE_LEVEL om_old, EDUC_ONE_LEVEL om_new)
{

    // Code Injection: group=8, injector=child_mortality_group
    // Maintain identity for 'child_mortality_group'
    child_mortality_group_update_identity();

    // Code Injection: group=8, injector=educ1_group
    // Maintain identity for 'educ1_group'
    educ1_group_update_identity();

    // Code Injection: group=10, injector=TabImmunizationChildren
    // Cell change in TabImmunizationChildren
    if (om_active && theTabImmunizationChildren) {
        // Check and start pending increment in entity table TabImmunizationChildren
        auto cell = om_TabImmunizationChildren_current_cell();
        auto & incr = om_TabImmunizationChildren_incr;
        incr.set_cell(cell);
        incr.start_pending();
    }

    // Code Injection: group=10, injector=TabPrenatCare
    // Cell change in TabPrenatCare
    if (om_active && theTabPrenatCare) {
        // Check and start pending increment in entity table TabPrenatCare
        auto cell = om_TabPrenatCare_current_cell();
        auto & incr = om_TabPrenatCare_incr;
        incr.set_cell(cell);
        incr.start_pending();
    }

    // Code Injection: group=10, injector=tabStuntingSexRegMotherYob
    // Cell change in tabStuntingSexRegMotherYob
    if (om_active && thetabStuntingSexRegMotherYob) {
        // Check and start pending increment in entity table tabStuntingSexRegMotherYob
        auto cell = om_tabStuntingSexRegMotherYob_current_cell();
        auto & incr = om_tabStuntingSexRegMotherYob_incr;
        incr.set_cell(cell);
        incr.start_pending();
    }
}
void Person::om_side_effects_educ_one_entry_age(EDUC_ONE_ENTRY_AGE om_old, EDUC_ONE_ENTRY_AGE om_new)
{
}
void Person::om_side_effects_educ_one_fate(EDUC_ONE_LEVEL om_old, EDUC_ONE_LEVEL om_new)
{

    // Code Injection: group=8, injector=is_aded0
    // Maintain identity for 'is_aded0'
    is_aded0_update_identity();

    // Code Injection: group=8, injector=is_aded1
    // Maintain identity for 'is_aded1'
    is_aded1_update_identity();

    // Code Injection: group=8, injector=is_aded2
    // Maintain identity for 'is_aded2'
    is_aded2_update_identity();

    // Code Injection: group=8, injector=om_aia_6
    // Maintain identity for 'om_aia_6'
    om_aia_6_update_identity();

    // Code Injection: group=8, injector=om_aia_7
    // Maintain identity for 'om_aia_7'
    om_aia_7_update_identity();

    // Code Injection: group=8, injector=om_aia_8
    // Maintain identity for 'om_aia_8'
    om_aia_8_update_identity();

    // Code Injection: group=8, injector=om_asPotentialSchoolOneStudent_filter
    // Maintain identity for 'om_asPotentialSchoolOneStudent_filter'
    om_asPotentialSchoolOneStudent_filter_update_identity();

    // Code Injection: group=8, injector=spouse_group
    // Maintain identity for 'Person::spouse_group' using reciprocal link
    if (!lSpouse.is_nullptr()) lSpouse->spouse_group_update_identity();

    // Code Injection: group=8, injector=union1_group
    // Maintain identity for 'union1_group'
    union1_group_update_identity();

    // Code Injection: group=10, injector=om_FertilityDetailedEvent_om_event
    // Recalculate time to event FertilityDetailedEvent
    if (om_active) om_FertilityDetailedEvent_om_event.make_dirty();

    // Code Injection: group=10, injector=TabEducFateByGroup
    // Cell change in TabEducFateByGroup
    if (om_active && theTabEducFateByGroup) {
        // Check and start pending increment in entity table TabEducFateByGroup
        auto cell = om_TabEducFateByGroup_current_cell();
        auto & incr = om_TabEducFateByGroup_incr;
        incr.set_cell(cell);
        incr.start_pending();
    }

    // Code Injection: group=10, injector=TabEducFateDistrYob
    // Cell change in TabEducFateDistrYob
    if (om_active && theTabEducFateDistrYob) {
        // Check and start pending increment in entity table TabEducFateDistrYob
        auto cell = om_TabEducFateDistrYob_current_cell();
        auto & incr = om_TabEducFateDistrYob_incr;
        incr.set_cell(cell);
        incr.start_pending();
    }
}
void Person::om_side_effects_educ_one_geo(EDUC_ONE_GEO om_old, EDUC_ONE_GEO om_new)
{
}
void Person::om_side_effects_educ_one_grade(EDUC_ONE_GRADE om_old, EDUC_ONE_GRADE om_new)
{

    // Code Injection: group=10, injector=TabPrimarySchoolPlanning
    // Cell change in TabPrimarySchoolPlanning
    if (om_active && theTabPrimarySchoolPlanning) {
        // Check and start pending increment in entity table TabPrimarySchoolPlanning
        auto cell = om_TabPrimarySchoolPlanning_current_cell();
        auto & incr = om_TabPrimarySchoolPlanning_incr;
        incr.set_cell(cell);
        incr.start_pending();
    }
}
void Person::om_side_effects_educ_one_grade_attended(EDUC_ONE_GRADE0 om_old, EDUC_ONE_GRADE0 om_new)
{

    // Code Injection: group=5, injector=entrances(educ_one_grade_attended, 1)
    {
        // Maintain entrances(educ_one_grade_attended, 1)
        if (om_new == 1) {
            om_entrances_FOR_educ_one_grade_attended_X_1.set(om_entrances_FOR_educ_one_grade_attended_X_1.get() + 1);
        }
    }

    // Code Injection: group=8, injector=educ_one_grade
    // Maintain identity for 'educ_one_grade'
    educ_one_grade_update_identity();

    // Code Injection: group=8, injector=educ_one_level
    // Maintain identity for 'educ_one_level'
    educ_one_level_update_identity();

    // Code Injection: group=8, injector=is_educ_one_student
    // Maintain identity for 'is_educ_one_student'
    is_educ_one_student_update_identity();

    // Code Injection: group=10, injector=om_SetPreschoolYearsEvent_om_event
    // Recalculate time to event SetPreschoolYearsEvent
    if (om_active) om_SetPreschoolYearsEvent_om_event.make_dirty();
}
void Person::om_side_effects_educ_one_grade_fate(EDUC_ONE_GRADE om_old, EDUC_ONE_GRADE om_new)
{
}
void Person::om_side_effects_educ_one_grade_passed(EDUC_ONE_GRADE0 om_old, EDUC_ONE_GRADE0 om_new)
{

    // Code Injection: group=8, injector=educ_one_level
    // Maintain identity for 'educ_one_level'
    educ_one_level_update_identity();

    // Code Injection: group=8, injector=has_passed_primary
    // Maintain identity for 'has_passed_primary'
    has_passed_primary_update_identity();

    // Code Injection: group=8, injector=om_asPotentialSchoolTwoStudent_filter
    // Maintain identity for 'om_asPotentialSchoolTwoStudent_filter'
    om_asPotentialSchoolTwoStudent_filter_update_identity();

    // Code Injection: group=8, injector=years_of_schooling
    // Maintain identity for 'years_of_schooling'
    years_of_schooling_update_identity();
}
void Person::om_side_effects_educ_one_group(EDUC_ONE_GROUP om_old, EDUC_ONE_GROUP om_new)
{
}
void Person::om_side_effects_educ_one_level(EDUC_ONE_LEVEL om_old, EDUC_ONE_LEVEL om_new)
{

    // Code Injection: group=8, injector=om_aia_10
    // Maintain identity for 'om_aia_10'
    om_aia_10_update_identity();

    // Code Injection: group=8, injector=om_aia_11
    // Maintain identity for 'om_aia_11'
    om_aia_11_update_identity();

    // Code Injection: group=8, injector=om_aia_12
    // Maintain identity for 'om_aia_12'
    om_aia_12_update_identity();
}
void Person::om_side_effects_educ_one_required_rooms(double om_old, double om_new)
{
}
void Person::om_side_effects_educ_one_required_teachers(double om_old, double om_new)
{
}
void Person::om_side_effects_educ_one_status(EDUC_ONE_STATUS om_old, EDUC_ONE_STATUS om_new)
{

    // Code Injection: group=8, injector=is_educ_one_student
    // Maintain identity for 'is_educ_one_student'
    is_educ_one_student_update_identity();

    // Code Injection: group=8, injector=om_asPotentialSchoolOneStudent_filter
    // Maintain identity for 'om_asPotentialSchoolOneStudent_filter'
    om_asPotentialSchoolOneStudent_filter_update_identity();

    // Code Injection: group=8, injector=tab_out_of_primary
    // Maintain identity for 'tab_out_of_primary'
    tab_out_of_primary_update_identity();
}
void Person::om_side_effects_educ_one_to_process(bool om_old, bool om_new)
{

    // Code Injection: group=8, injector=om_asPotentialSchoolOneStudentToProcess_filter
    // Maintain identity for 'om_asPotentialSchoolOneStudentToProcess_filter'
    om_asPotentialSchoolOneStudentToProcess_filter_update_identity();
}
void Person::om_side_effects_educ_two_delay(int om_old, int om_new)
{

    // Code Injection: group=8, injector=om_asPotentialSchoolTwoStudent_filter
    // Maintain identity for 'om_asPotentialSchoolTwoStudent_filter'
    om_asPotentialSchoolTwoStudent_filter_update_identity();
}
void Person::om_side_effects_educ_two_geo(EDUC_TWO_GEO om_old, EDUC_TWO_GEO om_new)
{
}
void Person::om_side_effects_educ_two_grade_attended(EDUC_TWO_GRADE0 om_old, EDUC_TWO_GRADE0 om_new)
{

    // Code Injection: group=10, injector=TabSchool2TrackTab
    // Cell change in TabSchool2TrackTab
    if (om_active && theTabSchool2TrackTab) {
        // Check and start pending increment in entity table TabSchool2TrackTab
        auto cell = om_TabSchool2TrackTab_current_cell();
        auto & incr = om_TabSchool2TrackTab_incr;
        incr.set_cell(cell);
        incr.start_pending();
    }
}
void Person::om_side_effects_educ_two_grade_passed(EDUC_TWO_GRADE0 om_old, EDUC_TWO_GRADE0 om_new)
{

    // Code Injection: group=8, injector=educ_two_level
    // Maintain identity for 'educ_two_level'
    educ_two_level_update_identity();

    // Code Injection: group=8, injector=years_of_schooling
    // Maintain identity for 'years_of_schooling'
    years_of_schooling_update_identity();
}
void Person::om_side_effects_educ_two_group(EDUC_TWO_GROUP om_old, EDUC_TWO_GROUP om_new)
{
}
void Person::om_side_effects_educ_two_level(EDUC_TWO_LEVEL om_old, EDUC_TWO_LEVEL om_new)
{

    // Code Injection: group=8, injector=om_aia_27
    // Maintain identity for 'om_aia_27'
    om_aia_27_update_identity();

    // Code Injection: group=8, injector=om_aia_28
    // Maintain identity for 'om_aia_28'
    om_aia_28_update_identity();

    // Code Injection: group=8, injector=om_aia_29
    // Maintain identity for 'om_aia_29'
    om_aia_29_update_identity();
}
void Person::om_side_effects_educ_two_status(EDUC_TWO_STATUS om_old, EDUC_TWO_STATUS om_new)
{

    // Code Injection: group=8, injector=educ_two_level
    // Maintain identity for 'educ_two_level'
    educ_two_level_update_identity();

    // Code Injection: group=8, injector=om_aia_25
    // Maintain identity for 'om_aia_25'
    om_aia_25_update_identity();

    // Code Injection: group=8, injector=om_asPotentialSchoolTwoStudent_filter
    // Maintain identity for 'om_asPotentialSchoolTwoStudent_filter'
    om_asPotentialSchoolTwoStudent_filter_update_identity();
}
void Person::om_side_effects_educ_two_to_process(bool om_old, bool om_new)
{

    // Code Injection: group=8, injector=om_asPotentialSchoolTwoStudentToProcess_filter
    // Maintain identity for 'om_asPotentialSchoolTwoStudentToProcess_filter'
    om_asPotentialSchoolTwoStudentToProcess_filter_update_identity();
}
void Person::om_side_effects_entity_id(int om_old, int om_new)
{
}
void Person::om_side_effects_ethnicity(ETHNICITY om_old, ETHNICITY om_new)
{

    // Code Injection: group=5, injector=aggregate(ethnicity, ETHNICITY_SHORT)
    {
        // Maintain aggregate(ethnicity, ETHNICITY_SHORT)
        om_aggregate_FOR_ethnicity_X_ETHNICITY_SHORT.set(om_aggregation_ETHNICITY_om_ETHNICITY_SHORT.find(ethnicity)->second);
    }
}
void Person::om_side_effects_ethnicity_short(ETHNICITY_SHORT om_old, ETHNICITY_SHORT om_new)
{

    // Code Injection: group=10, injector=TabImmunizationChildren
    // Cell change in TabImmunizationChildren
    if (om_active && theTabImmunizationChildren) {
        // Check and start pending increment in entity table TabImmunizationChildren
        auto cell = om_TabImmunizationChildren_current_cell();
        auto & incr = om_TabImmunizationChildren_incr;
        incr.set_cell(cell);
        incr.start_pending();
    }
}
void Person::om_side_effects_events(counter om_old, counter om_new)
{
}
void Person::om_side_effects_ever_resident(bool om_old, bool om_new)
{

    // Code Injection: group=8, injector=is_fertile
    // Maintain identity for 'is_fertile'
    is_fertile_update_identity();

    // Code Injection: group=8, injector=is_mortal
    // Maintain identity for 'is_mortal'
    is_mortal_update_identity();

    // Code Injection: group=8, injector=om_asPotentialImmigrantMothers_filter
    // Maintain identity for 'om_asPotentialImmigrantMothers_filter'
    om_asPotentialImmigrantMothers_filter_update_identity();

    // Code Injection: group=10, injector=om_BackMigrationEvent_om_event
    // Recalculate time to event BackMigrationEvent
    if (om_active) om_BackMigrationEvent_om_event.make_dirty();

    // Code Injection: group=10, injector=om_FirstImmigrationFromPoolEvent_om_event
    // Recalculate time to event FirstImmigrationFromPoolEvent
    if (om_active) om_FirstImmigrationFromPoolEvent_om_event.make_dirty();

    // Code Injection: group=10, injector=om_FirstImmigrationFromScratchEvent_om_event
    // Recalculate time to event FirstImmigrationFromScratchEvent
    if (om_active) om_FirstImmigrationFromScratchEvent_om_event.make_dirty();
}
void Person::om_side_effects_ever_union(bool om_old, bool om_new)
{

    // Code Injection: group=8, injector=om_aia_32
    // Maintain identity for 'om_aia_32'
    om_aia_32_update_identity();

    // Code Injection: group=8, injector=om_asPotentialImmigrantMothers_filter
    // Maintain identity for 'om_asPotentialImmigrantMothers_filter'
    om_asPotentialImmigrantMothers_filter_update_identity();

    // Code Injection: group=10, injector=om_FertilityDetailedEvent_om_event
    // Recalculate time to event FertilityDetailedEvent
    if (om_active) om_FertilityDetailedEvent_om_event.make_dirty();

    // Code Injection: group=10, injector=om_FirstUnionFormationEvent_om_event
    // Recalculate time to event FirstUnionFormationEvent
    if (om_active) om_FirstUnionFormationEvent_om_event.make_dirty();
}
void Person::om_side_effects_family_role(FAM_ROLE om_old, FAM_ROLE om_new)
{

    // Code Injection: group=8, injector=om_asPotentialImmigrantMothers_filter
    // Maintain identity for 'om_asPotentialImmigrantMothers_filter'
    om_asPotentialImmigrantMothers_filter_update_identity();

    // Code Injection: group=10, injector=om_FirstImmigrationFromScratchEvent_om_event
    // Recalculate time to event FirstImmigrationFromScratchEvent
    if (om_active) om_FirstImmigrationFromScratchEvent_om_event.make_dirty();

    // Code Injection: group=10, injector=om_LeavingHomeEvent_om_event
    // Recalculate time to event LeavingHomeEvent
    if (om_active) om_LeavingHomeEvent_om_event.make_dirty();
}
void Person::om_side_effects_female_spouse_age(FEMALE_SPOUSE_AGE om_old, FEMALE_SPOUSE_AGE om_new)
{

    // Code Injection: group=10, injector=asFemaleInUnionByAgeAndPartnerAge
    // cell change in asFemaleInUnionByAgeAndPartnerAge
    if (om_active) {
        if (om_asFemaleInUnionByAgeAndPartnerAge_filter) {
            om_asFemaleInUnionByAgeAndPartnerAge_erase();
            om_asFemaleInUnionByAgeAndPartnerAge_update_cell();
            om_asFemaleInUnionByAgeAndPartnerAge_insert();
        }
    }

    // Code Injection: group=10, injector=asFemaleInUnionByAgeAndPartnerAgeImmiScratch
    // cell change in asFemaleInUnionByAgeAndPartnerAgeImmiScratch
    if (om_active) {
        if (om_asFemaleInUnionByAgeAndPartnerAgeImmiScratch_filter) {
            om_asFemaleInUnionByAgeAndPartnerAgeImmiScratch_erase();
            om_asFemaleInUnionByAgeAndPartnerAgeImmiScratch_update_cell();
            om_asFemaleInUnionByAgeAndPartnerAgeImmiScratch_insert();
        }
    }

    // Code Injection: group=10, injector=asWomenNoChildren
    // cell change in asWomenNoChildren
    if (om_active) {
        if (om_asWomenNoChildren_filter) {
            om_asWomenNoChildren_erase();
            om_asWomenNoChildren_update_cell();
            om_asWomenNoChildren_insert();
        }
    }
}
void Person::om_side_effects_fertile_age(FERTILE_AGE_RANGE om_old, FERTILE_AGE_RANGE om_new)
{

    // Code Injection: group=10, injector=asAllFertilePersonsForFertilityAlignmentByAge
    // cell change in asAllFertilePersonsForFertilityAlignmentByAge
    if (om_active) {
        if (om_asAllFertilePersonsForFertilityAlignmentByAge_filter) {
            om_asAllFertilePersonsForFertilityAlignmentByAge_erase();
            om_asAllFertilePersonsForFertilityAlignmentByAge_update_cell();
            om_asAllFertilePersonsForFertilityAlignmentByAge_insert();
        }
    }
}
void Person::om_side_effects_first_move_done(bool om_old, bool om_new)
{
}
void Person::om_side_effects_geo(GEO om_old, GEO om_new)
{

    // Code Injection: group=1, injector=trigger_changes(geo)
    if (om_active) {
        auto & ss_attr = om_trigger_changes_FOR_geo; // the self-scheduling attribute being maintained
        auto & ss_time = om_ss_time_om_trigger_changes_FOR_geo; // the scheduled time of maintenance of this self-scheduling attribute
        auto & ss_event = zzz_om_om_ss_event_om_event; // the single event in the entity which maintains all self-scheduling attributes

        // Activate trigger trigger_changes(geo)
        ss_attr.set(true);
        // Set the self-scheduling event to reset the trigger immediately
        ss_time = time;
        // Mark the entity's self-scheduling event for recalculation
        ss_event.make_dirty();
    }

    // Code Injection: group=5, injector=aggregate(geo, GEO_NAT)
    {
        // Maintain aggregate(geo, GEO_NAT)
        om_aggregate_FOR_geo_X_GEO_NAT.set(om_aggregation_GEO_om_GEO_NAT.find(geo)->second);
    }

    // Code Injection: group=5, injector=aggregate(geo, REGION_INT)
    {
        // Maintain aggregate(geo, REGION_INT)
        om_aggregate_FOR_geo_X_REGION_INT.set(om_aggregation_GEO_om_REGION_INT.find(geo)->second);
    }

    // Code Injection: group=8, injector=is_resident
    // Maintain identity for 'is_resident'
    is_resident_update_identity();

    // Code Injection: group=10, injector=om_EmigrationEvent_om_event
    // Recalculate time to event EmigrationEvent
    if (om_active) om_EmigrationEvent_om_event.make_dirty();

    // Code Injection: group=10, injector=om_FertilityDetailedEvent_om_event
    // Recalculate time to event FertilityDetailedEvent
    if (om_active) om_FertilityDetailedEvent_om_event.make_dirty();

    // Code Injection: group=10, injector=om_MigrationEvent_om_event
    // Recalculate time to event MigrationEvent
    if (om_active) om_MigrationEvent_om_event.make_dirty();

    // Code Injection: group=10, injector=asAvailableMale
    // cell change in asAvailableMale
    if (om_active) {
        if (om_asAvailableMale_filter) {
            om_asAvailableMale_erase();
            om_asAvailableMale_update_cell();
            om_asAvailableMale_insert();
        }
    }

    // Code Injection: group=10, injector=asAvailableMaleByType
    // cell change in asAvailableMaleByType
    if (om_active) {
        if (om_asAvailableMaleByType_filter) {
            om_asAvailableMaleByType_erase();
            om_asAvailableMaleByType_update_cell();
            om_asAvailableMaleByType_insert();
        }
    }

    // Code Injection: group=10, injector=asAvailableMaleByTypeImmiScratch
    // cell change in asAvailableMaleByTypeImmiScratch
    if (om_active) {
        if (om_asAvailableMaleByTypeImmiScratch_filter) {
            om_asAvailableMaleByTypeImmiScratch_erase();
            om_asAvailableMaleByTypeImmiScratch_update_cell();
            om_asAvailableMaleByTypeImmiScratch_insert();
        }
    }

    // Code Injection: group=10, injector=asAvailableMaleImmiScratch
    // cell change in asAvailableMaleImmiScratch
    if (om_active) {
        if (om_asAvailableMaleImmiScratch_filter) {
            om_asAvailableMaleImmiScratch_erase();
            om_asAvailableMaleImmiScratch_update_cell();
            om_asAvailableMaleImmiScratch_insert();
        }
    }

    // Code Injection: group=10, injector=asPotentialImmigrantMothers
    // cell change in asPotentialImmigrantMothers
    if (om_active) {
        if (om_asPotentialImmigrantMothers_filter) {
            om_asPotentialImmigrantMothers_erase();
            om_asPotentialImmigrantMothers_update_cell();
            om_asPotentialImmigrantMothers_insert();
        }
    }

    // Code Injection: group=10, injector=asSimBornAge0
    // cell change in asSimBornAge0
    if (om_active) {
        if (om_asSimBornAge0_filter) {
            om_asSimBornAge0_erase();
            om_asSimBornAge0_update_cell();
            om_asSimBornAge0_insert();
        }
    }

    // Code Injection: group=10, injector=asWantToMove
    // cell change in asWantToMove
    if (om_active) {
        if (om_asWantToMove_filter) {
            om_asWantToMove_erase();
            om_asWantToMove_update_cell();
            om_asWantToMove_insert();
        }
    }

    // Code Injection: group=10, injector=tabBirthsYearPlace
    // Cell change in tabBirthsYearPlace
    if (om_active && thetabBirthsYearPlace) {
        // Check and start pending increment in entity table tabBirthsYearPlace
        auto cell = om_tabBirthsYearPlace_current_cell();
        auto & incr = om_tabBirthsYearPlace_incr;
        incr.set_cell(cell);
        incr.start_pending();
    }

    // Code Injection: group=10, injector=tabMigrationOriginDestination
    // Cell change in tabMigrationOriginDestination
    if (om_active && thetabMigrationOriginDestination) {
        // Check and start pending increment in entity table tabMigrationOriginDestination
        auto cell = om_tabMigrationOriginDestination_current_cell();
        auto & incr = om_tabMigrationOriginDestination_incr;
        incr.set_cell(cell);
        incr.start_pending();
    }

    // Code Injection: group=10, injector=tabPopulationYearPlace
    // Cell change in tabPopulationYearPlace
    if (om_active && thetabPopulationYearPlace) {
        // Check and start pending increment in entity table tabPopulationYearPlace
        auto cell = om_tabPopulationYearPlace_current_cell();
        auto & incr = om_tabPopulationYearPlace_incr;
        incr.set_cell(cell);
        incr.start_pending();
    }

    // Code Injection: group=10, injector=tabPreSchool
    // Cell change in tabPreSchool
    if (om_active && thetabPreSchool) {
        // Check and start pending increment in entity table tabPreSchool
        auto cell = om_tabPreSchool_current_cell();
        auto & incr = om_tabPreSchool_incr;
        incr.set_cell(cell);
        incr.start_pending();
    }
}
void Person::om_side_effects_geo_birth(GEO om_old, GEO om_new)
{

    // Code Injection: group=5, injector=aggregate(geo_birth, GEO_NAT)
    {
        // Maintain aggregate(geo_birth, GEO_NAT)
        om_aggregate_FOR_geo_birth_X_GEO_NAT.set(om_aggregation_GEO_om_GEO_NAT.find(geo_birth)->second);
    }

    // Code Injection: group=5, injector=aggregate(geo_birth, REGION_INT)
    {
        // Maintain aggregate(geo_birth, REGION_INT)
        om_aggregate_FOR_geo_birth_X_REGION_INT.set(om_aggregation_GEO_om_REGION_INT.find(geo_birth)->second);
    }

    // Code Injection: group=8, injector=in_hci_sample
    // Maintain identity for 'in_hci_sample'
    in_hci_sample_update_identity();

    // Code Injection: group=10, injector=TabEduc15ByDistrictBirth
    // Cell change in TabEduc15ByDistrictBirth
    if (om_active && theTabEduc15ByDistrictBirth) {
        // Check and start pending increment in entity table TabEduc15ByDistrictBirth
        auto cell = om_TabEduc15ByDistrictBirth_current_cell();
        auto & incr = om_TabEduc15ByDistrictBirth_incr;
        incr.set_cell(cell);
        incr.start_pending();
    }

    // Code Injection: group=10, injector=asResidentsAge0SexGeo
    // cell change in asResidentsAge0SexGeo
    if (om_active) {
        if (om_asResidentsAge0SexGeo_filter) {
            om_asResidentsAge0SexGeo_erase();
            om_asResidentsAge0SexGeo_update_cell();
            om_asResidentsAge0SexGeo_insert();
        }
    }

    // Code Injection: group=10, injector=tabEducationFateGeobirYob
    // Cell change in tabEducationFateGeobirYob
    if (om_active && thetabEducationFateGeobirYob) {
        // Check and start pending increment in entity table tabEducationFateGeobirYob
        auto cell = om_tabEducationFateGeobirYob_current_cell();
        auto & incr = om_tabEducationFateGeobirYob_incr;
        incr.set_cell(cell);
        incr.start_pending();
    }
}
void Person::om_side_effects_geo_nat(GEO_NAT om_old, GEO_NAT om_new)
{

    // Code Injection: group=8, injector=educ_one_required_rooms
    // Maintain identity for 'educ_one_required_rooms'
    educ_one_required_rooms_update_identity();

    // Code Injection: group=8, injector=educ_one_required_teachers
    // Maintain identity for 'educ_one_required_teachers'
    educ_one_required_teachers_update_identity();

    // Code Injection: group=10, injector=PopPyramidByEduc
    // Cell change in PopPyramidByEduc
    if (om_active && thePopPyramidByEduc) {
        // Check and start pending increment in entity table PopPyramidByEduc
        auto cell = om_PopPyramidByEduc_current_cell();
        auto & incr = om_PopPyramidByEduc_incr;
        incr.set_cell(cell);
        incr.start_pending();
    }

    // Code Injection: group=10, injector=TabEduc15ByDistrict
    // Cell change in TabEduc15ByDistrict
    if (om_active && theTabEduc15ByDistrict) {
        // Check and start pending increment in entity table TabEduc15ByDistrict
        auto cell = om_TabEduc15ByDistrict_current_cell();
        auto & incr = om_TabEduc15ByDistrict_incr;
        incr.set_cell(cell);
        incr.start_pending();
    }

    // Code Injection: group=10, injector=TabPopProvAgeEducSex
    // Cell change in TabPopProvAgeEducSex
    if (om_active && theTabPopProvAgeEducSex) {
        // Check and start pending increment in entity table TabPopProvAgeEducSex
        auto cell = om_TabPopProvAgeEducSex_current_cell();
        auto & incr = om_TabPopProvAgeEducSex_incr;
        incr.set_cell(cell);
        incr.start_pending();
    }

    // Code Injection: group=10, injector=TabPrimSchoolEntries
    // Cell change in TabPrimSchoolEntries
    if (om_active && theTabPrimSchoolEntries) {
        // Check and start pending increment in entity table TabPrimSchoolEntries
        auto cell = om_TabPrimSchoolEntries_current_cell();
        auto & incr = om_TabPrimSchoolEntries_incr;
        incr.set_cell(cell);
        incr.start_pending();
    }

    // Code Injection: group=10, injector=TabPrimSchoolGraduations
    // Cell change in TabPrimSchoolGraduations
    if (om_active && theTabPrimSchoolGraduations) {
        // Check and start pending increment in entity table TabPrimSchoolGraduations
        auto cell = om_TabPrimSchoolGraduations_current_cell();
        auto & incr = om_TabPrimSchoolGraduations_incr;
        incr.set_cell(cell);
        incr.start_pending();
    }

    // Code Injection: group=10, injector=TabPrimSchoolOutOfSchool9to11
    // Cell change in TabPrimSchoolOutOfSchool9to11
    if (om_active && theTabPrimSchoolOutOfSchool9to11) {
        // Check and start pending increment in entity table TabPrimSchoolOutOfSchool9to11
        auto cell = om_TabPrimSchoolOutOfSchool9to11_current_cell();
        auto & incr = om_TabPrimSchoolOutOfSchool9to11_incr;
        incr.set_cell(cell);
        incr.start_pending();
    }

    // Code Injection: group=10, injector=TabPrimarySchoolPlanning
    // Cell change in TabPrimarySchoolPlanning
    if (om_active && theTabPrimarySchoolPlanning) {
        // Check and start pending increment in entity table TabPrimarySchoolPlanning
        auto cell = om_TabPrimarySchoolPlanning_current_cell();
        auto & incr = om_TabPrimarySchoolPlanning_incr;
        incr.set_cell(cell);
        incr.start_pending();
    }
}
void Person::om_side_effects_geo_prev(GEO om_old, GEO om_new)
{

    // Code Injection: group=10, injector=tabMigrationOriginDestination
    // Cell change in tabMigrationOriginDestination
    if (om_active && thetabMigrationOriginDestination) {
        // Check and start pending increment in entity table tabMigrationOriginDestination
        auto cell = om_tabMigrationOriginDestination_current_cell();
        auto & incr = om_tabMigrationOriginDestination_incr;
        incr.set_cell(cell);
        incr.start_pending();
    }
}
void Person::om_side_effects_geo_want_to_move(GEO om_old, GEO om_new)
{

    // Code Injection: group=10, injector=asWantToMove
    // cell change in asWantToMove
    if (om_active) {
        if (om_asWantToMove_filter) {
            om_asWantToMove_erase();
            om_asWantToMove_update_cell();
            om_asWantToMove_insert();
        }
    }
}
void Person::om_side_effects_got_prenat_care(GOT_PRENAT_CARE om_old, GOT_PRENAT_CARE om_new)
{

    // Code Injection: group=8, injector=om_aia_38
    // Maintain identity for 'om_aia_38'
    om_aia_38_update_identity();

    // Code Injection: group=10, injector=TabImmunizationChildren
    // Cell change in TabImmunizationChildren
    if (om_active && theTabImmunizationChildren) {
        // Check and start pending increment in entity table TabImmunizationChildren
        auto cell = om_TabImmunizationChildren_current_cell();
        auto & incr = om_TabImmunizationChildren_incr;
        incr.set_cell(cell);
        incr.start_pending();
    }
}
void Person::om_side_effects_has_passed_primary(bool om_old, bool om_new)
{

    // Code Injection: group=5, injector=entrances(has_passed_primary, true)
    {
        // Maintain entrances(has_passed_primary, true)
        if (om_new == true) {
            om_entrances_FOR_has_passed_primary_X_true.set(om_entrances_FOR_has_passed_primary_X_true.get() + 1);
        }
    }

    // Code Injection: group=8, injector=tab_out_of_primary
    // Maintain identity for 'tab_out_of_primary'
    tab_out_of_primary_update_identity();
}
void Person::om_side_effects_has_spouse(bool om_old, bool om_new)
{

    // Code Injection: group=8, injector=male_spouse_age
    // Maintain identity for 'male_spouse_age'
    male_spouse_age_update_identity();

    // Code Injection: group=8, injector=om_aia_31
    // Maintain identity for 'om_aia_31'
    om_aia_31_update_identity();

    // Code Injection: group=8, injector=om_asAvailableMaleByTypeImmiScratch_filter
    // Maintain identity for 'om_asAvailableMaleByTypeImmiScratch_filter'
    om_asAvailableMaleByTypeImmiScratch_filter_update_identity();

    // Code Injection: group=8, injector=om_asAvailableMaleByType_filter
    // Maintain identity for 'om_asAvailableMaleByType_filter'
    om_asAvailableMaleByType_filter_update_identity();

    // Code Injection: group=8, injector=om_asAvailableMaleImmiScratch_filter
    // Maintain identity for 'om_asAvailableMaleImmiScratch_filter'
    om_asAvailableMaleImmiScratch_filter_update_identity();

    // Code Injection: group=8, injector=om_asAvailableMale_filter
    // Maintain identity for 'om_asAvailableMale_filter'
    om_asAvailableMale_filter_update_identity();

    // Code Injection: group=8, injector=om_asFemaleInUnionByAgeAndPartnerAgeImmiScratch_filter
    // Maintain identity for 'om_asFemaleInUnionByAgeAndPartnerAgeImmiScratch_filter'
    om_asFemaleInUnionByAgeAndPartnerAgeImmiScratch_filter_update_identity();

    // Code Injection: group=8, injector=om_asFemaleInUnionByAgeAndPartnerAge_filter
    // Maintain identity for 'om_asFemaleInUnionByAgeAndPartnerAge_filter'
    om_asFemaleInUnionByAgeAndPartnerAge_filter_update_identity();

    // Code Injection: group=8, injector=spouse_group
    // Maintain identity for 'spouse_group'
    spouse_group_update_identity();

    // Code Injection: group=10, injector=asWomenNoChildren
    // cell change in asWomenNoChildren
    if (om_active) {
        if (om_asWomenNoChildren_filter) {
            om_asWomenNoChildren_erase();
            om_asWomenNoChildren_update_cell();
            om_asWomenNoChildren_insert();
        }
    }

    // Code Injection: group=10, injector=asWomenWithChildren
    // cell change in asWomenWithChildren
    if (om_active) {
        if (om_asWomenWithChildren_filter) {
            om_asWomenWithChildren_erase();
            om_asWomenWithChildren_update_cell();
            om_asWomenWithChildren_insert();
        }
    }
}
void Person::om_side_effects_in_hci_sample(bool om_old, bool om_new)
{

    // Code Injection: group=8, injector=om_aia_33
    // Maintain identity for 'om_aia_33'
    om_aia_33_update_identity();
}
void Person::om_side_effects_in_projected_time(bool om_old, bool om_new)
{

    // Code Injection: group=8, injector=om_aia_13
    // Maintain identity for 'om_aia_13'
    om_aia_13_update_identity();

    // Code Injection: group=8, injector=om_aia_14
    // Maintain identity for 'om_aia_14'
    om_aia_14_update_identity();

    // Code Injection: group=8, injector=om_aia_15
    // Maintain identity for 'om_aia_15'
    om_aia_15_update_identity();

    // Code Injection: group=8, injector=om_aia_22
    // Maintain identity for 'om_aia_22'
    om_aia_22_update_identity();

    // Code Injection: group=8, injector=om_aia_23
    // Maintain identity for 'om_aia_23'
    om_aia_23_update_identity();

    // Code Injection: group=8, injector=om_aia_25
    // Maintain identity for 'om_aia_25'
    om_aia_25_update_identity();

    // Code Injection: group=8, injector=om_aia_26
    // Maintain identity for 'om_aia_26'
    om_aia_26_update_identity();

    // Code Injection: group=8, injector=om_aia_33
    // Maintain identity for 'om_aia_33'
    om_aia_33_update_identity();

    // Code Injection: group=8, injector=om_aia_36
    // Maintain identity for 'om_aia_36'
    om_aia_36_update_identity();

    // Code Injection: group=8, injector=om_aia_37
    // Maintain identity for 'om_aia_37'
    om_aia_37_update_identity();

    // Code Injection: group=8, injector=om_aia_40
    // Maintain identity for 'om_aia_40'
    om_aia_40_update_identity();
}
void Person::om_side_effects_in_sel_years(bool om_old, bool om_new)
{

    // Code Injection: group=8, injector=om_aia_9
    // Maintain identity for 'om_aia_9'
    om_aia_9_update_identity();
}
void Person::om_side_effects_in_selected_year(bool om_old, bool om_new)
{

    // Code Injection: group=8, injector=om_aia_35
    // Maintain identity for 'om_aia_35'
    om_aia_35_update_identity();
}
void Person::om_side_effects_ind_hci(double om_old, double om_new)
{
}
void Person::om_side_effects_integer_age(AGE_RANGE om_old, AGE_RANGE om_new)
{

    // Code Injection: group=5, injector=split(integer_age, TAB_AGEC5)
    {
        // Maintain split(integer_age, TAB_AGEC5)
        om_split_FOR_integer_age_X_TAB_AGEC5.set(TAB_AGEC5::value_to_interval((real)integer_age));
    }

    // Code Injection: group=5, injector=transitions(integer_age, 14, 15)
    {
        // Maintain transitions(integer_age, 14, 15)
        if (om_old == 14 && om_new == 15) {
            om_transitions_FOR_integer_age_X_14_X_15.set(om_transitions_FOR_integer_age_X_14_X_15.get() + 1);
        }
    }

    // Code Injection: group=8, injector=age_last_birth
    // Maintain identity for 'age_last_birth'
    age_last_birth_update_identity();

    // Code Injection: group=8, injector=child_mortality
    // Maintain identity for 'child_mortality'
    child_mortality_update_identity();

    // Code Injection: group=8, injector=female_spouse_age
    // Maintain identity for 'female_spouse_age'
    female_spouse_age_update_identity();

    // Code Injection: group=8, injector=fertile_age
    // Maintain identity for 'fertile_age'
    fertile_age_update_identity();

    // Code Injection: group=8, injector=is_adult
    // Maintain identity for 'is_adult'
    is_adult_update_identity();

    // Code Injection: group=8, injector=is_child
    // Maintain identity for 'is_child'
    is_child_update_identity();

    // Code Injection: group=8, injector=is_fertile
    // Maintain identity for 'is_fertile'
    is_fertile_update_identity();

    // Code Injection: group=8, injector=is_old
    // Maintain identity for 'is_old'
    is_old_update_identity();

    // Code Injection: group=8, injector=male_age
    // Maintain identity for 'male_age'
    male_age_update_identity();

    // Code Injection: group=8, injector=male_spouse_age
    // Maintain identity for 'Person::male_spouse_age' using reciprocal link
    if (!lSpouse.is_nullptr()) lSpouse->male_spouse_age_update_identity();

    // Code Injection: group=8, injector=om_aia_1
    // Maintain identity for 'om_aia_1'
    om_aia_1_update_identity();

    // Code Injection: group=8, injector=om_aia_13
    // Maintain identity for 'om_aia_13'
    om_aia_13_update_identity();

    // Code Injection: group=8, injector=om_aia_21
    // Maintain identity for 'om_aia_21'
    om_aia_21_update_identity();

    // Code Injection: group=8, injector=om_aia_22
    // Maintain identity for 'om_aia_22'
    om_aia_22_update_identity();

    // Code Injection: group=8, injector=om_aia_23
    // Maintain identity for 'om_aia_23'
    om_aia_23_update_identity();

    // Code Injection: group=8, injector=om_aia_26
    // Maintain identity for 'om_aia_26'
    om_aia_26_update_identity();

    // Code Injection: group=8, injector=om_aia_37
    // Maintain identity for 'om_aia_37'
    om_aia_37_update_identity();

    // Code Injection: group=8, injector=om_aia_40
    // Maintain identity for 'om_aia_40'
    om_aia_40_update_identity();

    // Code Injection: group=8, injector=om_aia_5
    // Maintain identity for 'om_aia_5'
    om_aia_5_update_identity();

    // Code Injection: group=8, injector=om_asAvailableMaleByTypeImmiScratch_filter
    // Maintain identity for 'om_asAvailableMaleByTypeImmiScratch_filter'
    om_asAvailableMaleByTypeImmiScratch_filter_update_identity();

    // Code Injection: group=8, injector=om_asAvailableMaleByType_filter
    // Maintain identity for 'om_asAvailableMaleByType_filter'
    om_asAvailableMaleByType_filter_update_identity();

    // Code Injection: group=8, injector=om_asAvailableMaleImmiScratch_filter
    // Maintain identity for 'om_asAvailableMaleImmiScratch_filter'
    om_asAvailableMaleImmiScratch_filter_update_identity();

    // Code Injection: group=8, injector=om_asAvailableMale_filter
    // Maintain identity for 'om_asAvailableMale_filter'
    om_asAvailableMale_filter_update_identity();

    // Code Injection: group=8, injector=om_asFemaleInUnionByAgeAndPartnerAgeImmiScratch_filter
    // Maintain identity for 'om_asFemaleInUnionByAgeAndPartnerAgeImmiScratch_filter'
    om_asFemaleInUnionByAgeAndPartnerAgeImmiScratch_filter_update_identity();

    // Code Injection: group=8, injector=om_asFemaleInUnionByAgeAndPartnerAge_filter
    // Maintain identity for 'om_asFemaleInUnionByAgeAndPartnerAge_filter'
    om_asFemaleInUnionByAgeAndPartnerAge_filter_update_identity();

    // Code Injection: group=8, injector=om_asResidentBabies_filter
    // Maintain identity for 'om_asResidentBabies_filter'
    om_asResidentBabies_filter_update_identity();

    // Code Injection: group=8, injector=om_asResidentsAge0SexGeo_filter
    // Maintain identity for 'om_asResidentsAge0SexGeo_filter'
    om_asResidentsAge0SexGeo_filter_update_identity();

    // Code Injection: group=8, injector=om_asResidentsAge0Sex_filter
    // Maintain identity for 'om_asResidentsAge0Sex_filter'
    om_asResidentsAge0Sex_filter_update_identity();

    // Code Injection: group=8, injector=om_asSimBornAge0_filter
    // Maintain identity for 'om_asSimBornAge0_filter'
    om_asSimBornAge0_filter_update_identity();

    // Code Injection: group=8, injector=om_asWomenNoChildren_filter
    // Maintain identity for 'om_asWomenNoChildren_filter'
    om_asWomenNoChildren_filter_update_identity();

    // Code Injection: group=8, injector=om_asWomenWithChildren_filter
    // Maintain identity for 'om_asWomenWithChildren_filter'
    om_asWomenWithChildren_filter_update_identity();

    // Code Injection: group=8, injector=survived_early_years
    // Maintain identity for 'survived_early_years'
    survived_early_years_update_identity();

    // Code Injection: group=10, injector=om_BirthdayEvent_om_event
    // Recalculate time to event BirthdayEvent
    if (om_active) om_BirthdayEvent_om_event.make_dirty();

    // Code Injection: group=10, injector=om_FertilityBaseEvent_om_event
    // Recalculate time to event FertilityBaseEvent
    if (om_active) om_FertilityBaseEvent_om_event.make_dirty();

    // Code Injection: group=10, injector=om_FertilityDetailedEvent_om_event
    // Recalculate time to event FertilityDetailedEvent
    if (om_active) om_FertilityDetailedEvent_om_event.make_dirty();

    // Code Injection: group=10, injector=om_FirstUnionFormationEvent_om_event
    // Recalculate time to event FirstUnionFormationEvent
    if (om_active) om_FirstUnionFormationEvent_om_event.make_dirty();

    // Code Injection: group=10, injector=om_MortalityBaseEvent_om_event
    // Recalculate time to event MortalityBaseEvent
    if (om_active) om_MortalityBaseEvent_om_event.make_dirty();

    // Code Injection: group=10, injector=om_MortalityDetailedEvent_om_event
    // Recalculate time to event MortalityDetailedEvent
    if (om_active) om_MortalityDetailedEvent_om_event.make_dirty();

    // Code Injection: group=10, injector=om_mlHHMotherChildren_min_over_integer_age
    // Incremental update of multilink agentvar om_mlHHMotherChildren_min_over_integer_age
    {
        auto lnk = lHHMother.get();
        if (lnk.get() != nullptr) {
            AGE_RANGE current = lnk->om_mlHHMotherChildren_min_over_integer_age;
            if (om_new < current) lnk->om_mlHHMotherChildren_min_over_integer_age.set(om_new);
            else if (om_old == current && om_new > current) lnk->om_mlHHMotherChildren_min_over_integer_age_evaluate();
        }
    }


    // Code Injection: group=10, injector=asPotentialImmigrantMothers
    // cell change in asPotentialImmigrantMothers
    if (om_active) {
        if (om_asPotentialImmigrantMothers_filter) {
            om_asPotentialImmigrantMothers_erase();
            om_asPotentialImmigrantMothers_update_cell();
            om_asPotentialImmigrantMothers_insert();
        }
    }

    // Code Injection: group=10, injector=tabHavingSpouse
    // Cell change in tabHavingSpouse
    if (om_active && thetabHavingSpouse) {
        // Check and start pending increment in entity table tabHavingSpouse
        auto cell = om_tabHavingSpouse_current_cell();
        auto & incr = om_tabHavingSpouse_incr;
        incr.set_cell(cell);
        incr.start_pending();
    }
}
void Person::om_side_effects_is_aded0(bool om_old, bool om_new)
{

    // Code Injection: group=8, injector=om_aia_17
    // Maintain identity for 'om_aia_17'
    om_aia_17_update_identity();
}
void Person::om_side_effects_is_aded1(bool om_old, bool om_new)
{

    // Code Injection: group=8, injector=om_aia_18
    // Maintain identity for 'om_aia_18'
    om_aia_18_update_identity();
}
void Person::om_side_effects_is_aded2(bool om_old, bool om_new)
{

    // Code Injection: group=8, injector=om_aia_19
    // Maintain identity for 'om_aia_19'
    om_aia_19_update_identity();
}
void Person::om_side_effects_is_adult(bool om_old, bool om_new)
{
}
void Person::om_side_effects_is_alive(bool om_old, bool om_new)
{

    // Code Injection: group=5, injector=transitions(is_alive, false, true)
    {
        // Maintain transitions(is_alive, false, true)
        if (om_old == false && om_new == true) {
            om_transitions_FOR_is_alive_X_false_X_true.set(om_transitions_FOR_is_alive_X_false_X_true.get() + 1);
        }
    }

    // Code Injection: group=5, injector=transitions(is_alive, true, false)
    {
        // Maintain transitions(is_alive, true, false)
        if (om_old == true && om_new == false) {
            om_transitions_FOR_is_alive_X_true_X_false.set(om_transitions_FOR_is_alive_X_true_X_false.get() + 1);
        }
    }

    // Code Injection: group=5, injector=value_at_transitions(is_alive, true, false, adult_survival)
    {
        // Maintain value_at_transitions(is_alive, true, false, adult_survival)
        if (om_old == true && om_new == false) {
            om_value_at_transitions_FOR_is_alive_X_true_X_adult_survival_X_false.set(om_value_at_transitions_FOR_is_alive_X_true_X_adult_survival_X_false.get() + adult_survival.get());
        }
    }

    // Code Injection: group=5, injector=value_at_transitions(is_alive, true, false, ind_hci)
    {
        // Maintain value_at_transitions(is_alive, true, false, ind_hci)
        if (om_old == true && om_new == false) {
            om_value_at_transitions_FOR_is_alive_X_true_X_ind_hci_X_false.set(om_value_at_transitions_FOR_is_alive_X_true_X_ind_hci_X_false.get() + ind_hci.get());
        }
    }

    // Code Injection: group=5, injector=value_at_transitions(is_alive, true, false, is_stunted)
    {
        // Maintain value_at_transitions(is_alive, true, false, is_stunted)
        if (om_old == true && om_new == false) {
            om_value_at_transitions_FOR_is_alive_X_true_X_is_stunted_X_false.set(om_value_at_transitions_FOR_is_alive_X_true_X_is_stunted_X_false.get() + is_stunted.get());
        }
    }

    // Code Injection: group=5, injector=value_at_transitions(is_alive, true, false, quality_of_schooling)
    {
        // Maintain value_at_transitions(is_alive, true, false, quality_of_schooling)
        if (om_old == true && om_new == false) {
            om_value_at_transitions_FOR_is_alive_X_true_X_quality_of_schooling_X_false.set(om_value_at_transitions_FOR_is_alive_X_true_X_quality_of_schooling_X_false.get() + quality_of_schooling.get());
        }
    }

    // Code Injection: group=5, injector=value_at_transitions(is_alive, true, false, survived_early_years)
    {
        // Maintain value_at_transitions(is_alive, true, false, survived_early_years)
        if (om_old == true && om_new == false) {
            om_value_at_transitions_FOR_is_alive_X_true_X_survived_early_years_X_false.set(om_value_at_transitions_FOR_is_alive_X_true_X_survived_early_years_X_false.get() + survived_early_years.get());
        }
    }

    // Code Injection: group=5, injector=value_at_transitions(is_alive, true, false, years_of_schooling)
    {
        // Maintain value_at_transitions(is_alive, true, false, years_of_schooling)
        if (om_old == true && om_new == false) {
            om_value_at_transitions_FOR_is_alive_X_true_X_years_of_schooling_X_false.set(om_value_at_transitions_FOR_is_alive_X_true_X_years_of_schooling_X_false.get() + years_of_schooling.get());
        }
    }

    // Code Injection: group=8, injector=om_asAllPerson_filter
    // Maintain identity for 'om_asAllPerson_filter'
    om_asAllPerson_filter_update_identity();

    // Code Injection: group=8, injector=om_asAvailableMaleByTypeImmiScratch_filter
    // Maintain identity for 'om_asAvailableMaleByTypeImmiScratch_filter'
    om_asAvailableMaleByTypeImmiScratch_filter_update_identity();

    // Code Injection: group=8, injector=om_asAvailableMaleByType_filter
    // Maintain identity for 'om_asAvailableMaleByType_filter'
    om_asAvailableMaleByType_filter_update_identity();

    // Code Injection: group=8, injector=om_asAvailableMaleImmiScratch_filter
    // Maintain identity for 'om_asAvailableMaleImmiScratch_filter'
    om_asAvailableMaleImmiScratch_filter_update_identity();

    // Code Injection: group=8, injector=om_asAvailableMale_filter
    // Maintain identity for 'om_asAvailableMale_filter'
    om_asAvailableMale_filter_update_identity();

    // Code Injection: group=8, injector=om_asFemaleInUnionByAgeAndPartnerAgeImmiScratch_filter
    // Maintain identity for 'om_asFemaleInUnionByAgeAndPartnerAgeImmiScratch_filter'
    om_asFemaleInUnionByAgeAndPartnerAgeImmiScratch_filter_update_identity();

    // Code Injection: group=8, injector=om_asFemaleInUnionByAgeAndPartnerAge_filter
    // Maintain identity for 'om_asFemaleInUnionByAgeAndPartnerAge_filter'
    om_asFemaleInUnionByAgeAndPartnerAge_filter_update_identity();

    // Code Injection: group=8, injector=om_asPotentialImmigrantMothers_filter
    // Maintain identity for 'om_asPotentialImmigrantMothers_filter'
    om_asPotentialImmigrantMothers_filter_update_identity();

    // Code Injection: group=8, injector=om_asPotentialSchoolOneStudentToProcess_filter
    // Maintain identity for 'om_asPotentialSchoolOneStudentToProcess_filter'
    om_asPotentialSchoolOneStudentToProcess_filter_update_identity();

    // Code Injection: group=8, injector=om_asPotentialSchoolOneStudent_filter
    // Maintain identity for 'om_asPotentialSchoolOneStudent_filter'
    om_asPotentialSchoolOneStudent_filter_update_identity();

    // Code Injection: group=8, injector=om_asPotentialSchoolTwoStudentToProcess_filter
    // Maintain identity for 'om_asPotentialSchoolTwoStudentToProcess_filter'
    om_asPotentialSchoolTwoStudentToProcess_filter_update_identity();

    // Code Injection: group=8, injector=om_asResidentBabies_filter
    // Maintain identity for 'om_asResidentBabies_filter'
    om_asResidentBabies_filter_update_identity();

    // Code Injection: group=8, injector=om_asResidentsAge0SexGeo_filter
    // Maintain identity for 'om_asResidentsAge0SexGeo_filter'
    om_asResidentsAge0SexGeo_filter_update_identity();

    // Code Injection: group=8, injector=om_asResidentsAge0Sex_filter
    // Maintain identity for 'om_asResidentsAge0Sex_filter'
    om_asResidentsAge0Sex_filter_update_identity();

    // Code Injection: group=8, injector=om_asSimBornAge0_filter
    // Maintain identity for 'om_asSimBornAge0_filter'
    om_asSimBornAge0_filter_update_identity();

    // Code Injection: group=8, injector=om_asWantToMove_filter
    // Maintain identity for 'om_asWantToMove_filter'
    om_asWantToMove_filter_update_identity();

    // Code Injection: group=8, injector=om_asWomenNoChildren_filter
    // Maintain identity for 'om_asWomenNoChildren_filter'
    om_asWomenNoChildren_filter_update_identity();

    // Code Injection: group=8, injector=om_asWomenWithChildren_filter
    // Maintain identity for 'om_asWomenWithChildren_filter'
    om_asWomenWithChildren_filter_update_identity();

    // Code Injection: group=10, injector=om_mlHHFatherChildren_sum_over_is_alive
    // Incremental update of multilink agentvar om_mlHHFatherChildren_sum_over_is_alive
    {
        auto lnk = lHHFather.get();
        if (lnk.get() != nullptr) {
            lnk->om_mlHHFatherChildren_sum_over_is_alive.set(lnk->om_mlHHFatherChildren_sum_over_is_alive + om_new - om_old);
        }
    }


    // Code Injection: group=10, injector=om_mlHHMotherChildren_sum_over_is_alive
    // Incremental update of multilink agentvar om_mlHHMotherChildren_sum_over_is_alive
    {
        auto lnk = lHHMother.get();
        if (lnk.get() != nullptr) {
            lnk->om_mlHHMotherChildren_sum_over_is_alive.set(lnk->om_mlHHMotherChildren_sum_over_is_alive + om_new - om_old);
        }
    }

}
void Person::om_side_effects_is_blocked_from_marriage(bool om_old, bool om_new)
{

    // Code Injection: group=8, injector=om_asWomenNoChildren_filter
    // Maintain identity for 'om_asWomenNoChildren_filter'
    om_asWomenNoChildren_filter_update_identity();

    // Code Injection: group=8, injector=om_asWomenWithChildren_filter
    // Maintain identity for 'om_asWomenWithChildren_filter'
    om_asWomenWithChildren_filter_update_identity();
}
void Person::om_side_effects_is_child(bool om_old, bool om_new)
{

    // Code Injection: group=8, injector=is_aded0
    // Maintain identity for 'is_aded0'
    is_aded0_update_identity();

    // Code Injection: group=8, injector=is_aded1
    // Maintain identity for 'is_aded1'
    is_aded1_update_identity();

    // Code Injection: group=8, injector=is_aded2
    // Maintain identity for 'is_aded2'
    is_aded2_update_identity();

    // Code Injection: group=8, injector=om_aia_16
    // Maintain identity for 'om_aia_16'
    om_aia_16_update_identity();
}
void Person::om_side_effects_is_educ_one_student(bool om_old, bool om_new)
{

    // Code Injection: group=8, injector=educ_one_required_rooms
    // Maintain identity for 'educ_one_required_rooms'
    educ_one_required_rooms_update_identity();

    // Code Injection: group=8, injector=educ_one_required_teachers
    // Maintain identity for 'educ_one_required_teachers'
    educ_one_required_teachers_update_identity();

    // Code Injection: group=8, injector=om_aia_14
    // Maintain identity for 'om_aia_14'
    om_aia_14_update_identity();
}
void Person::om_side_effects_is_fertile(bool om_old, bool om_new)
{

    // Code Injection: group=8, injector=om_asAllFertilePersonsForFertilityAlignmentByAge_filter
    // Maintain identity for 'om_asAllFertilePersonsForFertilityAlignmentByAge_filter'
    om_asAllFertilePersonsForFertilityAlignmentByAge_filter_update_identity();

    // Code Injection: group=8, injector=om_asAllFertilePersonsForFertilityAlignment_filter
    // Maintain identity for 'om_asAllFertilePersonsForFertilityAlignment_filter'
    om_asAllFertilePersonsForFertilityAlignment_filter_update_identity();

    // Code Injection: group=10, injector=om_FertilityBaseEvent_om_event
    // Recalculate time to event FertilityBaseEvent
    if (om_active) om_FertilityBaseEvent_om_event.make_dirty();

    // Code Injection: group=10, injector=om_FertilityDetailedEvent_om_event
    // Recalculate time to event FertilityDetailedEvent
    if (om_active) om_FertilityDetailedEvent_om_event.make_dirty();
}
void Person::om_side_effects_is_immunized(bool om_old, bool om_new)
{

    // Code Injection: group=8, injector=om_aia_39
    // Maintain identity for 'om_aia_39'
    om_aia_39_update_identity();
}
void Person::om_side_effects_is_mortal(bool om_old, bool om_new)
{

    // Code Injection: group=8, injector=om_asAvailableMaleByTypeImmiScratch_filter
    // Maintain identity for 'om_asAvailableMaleByTypeImmiScratch_filter'
    om_asAvailableMaleByTypeImmiScratch_filter_update_identity();

    // Code Injection: group=8, injector=om_asAvailableMaleByType_filter
    // Maintain identity for 'om_asAvailableMaleByType_filter'
    om_asAvailableMaleByType_filter_update_identity();

    // Code Injection: group=8, injector=om_asAvailableMaleImmiScratch_filter
    // Maintain identity for 'om_asAvailableMaleImmiScratch_filter'
    om_asAvailableMaleImmiScratch_filter_update_identity();

    // Code Injection: group=8, injector=om_asAvailableMale_filter
    // Maintain identity for 'om_asAvailableMale_filter'
    om_asAvailableMale_filter_update_identity();

    // Code Injection: group=8, injector=om_asFemaleInUnionByAgeAndPartnerAgeImmiScratch_filter
    // Maintain identity for 'om_asFemaleInUnionByAgeAndPartnerAgeImmiScratch_filter'
    om_asFemaleInUnionByAgeAndPartnerAgeImmiScratch_filter_update_identity();

    // Code Injection: group=8, injector=om_asFemaleInUnionByAgeAndPartnerAge_filter
    // Maintain identity for 'om_asFemaleInUnionByAgeAndPartnerAge_filter'
    om_asFemaleInUnionByAgeAndPartnerAge_filter_update_identity();

    // Code Injection: group=8, injector=om_asWomenNoChildren_filter
    // Maintain identity for 'om_asWomenNoChildren_filter'
    om_asWomenNoChildren_filter_update_identity();

    // Code Injection: group=8, injector=om_asWomenWithChildren_filter
    // Maintain identity for 'om_asWomenWithChildren_filter'
    om_asWomenWithChildren_filter_update_identity();

    // Code Injection: group=8, injector=is_removeable
    // Maintain identity for 'StartpopValues::is_removeable' using reciprocal link
    if (!lStartValues.is_nullptr()) lStartValues->is_removeable_update_identity();

    // Code Injection: group=10, injector=om_EmigrationEvent_om_event
    // Recalculate time to event EmigrationEvent
    if (om_active) om_EmigrationEvent_om_event.make_dirty();

    // Code Injection: group=10, injector=om_FirstUnionFormationEvent_om_event
    // Recalculate time to event FirstUnionFormationEvent
    if (om_active) om_FirstUnionFormationEvent_om_event.make_dirty();

    // Code Injection: group=10, injector=om_MigrationEvent_om_event
    // Recalculate time to event MigrationEvent
    if (om_active) om_MigrationEvent_om_event.make_dirty();

    // Code Injection: group=10, injector=om_MortalityBaseEvent_om_event
    // Recalculate time to event MortalityBaseEvent
    if (om_active) om_MortalityBaseEvent_om_event.make_dirty();

    // Code Injection: group=10, injector=om_MortalityDetailedEvent_om_event
    // Recalculate time to event MortalityDetailedEvent
    if (om_active) om_MortalityDetailedEvent_om_event.make_dirty();
}
void Person::om_side_effects_is_old(bool om_old, bool om_new)
{

    // Code Injection: group=8, injector=is_aded0
    // Maintain identity for 'is_aded0'
    is_aded0_update_identity();

    // Code Injection: group=8, injector=is_aded1
    // Maintain identity for 'is_aded1'
    is_aded1_update_identity();

    // Code Injection: group=8, injector=is_aded2
    // Maintain identity for 'is_aded2'
    is_aded2_update_identity();

    // Code Injection: group=8, injector=om_aia_20
    // Maintain identity for 'om_aia_20'
    om_aia_20_update_identity();
}
void Person::om_side_effects_is_ready_for_birthtables(bool om_old, bool om_new)
{

    // Code Injection: group=1, injector=trigger_entrances(is_ready_for_birthtables, true)
    if (om_active) {
        auto & ss_attr = om_trigger_entrances_FOR_is_ready_for_birthtables_X_true; // the self-scheduling attribute being maintained
        auto & ss_time = om_ss_time_om_trigger_entrances_FOR_is_ready_for_birthtables_X_true; // the scheduled time of maintenance of this self-scheduling attribute
        auto & ss_event = zzz_om_om_ss_event_om_event; // the single event in the entity which maintains all self-scheduling attributes
        const bool k1 = true; // the first constant

        if (om_new == k1) {
            // Activate trigger trigger_entrances(is_ready_for_birthtables, true)
            ss_attr.set(true);
            // Set the self-scheduling event to reset the trigger immediately
            ss_time = time;
            // Mark the entity's self-scheduling event for recalculation
            ss_event.make_dirty();
        }
    }
}
void Person::om_side_effects_is_resident(bool om_old, bool om_new)
{

    // Code Injection: group=8, injector=educ_one_required_rooms
    // Maintain identity for 'educ_one_required_rooms'
    educ_one_required_rooms_update_identity();

    // Code Injection: group=8, injector=educ_one_required_teachers
    // Maintain identity for 'educ_one_required_teachers'
    educ_one_required_teachers_update_identity();

    // Code Injection: group=8, injector=om_aia_14
    // Maintain identity for 'om_aia_14'
    om_aia_14_update_identity();

    // Code Injection: group=8, injector=om_aia_15
    // Maintain identity for 'om_aia_15'
    om_aia_15_update_identity();

    // Code Injection: group=8, injector=om_aia_21
    // Maintain identity for 'om_aia_21'
    om_aia_21_update_identity();

    // Code Injection: group=8, injector=om_aia_22
    // Maintain identity for 'om_aia_22'
    om_aia_22_update_identity();

    // Code Injection: group=8, injector=om_aia_23
    // Maintain identity for 'om_aia_23'
    om_aia_23_update_identity();

    // Code Injection: group=8, injector=om_aia_25
    // Maintain identity for 'om_aia_25'
    om_aia_25_update_identity();

    // Code Injection: group=8, injector=om_aia_26
    // Maintain identity for 'om_aia_26'
    om_aia_26_update_identity();

    // Code Injection: group=8, injector=om_aia_30
    // Maintain identity for 'om_aia_30'
    om_aia_30_update_identity();

    // Code Injection: group=8, injector=om_aia_36
    // Maintain identity for 'om_aia_36'
    om_aia_36_update_identity();

    // Code Injection: group=8, injector=om_aia_37
    // Maintain identity for 'om_aia_37'
    om_aia_37_update_identity();

    // Code Injection: group=8, injector=om_aia_40
    // Maintain identity for 'om_aia_40'
    om_aia_40_update_identity();

    // Code Injection: group=8, injector=om_aia_9
    // Maintain identity for 'om_aia_9'
    om_aia_9_update_identity();

    // Code Injection: group=8, injector=om_asResidentBabies_filter
    // Maintain identity for 'om_asResidentBabies_filter'
    om_asResidentBabies_filter_update_identity();

    // Code Injection: group=8, injector=om_asResidentsAge0SexGeo_filter
    // Maintain identity for 'om_asResidentsAge0SexGeo_filter'
    om_asResidentsAge0SexGeo_filter_update_identity();

    // Code Injection: group=8, injector=om_asResidentsAge0Sex_filter
    // Maintain identity for 'om_asResidentsAge0Sex_filter'
    om_asResidentsAge0Sex_filter_update_identity();

    // Code Injection: group=10, injector=om_BackMigrationEvent_om_event
    // Recalculate time to event BackMigrationEvent
    if (om_active) om_BackMigrationEvent_om_event.make_dirty();

    // Code Injection: group=10, injector=om_EmigrationEvent_om_event
    // Recalculate time to event EmigrationEvent
    if (om_active) om_EmigrationEvent_om_event.make_dirty();

    // Code Injection: group=10, injector=om_MigrationEvent_om_event
    // Recalculate time to event MigrationEvent
    if (om_active) om_MigrationEvent_om_event.make_dirty();

    // Code Injection: group=10, injector=om_SetPreschoolYearsEvent_om_event
    // Recalculate time to event SetPreschoolYearsEvent
    if (om_active) om_SetPreschoolYearsEvent_om_event.make_dirty();

    // Code Injection: group=10, injector=asAllFertilePersonsForFertilityAlignment
    // cell change in asAllFertilePersonsForFertilityAlignment
    if (om_active) {
        if (om_asAllFertilePersonsForFertilityAlignment_filter) {
            om_asAllFertilePersonsForFertilityAlignment_erase();
            om_asAllFertilePersonsForFertilityAlignment_update_cell();
            om_asAllFertilePersonsForFertilityAlignment_insert();
        }
    }

    // Code Injection: group=10, injector=asAllFertilePersonsForFertilityAlignmentByAge
    // cell change in asAllFertilePersonsForFertilityAlignmentByAge
    if (om_active) {
        if (om_asAllFertilePersonsForFertilityAlignmentByAge_filter) {
            om_asAllFertilePersonsForFertilityAlignmentByAge_erase();
            om_asAllFertilePersonsForFertilityAlignmentByAge_update_cell();
            om_asAllFertilePersonsForFertilityAlignmentByAge_insert();
        }
    }
}
void Person::om_side_effects_is_stunted(bool om_old, bool om_new)
{
}
void Person::om_side_effects_lBioFather(entity_ptr<Person> om_old, entity_ptr<Person> om_new)
{
    // Maintain reciprocal multi-link: mlBioFatherChildren in Person
    if (om_old.get() != nullptr) {
        om_old->mlBioFatherChildren.erase(this);
    }
    if (om_new.get() != nullptr) {
        om_new->mlBioFatherChildren.insert(this);
    }

}
void Person::om_side_effects_lBioMother(entity_ptr<Person> om_old, entity_ptr<Person> om_new)
{
    // Maintain reciprocal multi-link: mlBioMotherChildren in Person
    if (om_old.get() != nullptr) {
        om_old->mlBioMotherChildren.erase(this);
    }
    if (om_new.get() != nullptr) {
        om_new->mlBioMotherChildren.insert(this);
    }

}
void Person::om_side_effects_lCalibrator(entity_ptr<Calibrator> om_old, entity_ptr<Calibrator> om_new)
{

    // Code Injection: group=8, injector=child_mortality
    // Maintain identity for 'Person::child_mortality' when link changed to different agent
    child_mortality_update_identity();
    // Maintain reciprocal multi-link: mlCalibratorToPerson in Calibrator
    if (om_old.get() != nullptr) {
        om_old->mlCalibratorToPerson.erase(this);
    }
    if (om_new.get() != nullptr) {
        om_new->mlCalibratorToPerson.insert(this);
    }

}
void Person::om_side_effects_lHHFather(entity_ptr<Person> om_old, entity_ptr<Person> om_new)
{

    // Code Injection: group=8, injector=family_role
    // Maintain identity for 'family_role'
    family_role_update_identity();
    // Maintain reciprocal multi-link: mlHHFatherChildren in Person
    if (om_old.get() != nullptr) {
        om_old->mlHHFatherChildren.erase(this);
    }
    if (om_new.get() != nullptr) {
        om_new->mlHHFatherChildren.insert(this);
    }

}
void Person::om_side_effects_lHHMother(entity_ptr<Person> om_old, entity_ptr<Person> om_new)
{

    // Code Injection: group=8, injector=family_role
    // Maintain identity for 'family_role'
    family_role_update_identity();
    // Maintain reciprocal multi-link: mlHHMotherChildren in Person
    if (om_old.get() != nullptr) {
        om_old->mlHHMotherChildren.erase(this);
    }
    if (om_new.get() != nullptr) {
        om_new->mlHHMotherChildren.insert(this);
    }

}
void Person::om_side_effects_lSpouse(entity_ptr<Person> om_old, entity_ptr<Person> om_new)
{

    // Code Injection: group=8, injector=family_role
    // Maintain identity for 'family_role'
    family_role_update_identity();

    // Code Injection: group=8, injector=has_spouse
    // Maintain identity for 'has_spouse'
    has_spouse_update_identity();

    // Code Injection: group=8, injector=male_spouse_age
    // Maintain identity for 'Person::male_spouse_age' when link changed to different agent
    male_spouse_age_update_identity();

    // Code Injection: group=8, injector=spouse_group
    // Maintain identity for 'Person::spouse_group' when link changed to different agent
    spouse_group_update_identity();
    // Maintain reciprocal single link: lSpouse in Person
    if (om_old.get() != nullptr && om_old->lSpouse.get().get() == this) {
        om_old->lSpouse = nullptr;
    }
    if (om_new.get() != nullptr && om_new->lSpouse.get().get() != this) {
        om_new->lSpouse = this;
    }

}
void Person::om_side_effects_lStartValues(entity_ptr<StartpopValues> om_old, entity_ptr<StartpopValues> om_new)
{
    // Maintain reciprocal single link: lPersonStartpop in StartpopValues
    if (om_old.get() != nullptr && om_old->lPersonStartpop.get().get() == this) {
        om_old->lPersonStartpop = nullptr;
    }
    if (om_new.get() != nullptr && om_new->lPersonStartpop.get().get() != this) {
        om_new->lPersonStartpop = this;
    }

}
void Person::om_side_effects_lives_with_dependent_child(bool om_old, bool om_new)
{

    // Code Injection: group=8, injector=age_last_birth
    // Maintain identity for 'age_last_birth'
    age_last_birth_update_identity();

    // Code Injection: group=8, injector=om_asWomenNoChildren_filter
    // Maintain identity for 'om_asWomenNoChildren_filter'
    om_asWomenNoChildren_filter_update_identity();

    // Code Injection: group=8, injector=om_asWomenWithChildren_filter
    // Maintain identity for 'om_asWomenWithChildren_filter'
    om_asWomenWithChildren_filter_update_identity();
}
void Person::om_side_effects_male_age(MALE_SPOUSE_AGE om_old, MALE_SPOUSE_AGE om_new)
{

    // Code Injection: group=10, injector=asAvailableMale
    // cell change in asAvailableMale
    if (om_active) {
        if (om_asAvailableMale_filter) {
            om_asAvailableMale_erase();
            om_asAvailableMale_update_cell();
            om_asAvailableMale_insert();
        }
    }

    // Code Injection: group=10, injector=asAvailableMaleByType
    // cell change in asAvailableMaleByType
    if (om_active) {
        if (om_asAvailableMaleByType_filter) {
            om_asAvailableMaleByType_erase();
            om_asAvailableMaleByType_update_cell();
            om_asAvailableMaleByType_insert();
        }
    }

    // Code Injection: group=10, injector=asAvailableMaleByTypeImmiScratch
    // cell change in asAvailableMaleByTypeImmiScratch
    if (om_active) {
        if (om_asAvailableMaleByTypeImmiScratch_filter) {
            om_asAvailableMaleByTypeImmiScratch_erase();
            om_asAvailableMaleByTypeImmiScratch_update_cell();
            om_asAvailableMaleByTypeImmiScratch_insert();
        }
    }

    // Code Injection: group=10, injector=asAvailableMaleImmiScratch
    // cell change in asAvailableMaleImmiScratch
    if (om_active) {
        if (om_asAvailableMaleImmiScratch_filter) {
            om_asAvailableMaleImmiScratch_erase();
            om_asAvailableMaleImmiScratch_update_cell();
            om_asAvailableMaleImmiScratch_insert();
        }
    }
}
void Person::om_side_effects_male_spouse_age(MALE_SPOUSE_AGE om_old, MALE_SPOUSE_AGE om_new)
{

    // Code Injection: group=10, injector=asFemaleInUnionByAgeAndPartnerAge
    // cell change in asFemaleInUnionByAgeAndPartnerAge
    if (om_active) {
        if (om_asFemaleInUnionByAgeAndPartnerAge_filter) {
            om_asFemaleInUnionByAgeAndPartnerAge_erase();
            om_asFemaleInUnionByAgeAndPartnerAge_update_cell();
            om_asFemaleInUnionByAgeAndPartnerAge_insert();
        }
    }

    // Code Injection: group=10, injector=asFemaleInUnionByAgeAndPartnerAgeImmiScratch
    // cell change in asFemaleInUnionByAgeAndPartnerAgeImmiScratch
    if (om_active) {
        if (om_asFemaleInUnionByAgeAndPartnerAgeImmiScratch_filter) {
            om_asFemaleInUnionByAgeAndPartnerAgeImmiScratch_erase();
            om_asFemaleInUnionByAgeAndPartnerAgeImmiScratch_update_cell();
            om_asFemaleInUnionByAgeAndPartnerAgeImmiScratch_insert();
        }
    }
}
void Person::om_side_effects_moth_agegr(MOTH_AGEGR om_old, MOTH_AGEGR om_new)
{

    // Code Injection: group=10, injector=asWomenWithChildren
    // cell change in asWomenWithChildren
    if (om_active) {
        if (om_asWomenWithChildren_filter) {
            om_asWomenWithChildren_erase();
            om_asWomenWithChildren_update_cell();
            om_asWomenWithChildren_insert();
        }
    }
}
void Person::om_side_effects_moth_agegr_part(int om_old, int om_new)
{

    // Code Injection: group=8, injector=moth_agegr
    // Maintain identity for 'moth_agegr'
    moth_agegr_update_identity();
}
void Person::om_side_effects_mother_age_at_birth(double om_old, double om_new)
{

    // Code Injection: group=8, injector=child_mortality_group
    // Maintain identity for 'child_mortality_group'
    child_mortality_group_update_identity();
}
void Person::om_side_effects_om_active_spell_duration_FOR_this_parity_spell_X_true(Time om_old, Time om_new)
{
}
void Person::om_side_effects_om_aggregate_FOR_ethnicity_X_ETHNICITY_SHORT(ETHNICITY_SHORT om_old, ETHNICITY_SHORT om_new)
{

    // Code Injection: group=8, injector=ethnicity_short
    // Maintain identity for 'ethnicity_short'
    ethnicity_short_update_identity();
}
void Person::om_side_effects_om_aggregate_FOR_geo_X_GEO_NAT(GEO_NAT om_old, GEO_NAT om_new)
{

    // Code Injection: group=8, injector=geo_nat
    // Maintain identity for 'geo_nat'
    geo_nat_update_identity();
}
void Person::om_side_effects_om_aggregate_FOR_geo_X_REGION_INT(REGION_INT om_old, REGION_INT om_new)
{

    // Code Injection: group=8, injector=region_int
    // Maintain identity for 'region_int'
    region_int_update_identity();
}
void Person::om_side_effects_om_aggregate_FOR_geo_birth_X_GEO_NAT(GEO_NAT om_old, GEO_NAT om_new)
{

    // Code Injection: group=10, injector=TabHCIDistrict
    // Cell change in TabHCIDistrict
    if (om_active && theTabHCIDistrict) {
        // Check and start pending increment in entity table TabHCIDistrict
        auto cell = om_TabHCIDistrict_current_cell();
        auto & incr = om_TabHCIDistrict_incr;
        incr.set_cell(cell);
        incr.start_pending();
    }
}
void Person::om_side_effects_om_aggregate_FOR_geo_birth_X_REGION_INT(REGION_INT om_old, REGION_INT om_new)
{

    // Code Injection: group=8, injector=region_birth
    // Maintain identity for 'region_birth'
    region_birth_update_identity();
}
void Person::om_side_effects_om_aggregate_FOR_region_birth_X_REGION_NAT(REGION_NAT om_old, REGION_NAT om_new)
{

    // Code Injection: group=10, injector=TabEducFateDistrYob
    // Cell change in TabEducFateDistrYob
    if (om_active && theTabEducFateDistrYob) {
        // Check and start pending increment in entity table TabEducFateDistrYob
        auto cell = om_TabEducFateDistrYob_current_cell();
        auto & incr = om_TabEducFateDistrYob_incr;
        incr.set_cell(cell);
        incr.start_pending();
    }

    // Code Injection: group=10, injector=tabHCI
    // Cell change in tabHCI
    if (om_active && thetabHCI) {
        // Check and start pending increment in entity table tabHCI
        auto cell = om_tabHCI_current_cell();
        auto & incr = om_tabHCI_incr;
        incr.set_cell(cell);
        incr.start_pending();
    }
}
void Person::om_side_effects_om_aggregate_FOR_region_int_X_REGION_NAT(REGION_NAT om_old, REGION_NAT om_new)
{

    // Code Injection: group=8, injector=region_nat
    // Maintain identity for 'region_nat'
    region_nat_update_identity();
}
void Person::om_side_effects_om_aia_0(bool om_old, bool om_new)
{

    // Code Injection: group=4, injector=active_spell_duration(this_parity_spell, true)
    if (om_new == false) {
        // Active spell is ending, set active_spell_duration(this_parity_spell, true) to zero.
        om_active_spell_duration_FOR_this_parity_spell_X_true.set(0);
    }

    // Code Injection: group=5, injector=self_scheduling_split(active_spell_duration(this_parity_spell, true), DUR_TIME_IN_PARITY)
    if (om_active) {
        auto & ss_attr = om_self_scheduling_split_FOR_om_active_spell_duration_FOR_this_parity_spell_X_true_X_DUR_TIME_IN_PARITY;
        auto & ss_time = om_ss_time_om_self_scheduling_split_FOR_om_active_spell_duration_FOR_this_parity_spell_X_true_X_DUR_TIME_IN_PARITY;
        auto & ss_event = zzz_om_om_ss_event_om_event;
        auto part = ss_attr.get(); // working copy of partition
        // The self-scheduling event will require recalculation
        ss_event.make_dirty();

        if (om_new == true) {
            // Active spell is starting, initialize self-scheduling attribute
            // Set the partitioned duration to the interval containing zero.
            part.set_from_value(0);
            ss_attr.set(part);
            // The time to wait is the upper bound of the current interval in the partition.
            if (part.upper() == REAL_MAX) ss_time = time_infinite;
            else ss_time = time + part.upper();
        }
        else {
            // The active spell is ending, so reset self-scheduling attribute.
            // Set the partitioned duration to the interval containing zero.
            part.set_from_value(0);
            ss_attr.set(part);
            // There is no next change scheduled.
            ss_time = time_infinite;
        }
    } // if (om_active)
}
void Person::om_side_effects_om_aia_1(bool om_old, bool om_new)
{

    // Code Injection: group=10, injector=tabPreSchool
    // filter change in tabPreSchool
    if (om_active && thetabPreSchool) {
        // Check and start pending increment in entity table tabPreSchool
        auto & incr = om_tabPreSchool_incr;
        incr.set_filter(om_new);
        incr.start_pending();
    }
}
void Person::om_side_effects_om_aia_10(bool om_old, bool om_new)
{
}
void Person::om_side_effects_om_aia_11(bool om_old, bool om_new)
{
}
void Person::om_side_effects_om_aia_12(bool om_old, bool om_new)
{
}
void Person::om_side_effects_om_aia_13(bool om_old, bool om_new)
{

    // Code Injection: group=10, injector=TabEducFateByGroup
    // filter change in TabEducFateByGroup
    if (om_active && theTabEducFateByGroup) {
        // Check and start pending increment in entity table TabEducFateByGroup
        auto & incr = om_TabEducFateByGroup_incr;
        incr.set_filter(om_new);
        incr.start_pending();
    }
}
void Person::om_side_effects_om_aia_14(bool om_old, bool om_new)
{

    // Code Injection: group=10, injector=TabPrimarySchoolPlanning
    // filter change in TabPrimarySchoolPlanning
    if (om_active && theTabPrimarySchoolPlanning) {
        // Check and start pending increment in entity table TabPrimarySchoolPlanning
        auto & incr = om_TabPrimarySchoolPlanning_incr;
        incr.set_filter(om_new);
        incr.start_pending();
    }
}
void Person::om_side_effects_om_aia_15(bool om_old, bool om_new)
{

    // Code Injection: group=10, injector=TabPopProvAgeEducSex
    // filter change in TabPopProvAgeEducSex
    if (om_active && theTabPopProvAgeEducSex) {
        // Check and start pending increment in entity table TabPopProvAgeEducSex
        auto & incr = om_TabPopProvAgeEducSex_incr;
        incr.set_filter(om_new);
        incr.start_pending();
    }

    // Code Injection: group=10, injector=TabPrimSchoolEntries
    // filter change in TabPrimSchoolEntries
    if (om_active && theTabPrimSchoolEntries) {
        // Check and start pending increment in entity table TabPrimSchoolEntries
        auto & incr = om_TabPrimSchoolEntries_incr;
        incr.set_filter(om_new);
        incr.start_pending();
    }

    // Code Injection: group=10, injector=TabPrimSchoolGraduations
    // filter change in TabPrimSchoolGraduations
    if (om_active && theTabPrimSchoolGraduations) {
        // Check and start pending increment in entity table TabPrimSchoolGraduations
        auto & incr = om_TabPrimSchoolGraduations_incr;
        incr.set_filter(om_new);
        incr.start_pending();
    }
}
void Person::om_side_effects_om_aia_16(bool om_old, bool om_new)
{
}
void Person::om_side_effects_om_aia_17(bool om_old, bool om_new)
{
}
void Person::om_side_effects_om_aia_18(bool om_old, bool om_new)
{
}
void Person::om_side_effects_om_aia_19(bool om_old, bool om_new)
{
}
void Person::om_side_effects_om_aia_2(bool om_old, bool om_new)
{
}
void Person::om_side_effects_om_aia_20(bool om_old, bool om_new)
{
}
void Person::om_side_effects_om_aia_21(bool om_old, bool om_new)
{

    // Code Injection: group=10, injector=TabEducFateDistrYob
    // filter change in TabEducFateDistrYob
    if (om_active && theTabEducFateDistrYob) {
        // Check and start pending increment in entity table TabEducFateDistrYob
        auto & incr = om_TabEducFateDistrYob_incr;
        incr.set_filter(om_new);
        incr.start_pending();
    }
}
void Person::om_side_effects_om_aia_22(bool om_old, bool om_new)
{

    // Code Injection: group=10, injector=TabEduc15ByDistrict
    // filter change in TabEduc15ByDistrict
    if (om_active && theTabEduc15ByDistrict) {
        // Check and start pending increment in entity table TabEduc15ByDistrict
        auto & incr = om_TabEduc15ByDistrict_incr;
        incr.set_filter(om_new);
        incr.start_pending();
    }

    // Code Injection: group=10, injector=TabEduc15ByDistrictBirth
    // filter change in TabEduc15ByDistrictBirth
    if (om_active && theTabEduc15ByDistrictBirth) {
        // Check and start pending increment in entity table TabEduc15ByDistrictBirth
        auto & incr = om_TabEduc15ByDistrictBirth_incr;
        incr.set_filter(om_new);
        incr.start_pending();
    }
}
void Person::om_side_effects_om_aia_23(bool om_old, bool om_new)
{

    // Code Injection: group=10, injector=TabPrimSchoolOutOfSchool9to11
    // filter change in TabPrimSchoolOutOfSchool9to11
    if (om_active && theTabPrimSchoolOutOfSchool9to11) {
        // Check and start pending increment in entity table TabPrimSchoolOutOfSchool9to11
        auto & incr = om_TabPrimSchoolOutOfSchool9to11_incr;
        incr.set_filter(om_new);
        incr.start_pending();
    }
}
void Person::om_side_effects_om_aia_24(bool om_old, bool om_new)
{
}
void Person::om_side_effects_om_aia_25(bool om_old, bool om_new)
{

    // Code Injection: group=10, injector=TabSchool2TrackTab
    // filter change in TabSchool2TrackTab
    if (om_active && theTabSchool2TrackTab) {
        // Check and start pending increment in entity table TabSchool2TrackTab
        auto & incr = om_TabSchool2TrackTab_incr;
        incr.set_filter(om_new);
        incr.start_pending();
    }
}
void Person::om_side_effects_om_aia_26(bool om_old, bool om_new)
{

    // Code Injection: group=10, injector=TabSchool2AttainmentsTab
    // filter change in TabSchool2AttainmentsTab
    if (om_active && theTabSchool2AttainmentsTab) {
        // Check and start pending increment in entity table TabSchool2AttainmentsTab
        auto & incr = om_TabSchool2AttainmentsTab_incr;
        incr.set_filter(om_new);
        incr.start_pending();
    }
}
void Person::om_side_effects_om_aia_27(bool om_old, bool om_new)
{
}
void Person::om_side_effects_om_aia_28(bool om_old, bool om_new)
{
}
void Person::om_side_effects_om_aia_29(bool om_old, bool om_new)
{
}
void Person::om_side_effects_om_aia_3(bool om_old, bool om_new)
{
}
void Person::om_side_effects_om_aia_30(bool om_old, bool om_new)
{

    // Code Injection: group=10, injector=tabHavingSpouse
    // filter change in tabHavingSpouse
    if (om_active && thetabHavingSpouse) {
        // Check and start pending increment in entity table tabHavingSpouse
        auto & incr = om_tabHavingSpouse_incr;
        incr.set_filter(om_new);
        incr.start_pending();
    }
}
void Person::om_side_effects_om_aia_31(bool om_old, bool om_new)
{
}
void Person::om_side_effects_om_aia_32(bool om_old, bool om_new)
{
}
void Person::om_side_effects_om_aia_33(bool om_old, bool om_new)
{

    // Code Injection: group=10, injector=TabHCIDistrict
    // filter change in TabHCIDistrict
    if (om_active && theTabHCIDistrict) {
        // Check and start pending increment in entity table TabHCIDistrict
        auto & incr = om_TabHCIDistrict_incr;
        incr.set_filter(om_new);
        incr.start_pending();
    }

    // Code Injection: group=10, injector=tabHCI
    // filter change in tabHCI
    if (om_active && thetabHCI) {
        // Check and start pending increment in entity table tabHCI
        auto & incr = om_tabHCI_incr;
        incr.set_filter(om_new);
        incr.start_pending();
    }
}
void Person::om_side_effects_om_aia_34(bool om_old, bool om_new)
{

    // Code Injection: group=10, injector=tabBirthsYearPlace
    // filter change in tabBirthsYearPlace
    if (om_active && thetabBirthsYearPlace) {
        // Check and start pending increment in entity table tabBirthsYearPlace
        auto & incr = om_tabBirthsYearPlace_incr;
        incr.set_filter(om_new);
        incr.start_pending();
    }

    // Code Injection: group=10, injector=tabPopulationYearPlace
    // filter change in tabPopulationYearPlace
    if (om_active && thetabPopulationYearPlace) {
        // Check and start pending increment in entity table tabPopulationYearPlace
        auto & incr = om_tabPopulationYearPlace_incr;
        incr.set_filter(om_new);
        incr.start_pending();
    }
}
void Person::om_side_effects_om_aia_35(bool om_old, bool om_new)
{

    // Code Injection: group=10, injector=tabMigrationOriginDestination
    // filter change in tabMigrationOriginDestination
    if (om_active && thetabMigrationOriginDestination) {
        // Check and start pending increment in entity table tabMigrationOriginDestination
        auto & incr = om_tabMigrationOriginDestination_incr;
        incr.set_filter(om_new);
        incr.start_pending();
    }
}
void Person::om_side_effects_om_aia_36(bool om_old, bool om_new)
{

    // Code Injection: group=10, injector=tabStuntingSexRegMotherYob
    // filter change in tabStuntingSexRegMotherYob
    if (om_active && thetabStuntingSexRegMotherYob) {
        // Check and start pending increment in entity table tabStuntingSexRegMotherYob
        auto & incr = om_tabStuntingSexRegMotherYob_incr;
        incr.set_filter(om_new);
        incr.start_pending();
    }

    // Code Injection: group=10, injector=tabStuntingSexRegYob
    // filter change in tabStuntingSexRegYob
    if (om_active && thetabStuntingSexRegYob) {
        // Check and start pending increment in entity table tabStuntingSexRegYob
        auto & incr = om_tabStuntingSexRegYob_incr;
        incr.set_filter(om_new);
        incr.start_pending();
    }
}
void Person::om_side_effects_om_aia_37(bool om_old, bool om_new)
{

    // Code Injection: group=10, injector=TabImmunizationChildren
    // filter change in TabImmunizationChildren
    if (om_active && theTabImmunizationChildren) {
        // Check and start pending increment in entity table TabImmunizationChildren
        auto & incr = om_TabImmunizationChildren_incr;
        incr.set_filter(om_new);
        incr.start_pending();
    }

    // Code Injection: group=10, injector=TabPrenatCare
    // filter change in TabPrenatCare
    if (om_active && theTabPrenatCare) {
        // Check and start pending increment in entity table TabPrenatCare
        auto & incr = om_TabPrenatCare_incr;
        incr.set_filter(om_new);
        incr.start_pending();
    }
}
void Person::om_side_effects_om_aia_38(bool om_old, bool om_new)
{
}
void Person::om_side_effects_om_aia_39(bool om_old, bool om_new)
{
}
void Person::om_side_effects_om_aia_4(bool om_old, bool om_new)
{
}
void Person::om_side_effects_om_aia_40(bool om_old, bool om_new)
{

    // Code Injection: group=10, injector=TabChildVaccination
    // filter change in TabChildVaccination
    if (om_active && theTabChildVaccination) {
        // Check and start pending increment in entity table TabChildVaccination
        auto & incr = om_TabChildVaccination_incr;
        incr.set_filter(om_new);
        incr.start_pending();
    }
}
void Person::om_side_effects_om_aia_5(bool om_old, bool om_new)
{

    // Code Injection: group=10, injector=tabEducationFateGeobirYob
    // filter change in tabEducationFateGeobirYob
    if (om_active && thetabEducationFateGeobirYob) {
        // Check and start pending increment in entity table tabEducationFateGeobirYob
        auto & incr = om_tabEducationFateGeobirYob_incr;
        incr.set_filter(om_new);
        incr.start_pending();
    }
}
void Person::om_side_effects_om_aia_6(bool om_old, bool om_new)
{
}
void Person::om_side_effects_om_aia_7(bool om_old, bool om_new)
{
}
void Person::om_side_effects_om_aia_8(bool om_old, bool om_new)
{
}
void Person::om_side_effects_om_aia_9(bool om_old, bool om_new)
{

    // Code Injection: group=10, injector=PopPyramidByEduc
    // filter change in PopPyramidByEduc
    if (om_active && thePopPyramidByEduc) {
        // Check and start pending increment in entity table PopPyramidByEduc
        auto & incr = om_PopPyramidByEduc_incr;
        incr.set_filter(om_new);
        incr.start_pending();
    }
}
void Person::om_side_effects_om_asAllFertilePersonsForFertilityAlignmentByAge_filter(bool om_old, bool om_new)
{

    // Code Injection: group=10, injector=asAllFertilePersonsForFertilityAlignmentByAge
    // filter change in asAllFertilePersonsForFertilityAlignmentByAge
    if (om_active) {
        if (om_new) {
            // filter changed from false to true
            om_asAllFertilePersonsForFertilityAlignmentByAge_update_cell();
            om_asAllFertilePersonsForFertilityAlignmentByAge_insert();
        }
        else {
            // filter changed from true to false
            om_asAllFertilePersonsForFertilityAlignmentByAge_erase();
        }
    }
}
void Person::om_side_effects_om_asAllFertilePersonsForFertilityAlignment_filter(bool om_old, bool om_new)
{

    // Code Injection: group=10, injector=asAllFertilePersonsForFertilityAlignment
    // filter change in asAllFertilePersonsForFertilityAlignment
    if (om_active) {
        if (om_new) {
            // filter changed from false to true
            om_asAllFertilePersonsForFertilityAlignment_update_cell();
            om_asAllFertilePersonsForFertilityAlignment_insert();
        }
        else {
            // filter changed from true to false
            om_asAllFertilePersonsForFertilityAlignment_erase();
        }
    }
}
void Person::om_side_effects_om_asAllPerson_filter(bool om_old, bool om_new)
{

    // Code Injection: group=10, injector=asAllPerson
    // filter change in asAllPerson
    if (om_active) {
        if (om_new) {
            // filter changed from false to true
            om_asAllPerson_update_cell();
            om_asAllPerson_insert();
        }
        else {
            // filter changed from true to false
            om_asAllPerson_erase();
        }
    }
}
void Person::om_side_effects_om_asAvailableMaleByTypeImmiScratch_filter(bool om_old, bool om_new)
{

    // Code Injection: group=10, injector=asAvailableMaleByTypeImmiScratch
    // filter change in asAvailableMaleByTypeImmiScratch
    if (om_active) {
        if (om_new) {
            // filter changed from false to true
            om_asAvailableMaleByTypeImmiScratch_update_cell();
            om_asAvailableMaleByTypeImmiScratch_insert();
        }
        else {
            // filter changed from true to false
            om_asAvailableMaleByTypeImmiScratch_erase();
        }
    }
}
void Person::om_side_effects_om_asAvailableMaleByType_filter(bool om_old, bool om_new)
{

    // Code Injection: group=10, injector=asAvailableMaleByType
    // filter change in asAvailableMaleByType
    if (om_active) {
        if (om_new) {
            // filter changed from false to true
            om_asAvailableMaleByType_update_cell();
            om_asAvailableMaleByType_insert();
        }
        else {
            // filter changed from true to false
            om_asAvailableMaleByType_erase();
        }
    }
}
void Person::om_side_effects_om_asAvailableMaleImmiScratch_filter(bool om_old, bool om_new)
{

    // Code Injection: group=10, injector=asAvailableMaleImmiScratch
    // filter change in asAvailableMaleImmiScratch
    if (om_active) {
        if (om_new) {
            // filter changed from false to true
            om_asAvailableMaleImmiScratch_update_cell();
            om_asAvailableMaleImmiScratch_insert();
        }
        else {
            // filter changed from true to false
            om_asAvailableMaleImmiScratch_erase();
        }
    }
}
void Person::om_side_effects_om_asAvailableMale_filter(bool om_old, bool om_new)
{

    // Code Injection: group=10, injector=asAvailableMale
    // filter change in asAvailableMale
    if (om_active) {
        if (om_new) {
            // filter changed from false to true
            om_asAvailableMale_update_cell();
            om_asAvailableMale_insert();
        }
        else {
            // filter changed from true to false
            om_asAvailableMale_erase();
        }
    }
}
void Person::om_side_effects_om_asFemaleInUnionByAgeAndPartnerAgeImmiScratch_filter(bool om_old, bool om_new)
{

    // Code Injection: group=10, injector=asFemaleInUnionByAgeAndPartnerAgeImmiScratch
    // filter change in asFemaleInUnionByAgeAndPartnerAgeImmiScratch
    if (om_active) {
        if (om_new) {
            // filter changed from false to true
            om_asFemaleInUnionByAgeAndPartnerAgeImmiScratch_update_cell();
            om_asFemaleInUnionByAgeAndPartnerAgeImmiScratch_insert();
        }
        else {
            // filter changed from true to false
            om_asFemaleInUnionByAgeAndPartnerAgeImmiScratch_erase();
        }
    }
}
void Person::om_side_effects_om_asFemaleInUnionByAgeAndPartnerAge_filter(bool om_old, bool om_new)
{

    // Code Injection: group=10, injector=asFemaleInUnionByAgeAndPartnerAge
    // filter change in asFemaleInUnionByAgeAndPartnerAge
    if (om_active) {
        if (om_new) {
            // filter changed from false to true
            om_asFemaleInUnionByAgeAndPartnerAge_update_cell();
            om_asFemaleInUnionByAgeAndPartnerAge_insert();
        }
        else {
            // filter changed from true to false
            om_asFemaleInUnionByAgeAndPartnerAge_erase();
        }
    }
}
void Person::om_side_effects_om_asPotentialImmigrantMothers_filter(bool om_old, bool om_new)
{

    // Code Injection: group=10, injector=asPotentialImmigrantMothers
    // filter change in asPotentialImmigrantMothers
    if (om_active) {
        if (om_new) {
            // filter changed from false to true
            om_asPotentialImmigrantMothers_update_cell();
            om_asPotentialImmigrantMothers_insert();
        }
        else {
            // filter changed from true to false
            om_asPotentialImmigrantMothers_erase();
        }
    }
}
void Person::om_side_effects_om_asPotentialSchoolOneStudentToProcess_filter(bool om_old, bool om_new)
{

    // Code Injection: group=10, injector=asPotentialSchoolOneStudentToProcess
    // filter change in asPotentialSchoolOneStudentToProcess
    if (om_active) {
        if (om_new) {
            // filter changed from false to true
            om_asPotentialSchoolOneStudentToProcess_update_cell();
            om_asPotentialSchoolOneStudentToProcess_insert();
        }
        else {
            // filter changed from true to false
            om_asPotentialSchoolOneStudentToProcess_erase();
        }
    }
}
void Person::om_side_effects_om_asPotentialSchoolOneStudent_filter(bool om_old, bool om_new)
{

    // Code Injection: group=10, injector=asPotentialSchoolOneStudent
    // filter change in asPotentialSchoolOneStudent
    if (om_active) {
        if (om_new) {
            // filter changed from false to true
            om_asPotentialSchoolOneStudent_update_cell();
            om_asPotentialSchoolOneStudent_insert();
        }
        else {
            // filter changed from true to false
            om_asPotentialSchoolOneStudent_erase();
        }
    }
}
void Person::om_side_effects_om_asPotentialSchoolTwoStudentToProcess_filter(bool om_old, bool om_new)
{

    // Code Injection: group=10, injector=asPotentialSchoolTwoStudentToProcess
    // filter change in asPotentialSchoolTwoStudentToProcess
    if (om_active) {
        if (om_new) {
            // filter changed from false to true
            om_asPotentialSchoolTwoStudentToProcess_update_cell();
            om_asPotentialSchoolTwoStudentToProcess_insert();
        }
        else {
            // filter changed from true to false
            om_asPotentialSchoolTwoStudentToProcess_erase();
        }
    }
}
void Person::om_side_effects_om_asPotentialSchoolTwoStudent_filter(bool om_old, bool om_new)
{

    // Code Injection: group=10, injector=asPotentialSchoolTwoStudent
    // filter change in asPotentialSchoolTwoStudent
    if (om_active) {
        if (om_new) {
            // filter changed from false to true
            om_asPotentialSchoolTwoStudent_update_cell();
            om_asPotentialSchoolTwoStudent_insert();
        }
        else {
            // filter changed from true to false
            om_asPotentialSchoolTwoStudent_erase();
        }
    }
}
void Person::om_side_effects_om_asResidentBabies_filter(bool om_old, bool om_new)
{

    // Code Injection: group=10, injector=asResidentBabies
    // filter change in asResidentBabies
    if (om_active) {
        if (om_new) {
            // filter changed from false to true
            om_asResidentBabies_update_cell();
            om_asResidentBabies_insert();
        }
        else {
            // filter changed from true to false
            om_asResidentBabies_erase();
        }
    }
}
void Person::om_side_effects_om_asResidentsAge0SexGeo_filter(bool om_old, bool om_new)
{

    // Code Injection: group=10, injector=asResidentsAge0SexGeo
    // filter change in asResidentsAge0SexGeo
    if (om_active) {
        if (om_new) {
            // filter changed from false to true
            om_asResidentsAge0SexGeo_update_cell();
            om_asResidentsAge0SexGeo_insert();
        }
        else {
            // filter changed from true to false
            om_asResidentsAge0SexGeo_erase();
        }
    }
}
void Person::om_side_effects_om_asResidentsAge0Sex_filter(bool om_old, bool om_new)
{

    // Code Injection: group=10, injector=asResidentsAge0Sex
    // filter change in asResidentsAge0Sex
    if (om_active) {
        if (om_new) {
            // filter changed from false to true
            om_asResidentsAge0Sex_update_cell();
            om_asResidentsAge0Sex_insert();
        }
        else {
            // filter changed from true to false
            om_asResidentsAge0Sex_erase();
        }
    }
}
void Person::om_side_effects_om_asSimBornAge0_filter(bool om_old, bool om_new)
{

    // Code Injection: group=10, injector=asSimBornAge0
    // filter change in asSimBornAge0
    if (om_active) {
        if (om_new) {
            // filter changed from false to true
            om_asSimBornAge0_update_cell();
            om_asSimBornAge0_insert();
        }
        else {
            // filter changed from true to false
            om_asSimBornAge0_erase();
        }
    }
}
void Person::om_side_effects_om_asWantToMove_filter(bool om_old, bool om_new)
{

    // Code Injection: group=10, injector=asWantToMove
    // filter change in asWantToMove
    if (om_active) {
        if (om_new) {
            // filter changed from false to true
            om_asWantToMove_update_cell();
            om_asWantToMove_insert();
        }
        else {
            // filter changed from true to false
            om_asWantToMove_erase();
        }
    }
}
void Person::om_side_effects_om_asWomenNoChildren_filter(bool om_old, bool om_new)
{

    // Code Injection: group=10, injector=asWomenNoChildren
    // filter change in asWomenNoChildren
    if (om_active) {
        if (om_new) {
            // filter changed from false to true
            om_asWomenNoChildren_update_cell();
            om_asWomenNoChildren_insert();
        }
        else {
            // filter changed from true to false
            om_asWomenNoChildren_erase();
        }
    }
}
void Person::om_side_effects_om_asWomenWithChildren_filter(bool om_old, bool om_new)
{

    // Code Injection: group=10, injector=asWomenWithChildren
    // filter change in asWomenWithChildren
    if (om_active) {
        if (om_new) {
            // filter changed from false to true
            om_asWomenWithChildren_update_cell();
            om_asWomenWithChildren_insert();
        }
        else {
            // filter changed from true to false
            om_asWomenWithChildren_erase();
        }
    }
}
void Person::om_side_effects_om_duration(Time om_old, Time om_new)
{
}
void Person::om_side_effects_om_duration_FOR_educ_one_fate_X_EOL_HIGH(Time om_old, Time om_new)
{
}
void Person::om_side_effects_om_duration_FOR_educ_one_fate_X_EOL_LOW(Time om_old, Time om_new)
{
}
void Person::om_side_effects_om_duration_FOR_educ_one_fate_X_EOL_MEDIUM(Time om_old, Time om_new)
{
}
void Person::om_side_effects_om_duration_FOR_educ_one_level_X_EOL_HIGH(Time om_old, Time om_new)
{
}
void Person::om_side_effects_om_duration_FOR_educ_one_level_X_EOL_LOW(Time om_old, Time om_new)
{
}
void Person::om_side_effects_om_duration_FOR_educ_one_level_X_EOL_MEDIUM(Time om_old, Time om_new)
{
}
void Person::om_side_effects_om_duration_FOR_educ_two_level_X_ETL_GRADUATE(Time om_old, Time om_new)
{
}
void Person::om_side_effects_om_duration_FOR_educ_two_level_X_ETL_INCOMPLETE(Time om_old, Time om_new)
{
}
void Person::om_side_effects_om_duration_FOR_educ_two_level_X_ETL_NEVER(Time om_old, Time om_new)
{
}
void Person::om_side_effects_om_duration_FOR_ever_union_X_true(Time om_old, Time om_new)
{
}
void Person::om_side_effects_om_duration_FOR_got_prenat_care_X_GPC_YES(Time om_old, Time om_new)
{
}
void Person::om_side_effects_om_duration_FOR_has_spouse_X_true(Time om_old, Time om_new)
{
}
void Person::om_side_effects_om_duration_FOR_is_aded0_X_true(Time om_old, Time om_new)
{
}
void Person::om_side_effects_om_duration_FOR_is_aded1_X_true(Time om_old, Time om_new)
{
}
void Person::om_side_effects_om_duration_FOR_is_aded2_X_true(Time om_old, Time om_new)
{
}
void Person::om_side_effects_om_duration_FOR_is_child_X_true(Time om_old, Time om_new)
{
}
void Person::om_side_effects_om_duration_FOR_is_immunized_X_true(Time om_old, Time om_new)
{
}
void Person::om_side_effects_om_duration_FOR_is_old_X_true(Time om_old, Time om_new)
{
}
void Person::om_side_effects_om_duration_FOR_tab_out_of_primary_X_true(Time om_old, Time om_new)
{
}
void Person::om_side_effects_om_duration_FOR_years_preschool_X_0(Time om_old, Time om_new)
{
}
void Person::om_side_effects_om_duration_FOR_years_preschool_X_1(Time om_old, Time om_new)
{
}
void Person::om_side_effects_om_duration_FOR_years_preschool_X_2(Time om_old, Time om_new)
{
}
void Person::om_side_effects_om_entrances_FOR_educ_one_grade_attended_X_1(counter om_old, counter om_new)
{
}
void Person::om_side_effects_om_entrances_FOR_has_passed_primary_X_true(counter om_old, counter om_new)
{
}
void Person::om_side_effects_om_mlHHFatherChildren_count(counter om_old, counter om_new)
{

    // Code Injection: group=8, injector=lives_with_dependent_child
    // Maintain identity for 'lives_with_dependent_child'
    lives_with_dependent_child_update_identity();
}
void Person::om_side_effects_om_mlHHFatherChildren_sum_over_is_alive(integer om_old, integer om_new)
{

    // Code Injection: group=8, injector=children_in_household
    // Maintain identity for 'children_in_household'
    children_in_household_update_identity();
}
void Person::om_side_effects_om_mlHHMotherChildren_count(counter om_old, counter om_new)
{

    // Code Injection: group=8, injector=age_youngest_child
    // Maintain identity for 'age_youngest_child'
    age_youngest_child_update_identity();

    // Code Injection: group=8, injector=lives_with_dependent_child
    // Maintain identity for 'lives_with_dependent_child'
    lives_with_dependent_child_update_identity();
}
void Person::om_side_effects_om_mlHHMotherChildren_min_over_integer_age(AGE_RANGE om_old, AGE_RANGE om_new)
{

    // Code Injection: group=8, injector=age_youngest_child
    // Maintain identity for 'age_youngest_child'
    age_youngest_child_update_identity();
}
void Person::om_side_effects_om_mlHHMotherChildren_sum_over_is_alive(integer om_old, integer om_new)
{

    // Code Injection: group=8, injector=children_in_household
    // Maintain identity for 'children_in_household'
    children_in_household_update_identity();
}
void Person::om_side_effects_om_self_scheduling_split_FOR_age_X_AGE_MIG_PART(AGE_MIG_PART om_old, AGE_MIG_PART om_new)
{

    // Code Injection: group=8, injector=age_mig
    // Maintain identity for 'age_mig'
    age_mig_update_identity();
}
void Person::om_side_effects_om_self_scheduling_split_FOR_om_active_spell_duration_FOR_this_parity_spell_X_true_X_DUR_TIME_IN_PARITY(DUR_TIME_IN_PARITY om_old, DUR_TIME_IN_PARITY om_new)
{

    // Code Injection: group=8, injector=time_in_parity
    // Maintain identity for 'time_in_parity'
    time_in_parity_update_identity();
}
void Person::om_side_effects_om_split_FOR_age_last_birth_X_MOTH_AGEGR_PART(MOTH_AGEGR_PART om_old, MOTH_AGEGR_PART om_new)
{

    // Code Injection: group=8, injector=moth_agegr_part
    // Maintain identity for 'moth_agegr_part'
    moth_agegr_part_update_identity();
}
void Person::om_side_effects_om_split_FOR_age_youngest_child_X_CHILD_AGEGR_PART(CHILD_AGEGR_PART om_old, CHILD_AGEGR_PART om_new)
{

    // Code Injection: group=8, injector=child_agegr_part
    // Maintain identity for 'child_agegr_part'
    child_agegr_part_update_identity();
}
void Person::om_side_effects_om_split_FOR_integer_age_X_TAB_AGEC5(TAB_AGEC5 om_old, TAB_AGEC5 om_new)
{

    // Code Injection: group=10, injector=PopPyramidByEduc
    // Cell change in PopPyramidByEduc
    if (om_active && thePopPyramidByEduc) {
        // Check and start pending increment in entity table PopPyramidByEduc
        auto cell = om_PopPyramidByEduc_current_cell();
        auto & incr = om_PopPyramidByEduc_incr;
        incr.set_cell(cell);
        incr.start_pending();
    }
}
void Person::om_side_effects_om_transitions_FOR_integer_age_X_14_X_15(counter om_old, counter om_new)
{
}
void Person::om_side_effects_om_transitions_FOR_is_alive_X_false_X_true(counter om_old, counter om_new)
{
}
void Person::om_side_effects_om_transitions_FOR_is_alive_X_true_X_false(counter om_old, counter om_new)
{
}
void Person::om_side_effects_om_transitions_FOR_survived_early_years_X_false_X_true(counter om_old, counter om_new)
{
}
void Person::om_side_effects_om_trigger_changes_FOR_calendar_year(bool om_old, bool om_new)
{

    // Code Injection: group=8, injector=om_aia_13
    // Maintain identity for 'om_aia_13'
    om_aia_13_update_identity();

    // Code Injection: group=8, injector=om_aia_14
    // Maintain identity for 'om_aia_14'
    om_aia_14_update_identity();

    // Code Injection: group=8, injector=om_aia_21
    // Maintain identity for 'om_aia_21'
    om_aia_21_update_identity();

    // Code Injection: group=8, injector=om_aia_25
    // Maintain identity for 'om_aia_25'
    om_aia_25_update_identity();
}
void Person::om_side_effects_om_trigger_changes_FOR_geo(bool om_old, bool om_new)
{

    // Code Injection: group=8, injector=om_aia_35
    // Maintain identity for 'om_aia_35'
    om_aia_35_update_identity();
}
void Person::om_side_effects_om_trigger_entrances_FOR_is_ready_for_birthtables_X_true(bool om_old, bool om_new)
{

    // Code Injection: group=8, injector=om_aia_36
    // Maintain identity for 'om_aia_36'
    om_aia_36_update_identity();
}
void Person::om_side_effects_om_value_at_transitions_FOR_is_alive_X_true_X_adult_survival_X_false(real om_old, real om_new)
{
}
void Person::om_side_effects_om_value_at_transitions_FOR_is_alive_X_true_X_ind_hci_X_false(real om_old, real om_new)
{
}
void Person::om_side_effects_om_value_at_transitions_FOR_is_alive_X_true_X_is_stunted_X_false(integer om_old, integer om_new)
{
}
void Person::om_side_effects_om_value_at_transitions_FOR_is_alive_X_true_X_quality_of_schooling_X_false(real om_old, real om_new)
{
}
void Person::om_side_effects_om_value_at_transitions_FOR_is_alive_X_true_X_survived_early_years_X_false(integer om_old, integer om_new)
{
}
void Person::om_side_effects_om_value_at_transitions_FOR_is_alive_X_true_X_years_of_schooling_X_false(integer om_old, integer om_new)
{
}
void Person::om_side_effects_parity(PARITY_RANGE om_old, PARITY_RANGE om_new)
{

    // Code Injection: group=10, injector=om_FertilityDetailedEvent_om_event
    // Recalculate time to event FertilityDetailedEvent
    if (om_active) om_FertilityDetailedEvent_om_event.make_dirty();
}
void Person::om_side_effects_preschool_is_decided(bool om_old, bool om_new)
{

    // Code Injection: group=10, injector=om_SetPreschoolYearsEvent_om_event
    // Recalculate time to event SetPreschoolYearsEvent
    if (om_active) om_SetPreschoolYearsEvent_om_event.make_dirty();
}
void Person::om_side_effects_quality_adjusted_schooling(double om_old, double om_new)
{
}
void Person::om_side_effects_quality_of_schooling(double om_old, double om_new)
{
}
void Person::om_side_effects_ready_to_set_alive(bool om_old, bool om_new)
{

    // Code Injection: group=10, injector=om_SetAliveEvent_om_event
    // Recalculate time to event SetAliveEvent
    if (om_active) om_SetAliveEvent_om_event.make_dirty();
}
void Person::om_side_effects_region_birth(REGION_INT om_old, REGION_INT om_new)
{

    // Code Injection: group=5, injector=aggregate(region_birth, REGION_NAT)
    {
        // Maintain aggregate(region_birth, REGION_NAT)
        om_aggregate_FOR_region_birth_X_REGION_NAT.set(om_aggregation_REGION_INT_om_REGION_NAT.find(region_birth)->second);
    }
}
void Person::om_side_effects_region_int(REGION_INT om_old, REGION_INT om_new)
{

    // Code Injection: group=5, injector=aggregate(region_int, REGION_NAT)
    {
        // Maintain aggregate(region_int, REGION_NAT)
        om_aggregate_FOR_region_int_X_REGION_NAT.set(om_aggregation_REGION_INT_om_REGION_NAT.find(region_int)->second);
    }
}
void Person::om_side_effects_region_nat(REGION_NAT om_old, REGION_NAT om_new)
{

    // Code Injection: group=10, injector=TabChildVaccination
    // Cell change in TabChildVaccination
    if (om_active && theTabChildVaccination) {
        // Check and start pending increment in entity table TabChildVaccination
        auto cell = om_TabChildVaccination_current_cell();
        auto & incr = om_TabChildVaccination_incr;
        incr.set_cell(cell);
        incr.start_pending();
    }

    // Code Injection: group=10, injector=TabImmunizationChildren
    // Cell change in TabImmunizationChildren
    if (om_active && theTabImmunizationChildren) {
        // Check and start pending increment in entity table TabImmunizationChildren
        auto cell = om_TabImmunizationChildren_current_cell();
        auto & incr = om_TabImmunizationChildren_incr;
        incr.set_cell(cell);
        incr.start_pending();
    }

    // Code Injection: group=10, injector=TabPrenatCare
    // Cell change in TabPrenatCare
    if (om_active && theTabPrenatCare) {
        // Check and start pending increment in entity table TabPrenatCare
        auto cell = om_TabPrenatCare_current_cell();
        auto & incr = om_TabPrenatCare_incr;
        incr.set_cell(cell);
        incr.start_pending();
    }

    // Code Injection: group=10, injector=tabStuntingSexRegMotherYob
    // Cell change in tabStuntingSexRegMotherYob
    if (om_active && thetabStuntingSexRegMotherYob) {
        // Check and start pending increment in entity table tabStuntingSexRegMotherYob
        auto cell = om_tabStuntingSexRegMotherYob_current_cell();
        auto & incr = om_tabStuntingSexRegMotherYob_incr;
        incr.set_cell(cell);
        incr.start_pending();
    }

    // Code Injection: group=10, injector=tabStuntingSexRegYob
    // Cell change in tabStuntingSexRegYob
    if (om_active && thetabStuntingSexRegYob) {
        // Check and start pending increment in entity table tabStuntingSexRegYob
        auto cell = om_tabStuntingSexRegYob_current_cell();
        auto & incr = om_tabStuntingSexRegYob_incr;
        incr.set_cell(cell);
        incr.start_pending();
    }
}
void Person::om_side_effects_sel_years(TAB_SEL_YEARS om_old, TAB_SEL_YEARS om_new)
{

    // Code Injection: group=10, injector=PopPyramidByEduc
    // Cell change in PopPyramidByEduc
    if (om_active && thePopPyramidByEduc) {
        // Check and start pending increment in entity table PopPyramidByEduc
        auto cell = om_PopPyramidByEduc_current_cell();
        auto & incr = om_PopPyramidByEduc_incr;
        incr.set_cell(cell);
        incr.start_pending();
    }
}
void Person::om_side_effects_selected_year10(SELECTED_YEAR10 om_old, SELECTED_YEAR10 om_new)
{

    // Code Injection: group=8, injector=in_selected_year
    // Maintain identity for 'in_selected_year'
    in_selected_year_update_identity();

    // Code Injection: group=10, injector=tabMigrationOriginDestination
    // Cell change in tabMigrationOriginDestination
    if (om_active && thetabMigrationOriginDestination) {
        // Check and start pending increment in entity table tabMigrationOriginDestination
        auto cell = om_tabMigrationOriginDestination_current_cell();
        auto & incr = om_tabMigrationOriginDestination_incr;
        incr.set_cell(cell);
        incr.start_pending();
    }
}
void Person::om_side_effects_sex(SEX om_old, SEX om_new)
{

    // Code Injection: group=8, injector=age_youngest_child
    // Maintain identity for 'age_youngest_child'
    age_youngest_child_update_identity();

    // Code Injection: group=8, injector=child_mortality
    // Maintain identity for 'child_mortality'
    child_mortality_update_identity();

    // Code Injection: group=8, injector=children_in_household
    // Maintain identity for 'children_in_household'
    children_in_household_update_identity();

    // Code Injection: group=8, injector=family_role
    // Maintain identity for 'family_role'
    family_role_update_identity();

    // Code Injection: group=8, injector=female_spouse_age
    // Maintain identity for 'female_spouse_age'
    female_spouse_age_update_identity();

    // Code Injection: group=8, injector=is_fertile
    // Maintain identity for 'is_fertile'
    is_fertile_update_identity();

    // Code Injection: group=8, injector=lives_with_dependent_child
    // Maintain identity for 'lives_with_dependent_child'
    lives_with_dependent_child_update_identity();

    // Code Injection: group=8, injector=male_age
    // Maintain identity for 'male_age'
    male_age_update_identity();

    // Code Injection: group=8, injector=male_spouse_age
    // Maintain identity for 'male_spouse_age'
    male_spouse_age_update_identity();

    // Code Injection: group=8, injector=om_asAvailableMaleByTypeImmiScratch_filter
    // Maintain identity for 'om_asAvailableMaleByTypeImmiScratch_filter'
    om_asAvailableMaleByTypeImmiScratch_filter_update_identity();

    // Code Injection: group=8, injector=om_asAvailableMaleByType_filter
    // Maintain identity for 'om_asAvailableMaleByType_filter'
    om_asAvailableMaleByType_filter_update_identity();

    // Code Injection: group=8, injector=om_asAvailableMaleImmiScratch_filter
    // Maintain identity for 'om_asAvailableMaleImmiScratch_filter'
    om_asAvailableMaleImmiScratch_filter_update_identity();

    // Code Injection: group=8, injector=om_asAvailableMale_filter
    // Maintain identity for 'om_asAvailableMale_filter'
    om_asAvailableMale_filter_update_identity();

    // Code Injection: group=8, injector=om_asFemaleInUnionByAgeAndPartnerAgeImmiScratch_filter
    // Maintain identity for 'om_asFemaleInUnionByAgeAndPartnerAgeImmiScratch_filter'
    om_asFemaleInUnionByAgeAndPartnerAgeImmiScratch_filter_update_identity();

    // Code Injection: group=8, injector=om_asFemaleInUnionByAgeAndPartnerAge_filter
    // Maintain identity for 'om_asFemaleInUnionByAgeAndPartnerAge_filter'
    om_asFemaleInUnionByAgeAndPartnerAge_filter_update_identity();

    // Code Injection: group=8, injector=om_asPotentialImmigrantMothers_filter
    // Maintain identity for 'om_asPotentialImmigrantMothers_filter'
    om_asPotentialImmigrantMothers_filter_update_identity();

    // Code Injection: group=8, injector=om_asWomenNoChildren_filter
    // Maintain identity for 'om_asWomenNoChildren_filter'
    om_asWomenNoChildren_filter_update_identity();

    // Code Injection: group=8, injector=om_asWomenWithChildren_filter
    // Maintain identity for 'om_asWomenWithChildren_filter'
    om_asWomenWithChildren_filter_update_identity();

    // Code Injection: group=10, injector=om_EmigrationEvent_om_event
    // Recalculate time to event EmigrationEvent
    if (om_active) om_EmigrationEvent_om_event.make_dirty();

    // Code Injection: group=10, injector=om_FirstUnionFormationEvent_om_event
    // Recalculate time to event FirstUnionFormationEvent
    if (om_active) om_FirstUnionFormationEvent_om_event.make_dirty();

    // Code Injection: group=10, injector=om_MigrationEvent_om_event
    // Recalculate time to event MigrationEvent
    if (om_active) om_MigrationEvent_om_event.make_dirty();

    // Code Injection: group=10, injector=om_MortalityBaseEvent_om_event
    // Recalculate time to event MortalityBaseEvent
    if (om_active) om_MortalityBaseEvent_om_event.make_dirty();

    // Code Injection: group=10, injector=om_MortalityDetailedEvent_om_event
    // Recalculate time to event MortalityDetailedEvent
    if (om_active) om_MortalityDetailedEvent_om_event.make_dirty();

    // Code Injection: group=10, injector=PopPyramidByEduc
    // Cell change in PopPyramidByEduc
    if (om_active && thePopPyramidByEduc) {
        // Check and start pending increment in entity table PopPyramidByEduc
        auto cell = om_PopPyramidByEduc_current_cell();
        auto & incr = om_PopPyramidByEduc_incr;
        incr.set_cell(cell);
        incr.start_pending();
    }

    // Code Injection: group=10, injector=TabEduc15ByDistrict
    // Cell change in TabEduc15ByDistrict
    if (om_active && theTabEduc15ByDistrict) {
        // Check and start pending increment in entity table TabEduc15ByDistrict
        auto cell = om_TabEduc15ByDistrict_current_cell();
        auto & incr = om_TabEduc15ByDistrict_incr;
        incr.set_cell(cell);
        incr.start_pending();
    }

    // Code Injection: group=10, injector=TabEduc15ByDistrictBirth
    // Cell change in TabEduc15ByDistrictBirth
    if (om_active && theTabEduc15ByDistrictBirth) {
        // Check and start pending increment in entity table TabEduc15ByDistrictBirth
        auto cell = om_TabEduc15ByDistrictBirth_current_cell();
        auto & incr = om_TabEduc15ByDistrictBirth_incr;
        incr.set_cell(cell);
        incr.start_pending();
    }

    // Code Injection: group=10, injector=TabHCIDistrict
    // Cell change in TabHCIDistrict
    if (om_active && theTabHCIDistrict) {
        // Check and start pending increment in entity table TabHCIDistrict
        auto cell = om_TabHCIDistrict_current_cell();
        auto & incr = om_TabHCIDistrict_incr;
        incr.set_cell(cell);
        incr.start_pending();
    }

    // Code Injection: group=10, injector=TabImmunizationChildren
    // Cell change in TabImmunizationChildren
    if (om_active && theTabImmunizationChildren) {
        // Check and start pending increment in entity table TabImmunizationChildren
        auto cell = om_TabImmunizationChildren_current_cell();
        auto & incr = om_TabImmunizationChildren_incr;
        incr.set_cell(cell);
        incr.start_pending();
    }

    // Code Injection: group=10, injector=TabPopProvAgeEducSex
    // Cell change in TabPopProvAgeEducSex
    if (om_active && theTabPopProvAgeEducSex) {
        // Check and start pending increment in entity table TabPopProvAgeEducSex
        auto cell = om_TabPopProvAgeEducSex_current_cell();
        auto & incr = om_TabPopProvAgeEducSex_incr;
        incr.set_cell(cell);
        incr.start_pending();
    }

    // Code Injection: group=10, injector=TabSchool2AttainmentsTab
    // Cell change in TabSchool2AttainmentsTab
    if (om_active && theTabSchool2AttainmentsTab) {
        // Check and start pending increment in entity table TabSchool2AttainmentsTab
        auto cell = om_TabSchool2AttainmentsTab_current_cell();
        auto & incr = om_TabSchool2AttainmentsTab_incr;
        incr.set_cell(cell);
        incr.start_pending();
    }

    // Code Injection: group=10, injector=asResidentsAge0Sex
    // cell change in asResidentsAge0Sex
    if (om_active) {
        if (om_asResidentsAge0Sex_filter) {
            om_asResidentsAge0Sex_erase();
            om_asResidentsAge0Sex_update_cell();
            om_asResidentsAge0Sex_insert();
        }
    }

    // Code Injection: group=10, injector=asResidentsAge0SexGeo
    // cell change in asResidentsAge0SexGeo
    if (om_active) {
        if (om_asResidentsAge0SexGeo_filter) {
            om_asResidentsAge0SexGeo_erase();
            om_asResidentsAge0SexGeo_update_cell();
            om_asResidentsAge0SexGeo_insert();
        }
    }

    // Code Injection: group=10, injector=asSimBornAge0
    // cell change in asSimBornAge0
    if (om_active) {
        if (om_asSimBornAge0_filter) {
            om_asSimBornAge0_erase();
            om_asSimBornAge0_update_cell();
            om_asSimBornAge0_insert();
        }
    }

    // Code Injection: group=10, injector=asWantToMove
    // cell change in asWantToMove
    if (om_active) {
        if (om_asWantToMove_filter) {
            om_asWantToMove_erase();
            om_asWantToMove_update_cell();
            om_asWantToMove_insert();
        }
    }

    // Code Injection: group=10, injector=tabEducationFateGeobirYob
    // Cell change in tabEducationFateGeobirYob
    if (om_active && thetabEducationFateGeobirYob) {
        // Check and start pending increment in entity table tabEducationFateGeobirYob
        auto cell = om_tabEducationFateGeobirYob_current_cell();
        auto & incr = om_tabEducationFateGeobirYob_incr;
        incr.set_cell(cell);
        incr.start_pending();
    }

    // Code Injection: group=10, injector=tabHCI
    // Cell change in tabHCI
    if (om_active && thetabHCI) {
        // Check and start pending increment in entity table tabHCI
        auto cell = om_tabHCI_current_cell();
        auto & incr = om_tabHCI_incr;
        incr.set_cell(cell);
        incr.start_pending();
    }

    // Code Injection: group=10, injector=tabHavingSpouse
    // Cell change in tabHavingSpouse
    if (om_active && thetabHavingSpouse) {
        // Check and start pending increment in entity table tabHavingSpouse
        auto cell = om_tabHavingSpouse_current_cell();
        auto & incr = om_tabHavingSpouse_incr;
        incr.set_cell(cell);
        incr.start_pending();
    }

    // Code Injection: group=10, injector=tabStuntingSexRegMotherYob
    // Cell change in tabStuntingSexRegMotherYob
    if (om_active && thetabStuntingSexRegMotherYob) {
        // Check and start pending increment in entity table tabStuntingSexRegMotherYob
        auto cell = om_tabStuntingSexRegMotherYob_current_cell();
        auto & incr = om_tabStuntingSexRegMotherYob_incr;
        incr.set_cell(cell);
        incr.start_pending();
    }
}
void Person::om_side_effects_sim_year(SIM_YEAR_RANGE om_old, SIM_YEAR_RANGE om_new)
{

    // Code Injection: group=10, injector=TabChildVaccination
    // Cell change in TabChildVaccination
    if (om_active && theTabChildVaccination) {
        // Check and start pending increment in entity table TabChildVaccination
        auto cell = om_TabChildVaccination_current_cell();
        auto & incr = om_TabChildVaccination_incr;
        incr.set_cell(cell);
        incr.start_pending();
    }

    // Code Injection: group=10, injector=TabEduc15ByDistrict
    // Cell change in TabEduc15ByDistrict
    if (om_active && theTabEduc15ByDistrict) {
        // Check and start pending increment in entity table TabEduc15ByDistrict
        auto cell = om_TabEduc15ByDistrict_current_cell();
        auto & incr = om_TabEduc15ByDistrict_incr;
        incr.set_cell(cell);
        incr.start_pending();
    }

    // Code Injection: group=10, injector=TabEduc15ByDistrictBirth
    // Cell change in TabEduc15ByDistrictBirth
    if (om_active && theTabEduc15ByDistrictBirth) {
        // Check and start pending increment in entity table TabEduc15ByDistrictBirth
        auto cell = om_TabEduc15ByDistrictBirth_current_cell();
        auto & incr = om_TabEduc15ByDistrictBirth_incr;
        incr.set_cell(cell);
        incr.start_pending();
    }

    // Code Injection: group=10, injector=TabImmunizationChildren
    // Cell change in TabImmunizationChildren
    if (om_active && theTabImmunizationChildren) {
        // Check and start pending increment in entity table TabImmunizationChildren
        auto cell = om_TabImmunizationChildren_current_cell();
        auto & incr = om_TabImmunizationChildren_incr;
        incr.set_cell(cell);
        incr.start_pending();
    }

    // Code Injection: group=10, injector=TabPopProvAgeEducSex
    // Cell change in TabPopProvAgeEducSex
    if (om_active && theTabPopProvAgeEducSex) {
        // Check and start pending increment in entity table TabPopProvAgeEducSex
        auto cell = om_TabPopProvAgeEducSex_current_cell();
        auto & incr = om_TabPopProvAgeEducSex_incr;
        incr.set_cell(cell);
        incr.start_pending();
    }

    // Code Injection: group=10, injector=TabPrenatCare
    // Cell change in TabPrenatCare
    if (om_active && theTabPrenatCare) {
        // Check and start pending increment in entity table TabPrenatCare
        auto cell = om_TabPrenatCare_current_cell();
        auto & incr = om_TabPrenatCare_incr;
        incr.set_cell(cell);
        incr.start_pending();
    }

    // Code Injection: group=10, injector=TabPrimSchoolEntries
    // Cell change in TabPrimSchoolEntries
    if (om_active && theTabPrimSchoolEntries) {
        // Check and start pending increment in entity table TabPrimSchoolEntries
        auto cell = om_TabPrimSchoolEntries_current_cell();
        auto & incr = om_TabPrimSchoolEntries_incr;
        incr.set_cell(cell);
        incr.start_pending();
    }

    // Code Injection: group=10, injector=TabPrimSchoolGraduations
    // Cell change in TabPrimSchoolGraduations
    if (om_active && theTabPrimSchoolGraduations) {
        // Check and start pending increment in entity table TabPrimSchoolGraduations
        auto cell = om_TabPrimSchoolGraduations_current_cell();
        auto & incr = om_TabPrimSchoolGraduations_incr;
        incr.set_cell(cell);
        incr.start_pending();
    }

    // Code Injection: group=10, injector=TabPrimSchoolOutOfSchool9to11
    // Cell change in TabPrimSchoolOutOfSchool9to11
    if (om_active && theTabPrimSchoolOutOfSchool9to11) {
        // Check and start pending increment in entity table TabPrimSchoolOutOfSchool9to11
        auto cell = om_TabPrimSchoolOutOfSchool9to11_current_cell();
        auto & incr = om_TabPrimSchoolOutOfSchool9to11_incr;
        incr.set_cell(cell);
        incr.start_pending();
    }

    // Code Injection: group=10, injector=TabPrimarySchoolPlanning
    // Cell change in TabPrimarySchoolPlanning
    if (om_active && theTabPrimarySchoolPlanning) {
        // Check and start pending increment in entity table TabPrimarySchoolPlanning
        auto cell = om_TabPrimarySchoolPlanning_current_cell();
        auto & incr = om_TabPrimarySchoolPlanning_incr;
        incr.set_cell(cell);
        incr.start_pending();
    }

    // Code Injection: group=10, injector=TabSchool2AttainmentsTab
    // Cell change in TabSchool2AttainmentsTab
    if (om_active && theTabSchool2AttainmentsTab) {
        // Check and start pending increment in entity table TabSchool2AttainmentsTab
        auto cell = om_TabSchool2AttainmentsTab_current_cell();
        auto & incr = om_TabSchool2AttainmentsTab_incr;
        incr.set_cell(cell);
        incr.start_pending();
    }

    // Code Injection: group=10, injector=TabSchool2TrackTab
    // Cell change in TabSchool2TrackTab
    if (om_active && theTabSchool2TrackTab) {
        // Check and start pending increment in entity table TabSchool2TrackTab
        auto cell = om_TabSchool2TrackTab_current_cell();
        auto & incr = om_TabSchool2TrackTab_incr;
        incr.set_cell(cell);
        incr.start_pending();
    }

    // Code Injection: group=10, injector=tabBirthsYearPlace
    // Cell change in tabBirthsYearPlace
    if (om_active && thetabBirthsYearPlace) {
        // Check and start pending increment in entity table tabBirthsYearPlace
        auto cell = om_tabBirthsYearPlace_current_cell();
        auto & incr = om_tabBirthsYearPlace_incr;
        incr.set_cell(cell);
        incr.start_pending();
    }

    // Code Injection: group=10, injector=tabHavingSpouse
    // Cell change in tabHavingSpouse
    if (om_active && thetabHavingSpouse) {
        // Check and start pending increment in entity table tabHavingSpouse
        auto cell = om_tabHavingSpouse_current_cell();
        auto & incr = om_tabHavingSpouse_incr;
        incr.set_cell(cell);
        incr.start_pending();
    }

    // Code Injection: group=10, injector=tabPopulationYearPlace
    // Cell change in tabPopulationYearPlace
    if (om_active && thetabPopulationYearPlace) {
        // Check and start pending increment in entity table tabPopulationYearPlace
        auto cell = om_tabPopulationYearPlace_current_cell();
        auto & incr = om_tabPopulationYearPlace_incr;
        incr.set_cell(cell);
        incr.start_pending();
    }

    // Code Injection: group=10, injector=tabStuntingSexRegMotherYob
    // Cell change in tabStuntingSexRegMotherYob
    if (om_active && thetabStuntingSexRegMotherYob) {
        // Check and start pending increment in entity table tabStuntingSexRegMotherYob
        auto cell = om_tabStuntingSexRegMotherYob_current_cell();
        auto & incr = om_tabStuntingSexRegMotherYob_incr;
        incr.set_cell(cell);
        incr.start_pending();
    }

    // Code Injection: group=10, injector=tabStuntingSexRegYob
    // Cell change in tabStuntingSexRegYob
    if (om_active && thetabStuntingSexRegYob) {
        // Check and start pending increment in entity table tabStuntingSexRegYob
        auto cell = om_tabStuntingSexRegYob_current_cell();
        auto & incr = om_tabStuntingSexRegYob_incr;
        incr.set_cell(cell);
        incr.start_pending();
    }
}
void Person::om_side_effects_spouse_group(SPOUSE_GROUP om_old, SPOUSE_GROUP om_new)
{

    // Code Injection: group=10, injector=asAvailableMaleByType
    // cell change in asAvailableMaleByType
    if (om_active) {
        if (om_asAvailableMaleByType_filter) {
            om_asAvailableMaleByType_erase();
            om_asAvailableMaleByType_update_cell();
            om_asAvailableMaleByType_insert();
        }
    }

    // Code Injection: group=10, injector=asAvailableMaleByTypeImmiScratch
    // cell change in asAvailableMaleByTypeImmiScratch
    if (om_active) {
        if (om_asAvailableMaleByTypeImmiScratch_filter) {
            om_asAvailableMaleByTypeImmiScratch_erase();
            om_asAvailableMaleByTypeImmiScratch_update_cell();
            om_asAvailableMaleByTypeImmiScratch_insert();
        }
    }
}
void Person::om_side_effects_survived_early_years(bool om_old, bool om_new)
{

    // Code Injection: group=5, injector=transitions(survived_early_years, false, true)
    {
        // Maintain transitions(survived_early_years, false, true)
        if (om_old == false && om_new == true) {
            om_transitions_FOR_survived_early_years_X_false_X_true.set(om_transitions_FOR_survived_early_years_X_false_X_true.get() + 1);
        }
    }
}
void Person::om_side_effects_tab_out_of_primary(bool om_old, bool om_new)
{

    // Code Injection: group=8, injector=om_aia_24
    // Maintain identity for 'om_aia_24'
    om_aia_24_update_identity();
}
void Person::om_side_effects_tab_sim_yob(SIM_YEAR_RANGE om_old, SIM_YEAR_RANGE om_new)
{

    // Code Injection: group=10, injector=TabEducFateByGroup
    // Cell change in TabEducFateByGroup
    if (om_active && theTabEducFateByGroup) {
        // Check and start pending increment in entity table TabEducFateByGroup
        auto cell = om_TabEducFateByGroup_current_cell();
        auto & incr = om_TabEducFateByGroup_incr;
        incr.set_cell(cell);
        incr.start_pending();
    }

    // Code Injection: group=10, injector=TabHCIDistrict
    // Cell change in TabHCIDistrict
    if (om_active && theTabHCIDistrict) {
        // Check and start pending increment in entity table TabHCIDistrict
        auto cell = om_TabHCIDistrict_current_cell();
        auto & incr = om_TabHCIDistrict_incr;
        incr.set_cell(cell);
        incr.start_pending();
    }

    // Code Injection: group=10, injector=tabHCI
    // Cell change in tabHCI
    if (om_active && thetabHCI) {
        // Check and start pending increment in entity table tabHCI
        auto cell = om_tabHCI_current_cell();
        auto & incr = om_tabHCI_incr;
        incr.set_cell(cell);
        incr.start_pending();
    }

    // Code Injection: group=10, injector=tabPreSchool
    // Cell change in tabPreSchool
    if (om_active && thetabPreSchool) {
        // Check and start pending increment in entity table tabPreSchool
        auto cell = om_tabPreSchool_current_cell();
        auto & incr = om_tabPreSchool_incr;
        incr.set_cell(cell);
        incr.start_pending();
    }
}
void Person::om_side_effects_this_parity_spell(bool om_old, bool om_new)
{

    // Code Injection: group=8, injector=om_aia_0
    // Maintain identity for 'om_aia_0'
    om_aia_0_update_identity();
}
void Person::om_side_effects_time(Time om_old, Time om_new)
{
    // Amount of time increment
    Time om_delta = om_new - om_old;

    // Code Injection: group=2, injector=age
    if (om_active) {
        // Advance time for the attribute 'age'
        age.set(age.get() + om_delta);
    }

    // Code Injection: group=2, injector=duration()
    if (om_active) {
        // Advance time for duration()
        om_duration.set(om_duration.get() + om_delta);
    }

    // Code Injection: group=2, injector=duration(educ_one_fate, EOL_HIGH)
    if (om_active) {
        if (om_aia_8) {
            // Advance time for duration(educ_one_fate, EOL_HIGH)
            om_duration_FOR_educ_one_fate_X_EOL_HIGH.set(om_duration_FOR_educ_one_fate_X_EOL_HIGH.get() + om_delta);
        }
    }

    // Code Injection: group=2, injector=duration(educ_one_fate, EOL_LOW)
    if (om_active) {
        if (om_aia_6) {
            // Advance time for duration(educ_one_fate, EOL_LOW)
            om_duration_FOR_educ_one_fate_X_EOL_LOW.set(om_duration_FOR_educ_one_fate_X_EOL_LOW.get() + om_delta);
        }
    }

    // Code Injection: group=2, injector=duration(educ_one_fate, EOL_MEDIUM)
    if (om_active) {
        if (om_aia_7) {
            // Advance time for duration(educ_one_fate, EOL_MEDIUM)
            om_duration_FOR_educ_one_fate_X_EOL_MEDIUM.set(om_duration_FOR_educ_one_fate_X_EOL_MEDIUM.get() + om_delta);
        }
    }

    // Code Injection: group=2, injector=duration(educ_one_level, EOL_HIGH)
    if (om_active) {
        if (om_aia_12) {
            // Advance time for duration(educ_one_level, EOL_HIGH)
            om_duration_FOR_educ_one_level_X_EOL_HIGH.set(om_duration_FOR_educ_one_level_X_EOL_HIGH.get() + om_delta);
        }
    }

    // Code Injection: group=2, injector=duration(educ_one_level, EOL_LOW)
    if (om_active) {
        if (om_aia_10) {
            // Advance time for duration(educ_one_level, EOL_LOW)
            om_duration_FOR_educ_one_level_X_EOL_LOW.set(om_duration_FOR_educ_one_level_X_EOL_LOW.get() + om_delta);
        }
    }

    // Code Injection: group=2, injector=duration(educ_one_level, EOL_MEDIUM)
    if (om_active) {
        if (om_aia_11) {
            // Advance time for duration(educ_one_level, EOL_MEDIUM)
            om_duration_FOR_educ_one_level_X_EOL_MEDIUM.set(om_duration_FOR_educ_one_level_X_EOL_MEDIUM.get() + om_delta);
        }
    }

    // Code Injection: group=2, injector=duration(educ_two_level, ETL_GRADUATE)
    if (om_active) {
        if (om_aia_29) {
            // Advance time for duration(educ_two_level, ETL_GRADUATE)
            om_duration_FOR_educ_two_level_X_ETL_GRADUATE.set(om_duration_FOR_educ_two_level_X_ETL_GRADUATE.get() + om_delta);
        }
    }

    // Code Injection: group=2, injector=duration(educ_two_level, ETL_INCOMPLETE)
    if (om_active) {
        if (om_aia_28) {
            // Advance time for duration(educ_two_level, ETL_INCOMPLETE)
            om_duration_FOR_educ_two_level_X_ETL_INCOMPLETE.set(om_duration_FOR_educ_two_level_X_ETL_INCOMPLETE.get() + om_delta);
        }
    }

    // Code Injection: group=2, injector=duration(educ_two_level, ETL_NEVER)
    if (om_active) {
        if (om_aia_27) {
            // Advance time for duration(educ_two_level, ETL_NEVER)
            om_duration_FOR_educ_two_level_X_ETL_NEVER.set(om_duration_FOR_educ_two_level_X_ETL_NEVER.get() + om_delta);
        }
    }

    // Code Injection: group=2, injector=duration(ever_union, true)
    if (om_active) {
        if (om_aia_32) {
            // Advance time for duration(ever_union, true)
            om_duration_FOR_ever_union_X_true.set(om_duration_FOR_ever_union_X_true.get() + om_delta);
        }
    }

    // Code Injection: group=2, injector=duration(got_prenat_care, GPC_YES)
    if (om_active) {
        if (om_aia_38) {
            // Advance time for duration(got_prenat_care, GPC_YES)
            om_duration_FOR_got_prenat_care_X_GPC_YES.set(om_duration_FOR_got_prenat_care_X_GPC_YES.get() + om_delta);
        }
    }

    // Code Injection: group=2, injector=duration(has_spouse, true)
    if (om_active) {
        if (om_aia_31) {
            // Advance time for duration(has_spouse, true)
            om_duration_FOR_has_spouse_X_true.set(om_duration_FOR_has_spouse_X_true.get() + om_delta);
        }
    }

    // Code Injection: group=2, injector=duration(is_aded0, true)
    if (om_active) {
        if (om_aia_17) {
            // Advance time for duration(is_aded0, true)
            om_duration_FOR_is_aded0_X_true.set(om_duration_FOR_is_aded0_X_true.get() + om_delta);
        }
    }

    // Code Injection: group=2, injector=duration(is_aded1, true)
    if (om_active) {
        if (om_aia_18) {
            // Advance time for duration(is_aded1, true)
            om_duration_FOR_is_aded1_X_true.set(om_duration_FOR_is_aded1_X_true.get() + om_delta);
        }
    }

    // Code Injection: group=2, injector=duration(is_aded2, true)
    if (om_active) {
        if (om_aia_19) {
            // Advance time for duration(is_aded2, true)
            om_duration_FOR_is_aded2_X_true.set(om_duration_FOR_is_aded2_X_true.get() + om_delta);
        }
    }

    // Code Injection: group=2, injector=duration(is_child, true)
    if (om_active) {
        if (om_aia_16) {
            // Advance time for duration(is_child, true)
            om_duration_FOR_is_child_X_true.set(om_duration_FOR_is_child_X_true.get() + om_delta);
        }
    }

    // Code Injection: group=2, injector=duration(is_immunized, true)
    if (om_active) {
        if (om_aia_39) {
            // Advance time for duration(is_immunized, true)
            om_duration_FOR_is_immunized_X_true.set(om_duration_FOR_is_immunized_X_true.get() + om_delta);
        }
    }

    // Code Injection: group=2, injector=duration(is_old, true)
    if (om_active) {
        if (om_aia_20) {
            // Advance time for duration(is_old, true)
            om_duration_FOR_is_old_X_true.set(om_duration_FOR_is_old_X_true.get() + om_delta);
        }
    }

    // Code Injection: group=2, injector=duration(tab_out_of_primary, true)
    if (om_active) {
        if (om_aia_24) {
            // Advance time for duration(tab_out_of_primary, true)
            om_duration_FOR_tab_out_of_primary_X_true.set(om_duration_FOR_tab_out_of_primary_X_true.get() + om_delta);
        }
    }

    // Code Injection: group=2, injector=duration(years_preschool, 0)
    if (om_active) {
        if (om_aia_2) {
            // Advance time for duration(years_preschool, 0)
            om_duration_FOR_years_preschool_X_0.set(om_duration_FOR_years_preschool_X_0.get() + om_delta);
        }
    }

    // Code Injection: group=2, injector=duration(years_preschool, 1)
    if (om_active) {
        if (om_aia_3) {
            // Advance time for duration(years_preschool, 1)
            om_duration_FOR_years_preschool_X_1.set(om_duration_FOR_years_preschool_X_1.get() + om_delta);
        }
    }

    // Code Injection: group=2, injector=duration(years_preschool, 2)
    if (om_active) {
        if (om_aia_4) {
            // Advance time for duration(years_preschool, 2)
            om_duration_FOR_years_preschool_X_2.set(om_duration_FOR_years_preschool_X_2.get() + om_delta);
        }
    }

    // Code Injection: group=4, injector=active_spell_duration(this_parity_spell, true)
    if (om_active) {
        if (om_aia_0) {
            // Advance time for active_spell_duration(this_parity_spell, true)
            om_active_spell_duration_FOR_this_parity_spell_X_true.set(om_active_spell_duration_FOR_this_parity_spell_X_true.get() + om_delta);
        }
    }

    // Code Injection: group=5, injector=self_scheduling_split(age, AGE_MIG_PART)
    if (!om_active) {
        // Initial values are being assigned.
        auto & ss_attr = om_self_scheduling_split_FOR_age_X_AGE_MIG_PART;
        auto & ss_time = om_ss_time_om_self_scheduling_split_FOR_age_X_AGE_MIG_PART;
        auto part = ss_attr.get(); // working copy of partition
        // Initial value is the corresponding partition interval.
        part.set_from_value(age.get());
        ss_attr.set(part);
        // Time to wait for next change is the remaining time to get to upper bound of current interval in partition.
        if (part.upper() == REAL_MAX) ss_time = time_infinite;
        else ss_time = time + (part.upper() - age.get());
    }
}
void Person::om_side_effects_time_first_move(Time om_old, Time om_new)
{
}
void Person::om_side_effects_time_in_parity(int om_old, int om_new)
{

    // Code Injection: group=10, injector=om_FertilityDetailedEvent_om_event
    // Recalculate time to event FertilityDetailedEvent
    if (om_active) om_FertilityDetailedEvent_om_event.make_dirty();
}
void Person::om_side_effects_time_last_move(Time om_old, Time om_new)
{

    // Code Injection: group=10, injector=om_MigrationEvent_om_event
    // Recalculate time to event MigrationEvent
    if (om_active) om_MigrationEvent_om_event.make_dirty();
}
void Person::om_side_effects_time_next_birthday(Time om_old, Time om_new)
{

    // Code Injection: group=10, injector=om_BirthdayEvent_om_event
    // Recalculate time to event BirthdayEvent
    if (om_active) om_BirthdayEvent_om_event.make_dirty();
}
void Person::om_side_effects_time_of_birth(Time om_old, Time om_new)
{

    // Code Injection: group=8, injector=year_of_birth
    // Maintain identity for 'year_of_birth'
    year_of_birth_update_identity();

    // Code Injection: group=10, injector=om_BirthdayEvent_om_event
    // Recalculate time to event BirthdayEvent
    if (om_active) om_BirthdayEvent_om_event.make_dirty();

    // Code Injection: group=10, injector=om_DeathAtMaxLifespanEvent_om_event
    // Recalculate time to event DeathAtMaxLifespanEvent
    if (om_active) om_DeathAtMaxLifespanEvent_om_event.make_dirty();

    // Code Injection: group=10, injector=om_LeavingHomeEvent_om_event
    // Recalculate time to event LeavingHomeEvent
    if (om_active) om_LeavingHomeEvent_om_event.make_dirty();
}
void Person::om_side_effects_time_of_first_immigration(Time om_old, Time om_new)
{

    // Code Injection: group=8, injector=year_of_first_immigration
    // Maintain identity for 'year_of_first_immigration'
    year_of_first_immigration_update_identity();

    // Code Injection: group=10, injector=om_FirstImmigrationFromPoolEvent_om_event
    // Recalculate time to event FirstImmigrationFromPoolEvent
    if (om_active) om_FirstImmigrationFromPoolEvent_om_event.make_dirty();

    // Code Injection: group=10, injector=om_FirstImmigrationFromScratchEvent_om_event
    // Recalculate time to event FirstImmigrationFromScratchEvent
    if (om_active) om_FirstImmigrationFromScratchEvent_om_event.make_dirty();
}
void Person::om_side_effects_union1_group(UNION1_GROUP om_old, UNION1_GROUP om_new)
{

    // Code Injection: group=10, injector=om_FirstUnionFormationEvent_om_event
    // Recalculate time to event FirstUnionFormationEvent
    if (om_active) om_FirstUnionFormationEvent_om_event.make_dirty();

    // Code Injection: group=10, injector=asWomenNoChildren
    // cell change in asWomenNoChildren
    if (om_active) {
        if (om_asWomenNoChildren_filter) {
            om_asWomenNoChildren_erase();
            om_asWomenNoChildren_update_cell();
            om_asWomenNoChildren_insert();
        }
    }

    // Code Injection: group=10, injector=asWomenWithChildren
    // cell change in asWomenWithChildren
    if (om_active) {
        if (om_asWomenWithChildren_filter) {
            om_asWomenWithChildren_erase();
            om_asWomenWithChildren_update_cell();
            om_asWomenWithChildren_insert();
        }
    }
}
void Person::om_side_effects_year_of_birth(ALL_YEAR_RANGE om_old, ALL_YEAR_RANGE om_new)
{

    // Code Injection: group=8, injector=om_aia_1
    // Maintain identity for 'om_aia_1'
    om_aia_1_update_identity();

    // Code Injection: group=8, injector=om_aia_33
    // Maintain identity for 'om_aia_33'
    om_aia_33_update_identity();

    // Code Injection: group=8, injector=tab_sim_yob
    // Maintain identity for 'tab_sim_yob'
    tab_sim_yob_update_identity();

    // Code Injection: group=10, injector=TabEducFateDistrYob
    // Cell change in TabEducFateDistrYob
    if (om_active && theTabEducFateDistrYob) {
        // Check and start pending increment in entity table TabEducFateDistrYob
        auto cell = om_TabEducFateDistrYob_current_cell();
        auto & incr = om_TabEducFateDistrYob_incr;
        incr.set_cell(cell);
        incr.start_pending();
    }

    // Code Injection: group=10, injector=tabEducationFateGeobirYob
    // Cell change in tabEducationFateGeobirYob
    if (om_active && thetabEducationFateGeobirYob) {
        // Check and start pending increment in entity table tabEducationFateGeobirYob
        auto cell = om_tabEducationFateGeobirYob_current_cell();
        auto & incr = om_tabEducationFateGeobirYob_incr;
        incr.set_cell(cell);
        incr.start_pending();
    }
}
void Person::om_side_effects_year_of_first_immigration(SIM_YEAR_RANGE om_old, SIM_YEAR_RANGE om_new)
{

    // Code Injection: group=10, injector=asAvailableMaleByTypeImmiScratch
    // cell change in asAvailableMaleByTypeImmiScratch
    if (om_active) {
        if (om_asAvailableMaleByTypeImmiScratch_filter) {
            om_asAvailableMaleByTypeImmiScratch_erase();
            om_asAvailableMaleByTypeImmiScratch_update_cell();
            om_asAvailableMaleByTypeImmiScratch_insert();
        }
    }

    // Code Injection: group=10, injector=asAvailableMaleImmiScratch
    // cell change in asAvailableMaleImmiScratch
    if (om_active) {
        if (om_asAvailableMaleImmiScratch_filter) {
            om_asAvailableMaleImmiScratch_erase();
            om_asAvailableMaleImmiScratch_update_cell();
            om_asAvailableMaleImmiScratch_insert();
        }
    }

    // Code Injection: group=10, injector=asFemaleInUnionByAgeAndPartnerAgeImmiScratch
    // cell change in asFemaleInUnionByAgeAndPartnerAgeImmiScratch
    if (om_active) {
        if (om_asFemaleInUnionByAgeAndPartnerAgeImmiScratch_filter) {
            om_asFemaleInUnionByAgeAndPartnerAgeImmiScratch_erase();
            om_asFemaleInUnionByAgeAndPartnerAgeImmiScratch_update_cell();
            om_asFemaleInUnionByAgeAndPartnerAgeImmiScratch_insert();
        }
    }

    // Code Injection: group=10, injector=asPotentialImmigrantMothers
    // cell change in asPotentialImmigrantMothers
    if (om_active) {
        if (om_asPotentialImmigrantMothers_filter) {
            om_asPotentialImmigrantMothers_erase();
            om_asPotentialImmigrantMothers_update_cell();
            om_asPotentialImmigrantMothers_insert();
        }
    }
}
void Person::om_side_effects_years_of_schooling(int om_old, int om_new)
{
}
void Person::om_side_effects_years_preschool(int om_old, int om_new)
{

    // Code Injection: group=8, injector=om_aia_2
    // Maintain identity for 'om_aia_2'
    om_aia_2_update_identity();

    // Code Injection: group=8, injector=om_aia_3
    // Maintain identity for 'om_aia_3'
    om_aia_3_update_identity();

    // Code Injection: group=8, injector=om_aia_4
    // Maintain identity for 'om_aia_4'
    om_aia_4_update_identity();

    // Code Injection: group=8, injector=years_of_schooling
    // Maintain identity for 'years_of_schooling'
    years_of_schooling_update_identity();
}
void Person::om_ss_event()
{
    // Working local variable
    Time current_time = time.get();

    // Update the value and next time of each self-scheduling derived attribute
    // whose time has come.

    // Code Injection: group=1, injector=trigger_changes(calendar_year)
    {
        // Maintain trigger_changes(calendar_year)
        auto & ss_attr = om_trigger_changes_FOR_calendar_year;
        auto & ss_time = om_ss_time_om_trigger_changes_FOR_calendar_year;
        if (current_time == ss_time) {
            ss_attr.set(false);
            ss_time = time_infinite;
        }
    }

    // Code Injection: group=1, injector=trigger_changes(geo)
    {
        // Maintain trigger_changes(geo)
        auto & ss_attr = om_trigger_changes_FOR_geo;
        auto & ss_time = om_ss_time_om_trigger_changes_FOR_geo;
        if (current_time == ss_time) {
            ss_attr.set(false);
            ss_time = time_infinite;
        }
    }

    // Code Injection: group=1, injector=trigger_entrances(is_ready_for_birthtables, true)
    {
        // Maintain trigger_entrances(is_ready_for_birthtables, true)
        auto & ss_attr = om_trigger_entrances_FOR_is_ready_for_birthtables_X_true;
        auto & ss_time = om_ss_time_om_trigger_entrances_FOR_is_ready_for_birthtables_X_true;
        if (current_time == ss_time) {
            ss_attr.set(false);
            ss_time = time_infinite;
        }
    }

    // Code Injection: group=5, injector=self_scheduling_split(age, AGE_MIG_PART)
    if (current_time == om_ss_time_om_self_scheduling_split_FOR_age_X_AGE_MIG_PART) {
        auto & ss_attr = om_self_scheduling_split_FOR_age_X_AGE_MIG_PART;
        auto & ss_time = om_ss_time_om_self_scheduling_split_FOR_age_X_AGE_MIG_PART;
        auto part = ss_attr.get(); // working copy of partition

        // Update the value
        part++; // Advance to the next interval in the partition.
        ss_attr.set(part);
        // Update the time of next change by the width of that new interval.
        if (part.upper() == REAL_MAX) ss_time = time_infinite;
        else ss_time += part.width();
    }

    // Code Injection: group=5, injector=self_scheduling_split(active_spell_duration(this_parity_spell, true), DUR_TIME_IN_PARITY)
    if (current_time == om_ss_time_om_self_scheduling_split_FOR_om_active_spell_duration_FOR_this_parity_spell_X_true_X_DUR_TIME_IN_PARITY) {
        auto & ss_attr = om_self_scheduling_split_FOR_om_active_spell_duration_FOR_this_parity_spell_X_true_X_DUR_TIME_IN_PARITY;
        auto & ss_time = om_ss_time_om_self_scheduling_split_FOR_om_active_spell_duration_FOR_this_parity_spell_X_true_X_DUR_TIME_IN_PARITY;
        auto part = ss_attr.get(); // working copy of partition

        // Set the partitioned duration to the next interval.
        part++;
        ss_attr.set(part);
        // The time to wait is the width of the current interval in the partition.
        if (part.upper() == REAL_MAX) ss_time = time_infinite;
        else ss_time = time + part.width();
    }
}
Time Person::om_ss_time()
{
    // Compute the minimum next time of all of the self-scheduling derived attributes.
    Time et = time_infinite;

    // Code Injection: group=1, injector=trigger_changes(calendar_year)
    {
        auto & ss_time = om_ss_time_om_trigger_changes_FOR_calendar_year;

        // Compare minimum time against scheduled time for trigger_changes(calendar_year)
        if (ss_time < et) et = ss_time;
    }

    // Code Injection: group=1, injector=trigger_changes(geo)
    {
        auto & ss_time = om_ss_time_om_trigger_changes_FOR_geo;

        // Compare minimum time against scheduled time for trigger_changes(geo)
        if (ss_time < et) et = ss_time;
    }

    // Code Injection: group=1, injector=trigger_entrances(is_ready_for_birthtables, true)
    {
        auto & ss_time = om_ss_time_om_trigger_entrances_FOR_is_ready_for_birthtables_X_true;

        // Compare minimum time against scheduled time for trigger_entrances(is_ready_for_birthtables, true)
        if (ss_time < et) et = ss_time;
    }

    // Code Injection: group=5, injector=self_scheduling_split(age, AGE_MIG_PART)
    {
        // Check scheduled time for self_scheduling_split(age, AGE_MIG_PART)
        auto & ss_time = om_ss_time_om_self_scheduling_split_FOR_age_X_AGE_MIG_PART;
        if (ss_time < et) et = ss_time;
    }

    // Code Injection: group=5, injector=self_scheduling_split(active_spell_duration(this_parity_spell, true), DUR_TIME_IN_PARITY)
    {
        // Check scheduled time for self_scheduling_split(active_spell_duration(this_parity_spell, true), DUR_TIME_IN_PARITY)
        auto & ss_time = om_ss_time_om_self_scheduling_split_FOR_om_active_spell_duration_FOR_this_parity_spell_X_true_X_DUR_TIME_IN_PARITY;
        if (ss_time < et) et = ss_time;
    }

    // Code Injection: group=0, injector=Person
    return et;
}
int Person::om_tabBirthsYearPlace_current_cell()
{
    assert(thetabBirthsYearPlace); // unitary table must be instantiated

    // Dimensionality of table (does not include measure dimension)
    const size_t rank = 2;

    // Size of each dimension of table (includes margin if present)
    const std::array<size_t, rank> shape = {14, 151};

    // Dimension coordinates of current cell
    const std::array<size_t, rank> coordinates = {
        size_t(geo), 
        size_t(sim_year - 2000), 
    };

    // Encode the dimension coordinates of the margin cell into flattened index
    size_t cell = coordinates[0];
    for (size_t j = 1; j < rank; ++j) {
        cell *= shape[j];
        cell += coordinates[j];
    }

    assert(cell >= 0 && cell < 2114); // logic guarantee
    return cell;
}
void Person::om_tabBirthsYearPlace_init_increment(int pending, big_counter pending_event_counter)
{
    assert(thetabBirthsYearPlace); // unitary table must be instantiated

    {
        // interval(om_transitions_FOR_is_alive_X_false_X_true)
        auto & value_in = om_tabBirthsYearPlace_in_om_transitions_FOR_is_alive_X_false_X_true;
        counter value_curr = om_transitions_FOR_is_alive_X_false_X_true;

        value_in = value_curr;
    }
}
void Person::om_tabBirthsYearPlace_push_increment(int cell_in, int pending, big_counter pending_event_counter)
{
    assert(thetabBirthsYearPlace); // unitary table must be instantiated

    auto& table = thetabBirthsYearPlace;

    // Table has margins

    // Dimensionality of table (does not include measure dimension)
    const size_t rank = 2;

    // Size of each dimension of table (includes margin if present)
    const std::array<size_t, rank> shape = {14, 151};

    // Number of dimensions with a margin
    const size_t margin_count = 1;

    // Dimensions with a margin
    const std::array<size_t, margin_count> margin_dims = {0};

    // Number of margin combinations for a cell in the table body
    // e.g. a table with 3 margins has 2^3-1=7 margin cells associated with a body cell
    const size_t margin_combos = (1 << margin_count) - 1;

    // Indexes of table cells to increment (cell in table body and cells in margins)
    std::array<size_t, 1 + margin_combos> cells_to_increment;

    // Populate cells_to_increment

    // The cell in the table body:
    cells_to_increment[0] = cell_in;

    // The margin cells
    {
        // Dimension coordinates of the body cell being incremented
        std::array<size_t, rank> body_coordinates;
        // Decode dimension coordinates of the body cell
        for (int j = rank - 1, w = cell_in; j >= 0; --j) {
            body_coordinates[j] = w % shape[j];
            w /= shape[j];
        }
        // Working coordinates of a margin cell
        std::array<size_t, rank> margin_coordinates;
        for (size_t combo = 1; combo <= margin_combos; ++combo) {
            // The binary bits of combo select the margin dimensions for the combination.
            margin_coordinates = body_coordinates;
            size_t bits = combo;
            for (size_t margin = 0; margin < margin_count; ++margin) {
                // read out the bits in combo
                if (bits & 1) {
                    // low order bit is 1, so replace coordinate from body cell by margin coordinate
                    margin_coordinates[margin_dims[margin]] = shape[margin_dims[margin]] - 1;
                }
                bits >>= 1;
            }
            // Encode the dimension coordinates of the margin cell into flattened index
            size_t margin_cell = margin_coordinates[0];
            for (size_t j = 1; j < rank; ++j) {
                margin_cell *= shape[j];
                margin_cell += margin_coordinates[j];
            }
            assert(margin_cell >= 0 && margin_cell < 2114); // logic guarantee
            cells_to_increment[combo] = margin_cell;
        }
    }

    // Increments and Accumulators:
    //  accumulator 0: sum(delta(interval(transitions(is_alive, false, true))))
    {
        const int acc_index = 0; // accumulator index

        // Compute increment
        counter value_out = om_transitions_FOR_is_alive_X_false_X_true;
        auto& value_in = om_tabBirthsYearPlace_in_om_transitions_FOR_is_alive_X_false_X_true;

        double dIncrement;
        dIncrement = (double)value_out - (double)value_in;

        // Push increment to body cell and margin cells
        for (int cell : cells_to_increment) {
            auto& dAccumulator = table->acc[acc_index][cell];
            dAccumulator += dIncrement;
        }
    }
}
int Person::om_tabEducationFateGeobirYob_current_cell()
{
    assert(thetabEducationFateGeobirYob); // unitary table must be instantiated

    // Dimensionality of table (does not include measure dimension)
    const size_t rank = 3;

    // Size of each dimension of table (includes margin if present)
    const std::array<size_t, rank> shape = {3, 14, 252};

    // Dimension coordinates of current cell
    const std::array<size_t, rank> coordinates = {
        size_t(sex), 
        size_t(geo_birth), 
        size_t(year_of_birth - 1899), 
    };

    // Encode the dimension coordinates of the margin cell into flattened index
    size_t cell = coordinates[0];
    for (size_t j = 1; j < rank; ++j) {
        cell *= shape[j];
        cell += coordinates[j];
    }

    assert(cell >= 0 && cell < 10584); // logic guarantee
    return cell;
}
void Person::om_tabEducationFateGeobirYob_init_increment(int pending, big_counter pending_event_counter)
{
    assert(thetabEducationFateGeobirYob); // unitary table must be instantiated

    {
        // interval(om_duration_FOR_educ_one_fate_X_EOL_LOW)
        auto & value_in = om_tabEducationFateGeobirYob_in_om_duration_FOR_educ_one_fate_X_EOL_LOW;
        Time value_curr = om_duration_FOR_educ_one_fate_X_EOL_LOW;

        value_in = value_curr;
    }
    {
        // interval(om_duration)
        auto & value_in = om_tabEducationFateGeobirYob_in_om_duration;
        Time value_curr = om_duration;

        value_in = value_curr;
    }
    {
        // interval(om_duration_FOR_educ_one_fate_X_EOL_MEDIUM)
        auto & value_in = om_tabEducationFateGeobirYob_in_om_duration_FOR_educ_one_fate_X_EOL_MEDIUM;
        Time value_curr = om_duration_FOR_educ_one_fate_X_EOL_MEDIUM;

        value_in = value_curr;
    }
    {
        // interval(om_duration_FOR_educ_one_fate_X_EOL_HIGH)
        auto & value_in = om_tabEducationFateGeobirYob_in_om_duration_FOR_educ_one_fate_X_EOL_HIGH;
        Time value_curr = om_duration_FOR_educ_one_fate_X_EOL_HIGH;

        value_in = value_curr;
    }
}
void Person::om_tabEducationFateGeobirYob_push_increment(int cell_in, int pending, big_counter pending_event_counter)
{
    assert(thetabEducationFateGeobirYob); // unitary table must be instantiated

    auto& table = thetabEducationFateGeobirYob;

    // Table has margins

    // Dimensionality of table (does not include measure dimension)
    const size_t rank = 3;

    // Size of each dimension of table (includes margin if present)
    const std::array<size_t, rank> shape = {3, 14, 252};

    // Number of dimensions with a margin
    const size_t margin_count = 2;

    // Dimensions with a margin
    const std::array<size_t, margin_count> margin_dims = {0, 1};

    // Number of margin combinations for a cell in the table body
    // e.g. a table with 3 margins has 2^3-1=7 margin cells associated with a body cell
    const size_t margin_combos = (1 << margin_count) - 1;

    // Indexes of table cells to increment (cell in table body and cells in margins)
    std::array<size_t, 1 + margin_combos> cells_to_increment;

    // Populate cells_to_increment

    // The cell in the table body:
    cells_to_increment[0] = cell_in;

    // The margin cells
    {
        // Dimension coordinates of the body cell being incremented
        std::array<size_t, rank> body_coordinates;
        // Decode dimension coordinates of the body cell
        for (int j = rank - 1, w = cell_in; j >= 0; --j) {
            body_coordinates[j] = w % shape[j];
            w /= shape[j];
        }
        // Working coordinates of a margin cell
        std::array<size_t, rank> margin_coordinates;
        for (size_t combo = 1; combo <= margin_combos; ++combo) {
            // The binary bits of combo select the margin dimensions for the combination.
            margin_coordinates = body_coordinates;
            size_t bits = combo;
            for (size_t margin = 0; margin < margin_count; ++margin) {
                // read out the bits in combo
                if (bits & 1) {
                    // low order bit is 1, so replace coordinate from body cell by margin coordinate
                    margin_coordinates[margin_dims[margin]] = shape[margin_dims[margin]] - 1;
                }
                bits >>= 1;
            }
            // Encode the dimension coordinates of the margin cell into flattened index
            size_t margin_cell = margin_coordinates[0];
            for (size_t j = 1; j < rank; ++j) {
                margin_cell *= shape[j];
                margin_cell += margin_coordinates[j];
            }
            assert(margin_cell >= 0 && margin_cell < 10584); // logic guarantee
            cells_to_increment[combo] = margin_cell;
        }
    }

    // Increments and Accumulators:
    //  accumulator 0: sum(delta(interval(duration(educ_one_fate, EOL_LOW))))
    {
        const int acc_index = 0; // accumulator index

        // Compute increment
        Time value_out = om_duration_FOR_educ_one_fate_X_EOL_LOW;
        auto& value_in = om_tabEducationFateGeobirYob_in_om_duration_FOR_educ_one_fate_X_EOL_LOW;

        double dIncrement;
        dIncrement = (double)value_out - (double)value_in;

        // Push increment to body cell and margin cells
        for (int cell : cells_to_increment) {
            auto& dAccumulator = table->acc[acc_index][cell];
            dAccumulator += dIncrement;
        }
    }
    //  accumulator 1: sum(delta(interval(duration())))
    {
        const int acc_index = 1; // accumulator index

        // Compute increment
        Time value_out = om_duration;
        auto& value_in = om_tabEducationFateGeobirYob_in_om_duration;

        double dIncrement;
        dIncrement = (double)value_out - (double)value_in;

        // Push increment to body cell and margin cells
        for (int cell : cells_to_increment) {
            auto& dAccumulator = table->acc[acc_index][cell];
            dAccumulator += dIncrement;
        }
    }
    //  accumulator 2: sum(delta(interval(duration(educ_one_fate, EOL_MEDIUM))))
    {
        const int acc_index = 2; // accumulator index

        // Compute increment
        Time value_out = om_duration_FOR_educ_one_fate_X_EOL_MEDIUM;
        auto& value_in = om_tabEducationFateGeobirYob_in_om_duration_FOR_educ_one_fate_X_EOL_MEDIUM;

        double dIncrement;
        dIncrement = (double)value_out - (double)value_in;

        // Push increment to body cell and margin cells
        for (int cell : cells_to_increment) {
            auto& dAccumulator = table->acc[acc_index][cell];
            dAccumulator += dIncrement;
        }
    }
    //  accumulator 3: sum(delta(interval(duration(educ_one_fate, EOL_HIGH))))
    {
        const int acc_index = 3; // accumulator index

        // Compute increment
        Time value_out = om_duration_FOR_educ_one_fate_X_EOL_HIGH;
        auto& value_in = om_tabEducationFateGeobirYob_in_om_duration_FOR_educ_one_fate_X_EOL_HIGH;

        double dIncrement;
        dIncrement = (double)value_out - (double)value_in;

        // Push increment to body cell and margin cells
        for (int cell : cells_to_increment) {
            auto& dAccumulator = table->acc[acc_index][cell];
            dAccumulator += dIncrement;
        }
    }
}
int Person::om_tabHCI_current_cell()
{
    assert(thetabHCI); // unitary table must be instantiated

    // Dimensionality of table (does not include measure dimension)
    const size_t rank = 3;

    // Size of each dimension of table (includes margin if present)
    const std::array<size_t, rank> shape = {3, 6, 151};

    // Dimension coordinates of current cell
    const std::array<size_t, rank> coordinates = {
        size_t(sex), 
        size_t(om_aggregate_FOR_region_birth_X_REGION_NAT), 
        size_t(tab_sim_yob - 2000), 
    };

    // Encode the dimension coordinates of the margin cell into flattened index
    size_t cell = coordinates[0];
    for (size_t j = 1; j < rank; ++j) {
        cell *= shape[j];
        cell += coordinates[j];
    }

    assert(cell >= 0 && cell < 2718); // logic guarantee
    return cell;
}
void Person::om_tabHCI_init_increment(int pending, big_counter pending_event_counter)
{
    assert(thetabHCI); // unitary table must be instantiated

    {
        // interval(om_value_at_transitions_FOR_is_alive_X_true_X_is_stunted_X_false)
        auto & value_in = om_tabHCI_in_om_value_at_transitions_FOR_is_alive_X_true_X_is_stunted_X_false;
        integer value_curr = om_value_at_transitions_FOR_is_alive_X_true_X_is_stunted_X_false;

        value_in = value_curr;
    }
    {
        // interval(om_transitions_FOR_is_alive_X_true_X_false)
        auto & value_in = om_tabHCI_in_om_transitions_FOR_is_alive_X_true_X_false;
        counter value_curr = om_transitions_FOR_is_alive_X_true_X_false;

        value_in = value_curr;
    }
    {
        // interval(om_value_at_transitions_FOR_is_alive_X_true_X_survived_early_years_X_false)
        auto & value_in = om_tabHCI_in_om_value_at_transitions_FOR_is_alive_X_true_X_survived_early_years_X_false;
        integer value_curr = om_value_at_transitions_FOR_is_alive_X_true_X_survived_early_years_X_false;

        value_in = value_curr;
    }
    {
        // interval(om_value_at_transitions_FOR_is_alive_X_true_X_adult_survival_X_false)
        auto & value_in = om_tabHCI_in_om_value_at_transitions_FOR_is_alive_X_true_X_adult_survival_X_false;
        real value_curr = om_value_at_transitions_FOR_is_alive_X_true_X_adult_survival_X_false;

        value_in = value_curr;
    }
    {
        // interval(om_transitions_FOR_integer_age_X_14_X_15)
        auto & value_in = om_tabHCI_in_om_transitions_FOR_integer_age_X_14_X_15;
        counter value_curr = om_transitions_FOR_integer_age_X_14_X_15;

        value_in = value_curr;
    }
    {
        // interval(om_value_at_transitions_FOR_is_alive_X_true_X_quality_of_schooling_X_false)
        auto & value_in = om_tabHCI_in_om_value_at_transitions_FOR_is_alive_X_true_X_quality_of_schooling_X_false;
        real value_curr = om_value_at_transitions_FOR_is_alive_X_true_X_quality_of_schooling_X_false;

        value_in = value_curr;
    }
    {
        // interval(om_transitions_FOR_survived_early_years_X_false_X_true)
        auto & value_in = om_tabHCI_in_om_transitions_FOR_survived_early_years_X_false_X_true;
        counter value_curr = om_transitions_FOR_survived_early_years_X_false_X_true;

        value_in = value_curr;
    }
    {
        // interval(om_value_at_transitions_FOR_is_alive_X_true_X_years_of_schooling_X_false)
        auto & value_in = om_tabHCI_in_om_value_at_transitions_FOR_is_alive_X_true_X_years_of_schooling_X_false;
        integer value_curr = om_value_at_transitions_FOR_is_alive_X_true_X_years_of_schooling_X_false;

        value_in = value_curr;
    }
    {
        // interval(om_value_at_transitions_FOR_is_alive_X_true_X_ind_hci_X_false)
        auto & value_in = om_tabHCI_in_om_value_at_transitions_FOR_is_alive_X_true_X_ind_hci_X_false;
        real value_curr = om_value_at_transitions_FOR_is_alive_X_true_X_ind_hci_X_false;

        value_in = value_curr;
    }
}
void Person::om_tabHCI_push_increment(int cell_in, int pending, big_counter pending_event_counter)
{
    assert(thetabHCI); // unitary table must be instantiated

    auto& table = thetabHCI;

    // Table has margins

    // Dimensionality of table (does not include measure dimension)
    const size_t rank = 3;

    // Size of each dimension of table (includes margin if present)
    const std::array<size_t, rank> shape = {3, 6, 151};

    // Number of dimensions with a margin
    const size_t margin_count = 2;

    // Dimensions with a margin
    const std::array<size_t, margin_count> margin_dims = {0, 1};

    // Number of margin combinations for a cell in the table body
    // e.g. a table with 3 margins has 2^3-1=7 margin cells associated with a body cell
    const size_t margin_combos = (1 << margin_count) - 1;

    // Indexes of table cells to increment (cell in table body and cells in margins)
    std::array<size_t, 1 + margin_combos> cells_to_increment;

    // Populate cells_to_increment

    // The cell in the table body:
    cells_to_increment[0] = cell_in;

    // The margin cells
    {
        // Dimension coordinates of the body cell being incremented
        std::array<size_t, rank> body_coordinates;
        // Decode dimension coordinates of the body cell
        for (int j = rank - 1, w = cell_in; j >= 0; --j) {
            body_coordinates[j] = w % shape[j];
            w /= shape[j];
        }
        // Working coordinates of a margin cell
        std::array<size_t, rank> margin_coordinates;
        for (size_t combo = 1; combo <= margin_combos; ++combo) {
            // The binary bits of combo select the margin dimensions for the combination.
            margin_coordinates = body_coordinates;
            size_t bits = combo;
            for (size_t margin = 0; margin < margin_count; ++margin) {
                // read out the bits in combo
                if (bits & 1) {
                    // low order bit is 1, so replace coordinate from body cell by margin coordinate
                    margin_coordinates[margin_dims[margin]] = shape[margin_dims[margin]] - 1;
                }
                bits >>= 1;
            }
            // Encode the dimension coordinates of the margin cell into flattened index
            size_t margin_cell = margin_coordinates[0];
            for (size_t j = 1; j < rank; ++j) {
                margin_cell *= shape[j];
                margin_cell += margin_coordinates[j];
            }
            assert(margin_cell >= 0 && margin_cell < 2718); // logic guarantee
            cells_to_increment[combo] = margin_cell;
        }
    }

    // Increments and Accumulators:
    //  accumulator 0: sum(delta(interval(value_at_transitions(is_alive, true, false, is_stunted))))
    {
        const int acc_index = 0; // accumulator index

        // Compute increment
        integer value_out = om_value_at_transitions_FOR_is_alive_X_true_X_is_stunted_X_false;
        auto& value_in = om_tabHCI_in_om_value_at_transitions_FOR_is_alive_X_true_X_is_stunted_X_false;

        double dIncrement;
        dIncrement = (double)value_out - (double)value_in;

        // Push increment to body cell and margin cells
        for (int cell : cells_to_increment) {
            auto& dAccumulator = table->acc[acc_index][cell];
            dAccumulator += dIncrement;
        }
    }
    //  accumulator 1: sum(delta(interval(transitions(is_alive, true, false))))
    {
        const int acc_index = 1; // accumulator index

        // Compute increment
        counter value_out = om_transitions_FOR_is_alive_X_true_X_false;
        auto& value_in = om_tabHCI_in_om_transitions_FOR_is_alive_X_true_X_false;

        double dIncrement;
        dIncrement = (double)value_out - (double)value_in;

        // Push increment to body cell and margin cells
        for (int cell : cells_to_increment) {
            auto& dAccumulator = table->acc[acc_index][cell];
            dAccumulator += dIncrement;
        }
    }
    //  accumulator 2: sum(delta(interval(value_at_transitions(is_alive, true, false, survived_early_years))))
    {
        const int acc_index = 2; // accumulator index

        // Compute increment
        integer value_out = om_value_at_transitions_FOR_is_alive_X_true_X_survived_early_years_X_false;
        auto& value_in = om_tabHCI_in_om_value_at_transitions_FOR_is_alive_X_true_X_survived_early_years_X_false;

        double dIncrement;
        dIncrement = (double)value_out - (double)value_in;

        // Push increment to body cell and margin cells
        for (int cell : cells_to_increment) {
            auto& dAccumulator = table->acc[acc_index][cell];
            dAccumulator += dIncrement;
        }
    }
    //  accumulator 3: sum(delta(interval(value_at_transitions(is_alive, true, false, adult_survival))))
    {
        const int acc_index = 3; // accumulator index

        // Compute increment
        real value_out = om_value_at_transitions_FOR_is_alive_X_true_X_adult_survival_X_false;
        auto& value_in = om_tabHCI_in_om_value_at_transitions_FOR_is_alive_X_true_X_adult_survival_X_false;

        double dIncrement;
        dIncrement = (double)value_out - (double)value_in;

        // Push increment to body cell and margin cells
        for (int cell : cells_to_increment) {
            auto& dAccumulator = table->acc[acc_index][cell];
            dAccumulator += dIncrement;
        }
    }
    //  accumulator 4: sum(delta(interval(transitions(integer_age, 14, 15))))
    {
        const int acc_index = 4; // accumulator index

        // Compute increment
        counter value_out = om_transitions_FOR_integer_age_X_14_X_15;
        auto& value_in = om_tabHCI_in_om_transitions_FOR_integer_age_X_14_X_15;

        double dIncrement;
        dIncrement = (double)value_out - (double)value_in;

        // Push increment to body cell and margin cells
        for (int cell : cells_to_increment) {
            auto& dAccumulator = table->acc[acc_index][cell];
            dAccumulator += dIncrement;
        }
    }
    //  accumulator 5: sum(delta(interval(value_at_transitions(is_alive, true, false, quality_of_schooling))))
    {
        const int acc_index = 5; // accumulator index

        // Compute increment
        real value_out = om_value_at_transitions_FOR_is_alive_X_true_X_quality_of_schooling_X_false;
        auto& value_in = om_tabHCI_in_om_value_at_transitions_FOR_is_alive_X_true_X_quality_of_schooling_X_false;

        double dIncrement;
        dIncrement = (double)value_out - (double)value_in;

        // Push increment to body cell and margin cells
        for (int cell : cells_to_increment) {
            auto& dAccumulator = table->acc[acc_index][cell];
            dAccumulator += dIncrement;
        }
    }
    //  accumulator 6: sum(delta(interval(transitions(survived_early_years, false, true))))
    {
        const int acc_index = 6; // accumulator index

        // Compute increment
        counter value_out = om_transitions_FOR_survived_early_years_X_false_X_true;
        auto& value_in = om_tabHCI_in_om_transitions_FOR_survived_early_years_X_false_X_true;

        double dIncrement;
        dIncrement = (double)value_out - (double)value_in;

        // Push increment to body cell and margin cells
        for (int cell : cells_to_increment) {
            auto& dAccumulator = table->acc[acc_index][cell];
            dAccumulator += dIncrement;
        }
    }
    //  accumulator 7: sum(delta(interval(value_at_transitions(is_alive, true, false, years_of_schooling))))
    {
        const int acc_index = 7; // accumulator index

        // Compute increment
        integer value_out = om_value_at_transitions_FOR_is_alive_X_true_X_years_of_schooling_X_false;
        auto& value_in = om_tabHCI_in_om_value_at_transitions_FOR_is_alive_X_true_X_years_of_schooling_X_false;

        double dIncrement;
        dIncrement = (double)value_out - (double)value_in;

        // Push increment to body cell and margin cells
        for (int cell : cells_to_increment) {
            auto& dAccumulator = table->acc[acc_index][cell];
            dAccumulator += dIncrement;
        }
    }
    //  accumulator 8: sum(delta(interval(value_at_transitions(is_alive, true, false, ind_hci))))
    {
        const int acc_index = 8; // accumulator index

        // Compute increment
        real value_out = om_value_at_transitions_FOR_is_alive_X_true_X_ind_hci_X_false;
        auto& value_in = om_tabHCI_in_om_value_at_transitions_FOR_is_alive_X_true_X_ind_hci_X_false;

        double dIncrement;
        dIncrement = (double)value_out - (double)value_in;

        // Push increment to body cell and margin cells
        for (int cell : cells_to_increment) {
            auto& dAccumulator = table->acc[acc_index][cell];
            dAccumulator += dIncrement;
        }
    }
}
int Person::om_tabHavingSpouse_current_cell()
{
    assert(thetabHavingSpouse); // unitary table must be instantiated

    // Dimensionality of table (does not include measure dimension)
    const size_t rank = 3;

    // Size of each dimension of table (includes margin if present)
    const std::array<size_t, rank> shape = {3, 101, 151};

    // Dimension coordinates of current cell
    const std::array<size_t, rank> coordinates = {
        size_t(sex), 
        size_t(integer_age), 
        size_t(sim_year - 2000), 
    };

    // Encode the dimension coordinates of the margin cell into flattened index
    size_t cell = coordinates[0];
    for (size_t j = 1; j < rank; ++j) {
        cell *= shape[j];
        cell += coordinates[j];
    }

    assert(cell >= 0 && cell < 45753); // logic guarantee
    return cell;
}
void Person::om_tabHavingSpouse_init_increment(int pending, big_counter pending_event_counter)
{
    assert(thetabHavingSpouse); // unitary table must be instantiated

    {
        // interval(om_duration_FOR_has_spouse_X_true)
        auto & value_in = om_tabHavingSpouse_in_om_duration_FOR_has_spouse_X_true;
        Time value_curr = om_duration_FOR_has_spouse_X_true;

        value_in = value_curr;
    }
    {
        // interval(om_duration)
        auto & value_in = om_tabHavingSpouse_in_om_duration;
        Time value_curr = om_duration;

        value_in = value_curr;
    }
    {
        // interval(om_duration_FOR_ever_union_X_true)
        auto & value_in = om_tabHavingSpouse_in_om_duration_FOR_ever_union_X_true;
        Time value_curr = om_duration_FOR_ever_union_X_true;

        value_in = value_curr;
    }
}
void Person::om_tabHavingSpouse_push_increment(int cell_in, int pending, big_counter pending_event_counter)
{
    assert(thetabHavingSpouse); // unitary table must be instantiated

    auto& table = thetabHavingSpouse;

    // Table has margins

    // Dimensionality of table (does not include measure dimension)
    const size_t rank = 3;

    // Size of each dimension of table (includes margin if present)
    const std::array<size_t, rank> shape = {3, 101, 151};

    // Number of dimensions with a margin
    const size_t margin_count = 1;

    // Dimensions with a margin
    const std::array<size_t, margin_count> margin_dims = {0};

    // Number of margin combinations for a cell in the table body
    // e.g. a table with 3 margins has 2^3-1=7 margin cells associated with a body cell
    const size_t margin_combos = (1 << margin_count) - 1;

    // Indexes of table cells to increment (cell in table body and cells in margins)
    std::array<size_t, 1 + margin_combos> cells_to_increment;

    // Populate cells_to_increment

    // The cell in the table body:
    cells_to_increment[0] = cell_in;

    // The margin cells
    {
        // Dimension coordinates of the body cell being incremented
        std::array<size_t, rank> body_coordinates;
        // Decode dimension coordinates of the body cell
        for (int j = rank - 1, w = cell_in; j >= 0; --j) {
            body_coordinates[j] = w % shape[j];
            w /= shape[j];
        }
        // Working coordinates of a margin cell
        std::array<size_t, rank> margin_coordinates;
        for (size_t combo = 1; combo <= margin_combos; ++combo) {
            // The binary bits of combo select the margin dimensions for the combination.
            margin_coordinates = body_coordinates;
            size_t bits = combo;
            for (size_t margin = 0; margin < margin_count; ++margin) {
                // read out the bits in combo
                if (bits & 1) {
                    // low order bit is 1, so replace coordinate from body cell by margin coordinate
                    margin_coordinates[margin_dims[margin]] = shape[margin_dims[margin]] - 1;
                }
                bits >>= 1;
            }
            // Encode the dimension coordinates of the margin cell into flattened index
            size_t margin_cell = margin_coordinates[0];
            for (size_t j = 1; j < rank; ++j) {
                margin_cell *= shape[j];
                margin_cell += margin_coordinates[j];
            }
            assert(margin_cell >= 0 && margin_cell < 45753); // logic guarantee
            cells_to_increment[combo] = margin_cell;
        }
    }

    // Increments and Accumulators:
    //  accumulator 0: sum(delta(interval(duration(has_spouse, true))))
    {
        const int acc_index = 0; // accumulator index

        // Compute increment
        Time value_out = om_duration_FOR_has_spouse_X_true;
        auto& value_in = om_tabHavingSpouse_in_om_duration_FOR_has_spouse_X_true;

        double dIncrement;
        dIncrement = (double)value_out - (double)value_in;

        // Push increment to body cell and margin cells
        for (int cell : cells_to_increment) {
            auto& dAccumulator = table->acc[acc_index][cell];
            dAccumulator += dIncrement;
        }
    }
    //  accumulator 1: sum(delta(interval(duration())))
    {
        const int acc_index = 1; // accumulator index

        // Compute increment
        Time value_out = om_duration;
        auto& value_in = om_tabHavingSpouse_in_om_duration;

        double dIncrement;
        dIncrement = (double)value_out - (double)value_in;

        // Push increment to body cell and margin cells
        for (int cell : cells_to_increment) {
            auto& dAccumulator = table->acc[acc_index][cell];
            dAccumulator += dIncrement;
        }
    }
    //  accumulator 2: sum(delta(interval(duration(ever_union, true))))
    {
        const int acc_index = 2; // accumulator index

        // Compute increment
        Time value_out = om_duration_FOR_ever_union_X_true;
        auto& value_in = om_tabHavingSpouse_in_om_duration_FOR_ever_union_X_true;

        double dIncrement;
        dIncrement = (double)value_out - (double)value_in;

        // Push increment to body cell and margin cells
        for (int cell : cells_to_increment) {
            auto& dAccumulator = table->acc[acc_index][cell];
            dAccumulator += dIncrement;
        }
    }
}
int Person::om_tabMigrationOriginDestination_current_cell()
{
    assert(thetabMigrationOriginDestination); // unitary table must be instantiated

    // Dimensionality of table (does not include measure dimension)
    const size_t rank = 3;

    // Size of each dimension of table (includes margin if present)
    const std::array<size_t, rank> shape = {5, 14, 13};

    // Dimension coordinates of current cell
    const std::array<size_t, rank> coordinates = {
        size_t(selected_year10), 
        size_t(geo_prev), 
        size_t(geo), 
    };

    // Encode the dimension coordinates of the margin cell into flattened index
    size_t cell = coordinates[0];
    for (size_t j = 1; j < rank; ++j) {
        cell *= shape[j];
        cell += coordinates[j];
    }

    assert(cell >= 0 && cell < 910); // logic guarantee
    return cell;
}
void Person::om_tabMigrationOriginDestination_init_increment(int pending, big_counter pending_event_counter)
{
    assert(thetabMigrationOriginDestination); // unitary table must be instantiated

    {
        // interval(is_alive)
        auto & value_in = om_tabMigrationOriginDestination_in_is_alive;
        bool value_curr = is_alive;

        value_in = value_curr;
    }
}
void Person::om_tabMigrationOriginDestination_push_increment(int cell_in, int pending, big_counter pending_event_counter)
{
    assert(thetabMigrationOriginDestination); // unitary table must be instantiated

    auto& table = thetabMigrationOriginDestination;

    // Table has margins

    // Dimensionality of table (does not include measure dimension)
    const size_t rank = 3;

    // Size of each dimension of table (includes margin if present)
    const std::array<size_t, rank> shape = {5, 14, 13};

    // Number of dimensions with a margin
    const size_t margin_count = 1;

    // Dimensions with a margin
    const std::array<size_t, margin_count> margin_dims = {1};

    // Number of margin combinations for a cell in the table body
    // e.g. a table with 3 margins has 2^3-1=7 margin cells associated with a body cell
    const size_t margin_combos = (1 << margin_count) - 1;

    // Indexes of table cells to increment (cell in table body and cells in margins)
    std::array<size_t, 1 + margin_combos> cells_to_increment;

    // Populate cells_to_increment

    // The cell in the table body:
    cells_to_increment[0] = cell_in;

    // The margin cells
    {
        // Dimension coordinates of the body cell being incremented
        std::array<size_t, rank> body_coordinates;
        // Decode dimension coordinates of the body cell
        for (int j = rank - 1, w = cell_in; j >= 0; --j) {
            body_coordinates[j] = w % shape[j];
            w /= shape[j];
        }
        // Working coordinates of a margin cell
        std::array<size_t, rank> margin_coordinates;
        for (size_t combo = 1; combo <= margin_combos; ++combo) {
            // The binary bits of combo select the margin dimensions for the combination.
            margin_coordinates = body_coordinates;
            size_t bits = combo;
            for (size_t margin = 0; margin < margin_count; ++margin) {
                // read out the bits in combo
                if (bits & 1) {
                    // low order bit is 1, so replace coordinate from body cell by margin coordinate
                    margin_coordinates[margin_dims[margin]] = shape[margin_dims[margin]] - 1;
                }
                bits >>= 1;
            }
            // Encode the dimension coordinates of the margin cell into flattened index
            size_t margin_cell = margin_coordinates[0];
            for (size_t j = 1; j < rank; ++j) {
                margin_cell *= shape[j];
                margin_cell += margin_coordinates[j];
            }
            assert(margin_cell >= 0 && margin_cell < 910); // logic guarantee
            cells_to_increment[combo] = margin_cell;
        }
    }

    // Increments and Accumulators:
    //  accumulator 0: sum(value_in(interval(is_alive)))
    {
        const int acc_index = 0; // accumulator index

        // Compute increment
        auto& value_in = om_tabMigrationOriginDestination_in_is_alive;

        double dIncrement;
        dIncrement = value_in;

        // Push increment to body cell and margin cells
        for (int cell : cells_to_increment) {
            auto& dAccumulator = table->acc[acc_index][cell];
            dAccumulator += dIncrement;
        }
    }
}
int Person::om_tabPopulationYearPlace_current_cell()
{
    assert(thetabPopulationYearPlace); // unitary table must be instantiated

    // Dimensionality of table (does not include measure dimension)
    const size_t rank = 2;

    // Size of each dimension of table (includes margin if present)
    const std::array<size_t, rank> shape = {14, 151};

    // Dimension coordinates of current cell
    const std::array<size_t, rank> coordinates = {
        size_t(geo), 
        size_t(sim_year - 2000), 
    };

    // Encode the dimension coordinates of the margin cell into flattened index
    size_t cell = coordinates[0];
    for (size_t j = 1; j < rank; ++j) {
        cell *= shape[j];
        cell += coordinates[j];
    }

    assert(cell >= 0 && cell < 2114); // logic guarantee
    return cell;
}
void Person::om_tabPopulationYearPlace_init_increment(int pending, big_counter pending_event_counter)
{
    assert(thetabPopulationYearPlace); // unitary table must be instantiated

    {
        // interval(om_duration)
        auto & value_in = om_tabPopulationYearPlace_in_om_duration;
        Time value_curr = om_duration;

        value_in = value_curr;
    }
}
void Person::om_tabPopulationYearPlace_push_increment(int cell_in, int pending, big_counter pending_event_counter)
{
    assert(thetabPopulationYearPlace); // unitary table must be instantiated

    auto& table = thetabPopulationYearPlace;

    // Table has margins

    // Dimensionality of table (does not include measure dimension)
    const size_t rank = 2;

    // Size of each dimension of table (includes margin if present)
    const std::array<size_t, rank> shape = {14, 151};

    // Number of dimensions with a margin
    const size_t margin_count = 1;

    // Dimensions with a margin
    const std::array<size_t, margin_count> margin_dims = {0};

    // Number of margin combinations for a cell in the table body
    // e.g. a table with 3 margins has 2^3-1=7 margin cells associated with a body cell
    const size_t margin_combos = (1 << margin_count) - 1;

    // Indexes of table cells to increment (cell in table body and cells in margins)
    std::array<size_t, 1 + margin_combos> cells_to_increment;

    // Populate cells_to_increment

    // The cell in the table body:
    cells_to_increment[0] = cell_in;

    // The margin cells
    {
        // Dimension coordinates of the body cell being incremented
        std::array<size_t, rank> body_coordinates;
        // Decode dimension coordinates of the body cell
        for (int j = rank - 1, w = cell_in; j >= 0; --j) {
            body_coordinates[j] = w % shape[j];
            w /= shape[j];
        }
        // Working coordinates of a margin cell
        std::array<size_t, rank> margin_coordinates;
        for (size_t combo = 1; combo <= margin_combos; ++combo) {
            // The binary bits of combo select the margin dimensions for the combination.
            margin_coordinates = body_coordinates;
            size_t bits = combo;
            for (size_t margin = 0; margin < margin_count; ++margin) {
                // read out the bits in combo
                if (bits & 1) {
                    // low order bit is 1, so replace coordinate from body cell by margin coordinate
                    margin_coordinates[margin_dims[margin]] = shape[margin_dims[margin]] - 1;
                }
                bits >>= 1;
            }
            // Encode the dimension coordinates of the margin cell into flattened index
            size_t margin_cell = margin_coordinates[0];
            for (size_t j = 1; j < rank; ++j) {
                margin_cell *= shape[j];
                margin_cell += margin_coordinates[j];
            }
            assert(margin_cell >= 0 && margin_cell < 2114); // logic guarantee
            cells_to_increment[combo] = margin_cell;
        }
    }

    // Increments and Accumulators:
    //  accumulator 0: sum(delta(interval(duration())))
    {
        const int acc_index = 0; // accumulator index

        // Compute increment
        Time value_out = om_duration;
        auto& value_in = om_tabPopulationYearPlace_in_om_duration;

        double dIncrement;
        dIncrement = (double)value_out - (double)value_in;

        // Push increment to body cell and margin cells
        for (int cell : cells_to_increment) {
            auto& dAccumulator = table->acc[acc_index][cell];
            dAccumulator += dIncrement;
        }
    }
}
int Person::om_tabPreSchool_current_cell()
{
    assert(thetabPreSchool); // unitary table must be instantiated

    // Dimensionality of table (does not include measure dimension)
    const size_t rank = 2;

    // Size of each dimension of table (includes margin if present)
    const std::array<size_t, rank> shape = {14, 151};

    // Dimension coordinates of current cell
    const std::array<size_t, rank> coordinates = {
        size_t(geo), 
        size_t(tab_sim_yob - 2000), 
    };

    // Encode the dimension coordinates of the margin cell into flattened index
    size_t cell = coordinates[0];
    for (size_t j = 1; j < rank; ++j) {
        cell *= shape[j];
        cell += coordinates[j];
    }

    assert(cell >= 0 && cell < 2114); // logic guarantee
    return cell;
}
void Person::om_tabPreSchool_init_increment(int pending, big_counter pending_event_counter)
{
    assert(thetabPreSchool); // unitary table must be instantiated

    {
        // interval(om_duration_FOR_years_preschool_X_0)
        auto & value_in = om_tabPreSchool_in_om_duration_FOR_years_preschool_X_0;
        Time value_curr = om_duration_FOR_years_preschool_X_0;

        value_in = value_curr;
    }
    {
        // interval(om_duration)
        auto & value_in = om_tabPreSchool_in_om_duration;
        Time value_curr = om_duration;

        value_in = value_curr;
    }
    {
        // interval(om_duration_FOR_years_preschool_X_1)
        auto & value_in = om_tabPreSchool_in_om_duration_FOR_years_preschool_X_1;
        Time value_curr = om_duration_FOR_years_preschool_X_1;

        value_in = value_curr;
    }
    {
        // interval(om_duration_FOR_years_preschool_X_2)
        auto & value_in = om_tabPreSchool_in_om_duration_FOR_years_preschool_X_2;
        Time value_curr = om_duration_FOR_years_preschool_X_2;

        value_in = value_curr;
    }
}
void Person::om_tabPreSchool_push_increment(int cell_in, int pending, big_counter pending_event_counter)
{
    assert(thetabPreSchool); // unitary table must be instantiated

    auto& table = thetabPreSchool;

    // Table has margins

    // Dimensionality of table (does not include measure dimension)
    const size_t rank = 2;

    // Size of each dimension of table (includes margin if present)
    const std::array<size_t, rank> shape = {14, 151};

    // Number of dimensions with a margin
    const size_t margin_count = 1;

    // Dimensions with a margin
    const std::array<size_t, margin_count> margin_dims = {0};

    // Number of margin combinations for a cell in the table body
    // e.g. a table with 3 margins has 2^3-1=7 margin cells associated with a body cell
    const size_t margin_combos = (1 << margin_count) - 1;

    // Indexes of table cells to increment (cell in table body and cells in margins)
    std::array<size_t, 1 + margin_combos> cells_to_increment;

    // Populate cells_to_increment

    // The cell in the table body:
    cells_to_increment[0] = cell_in;

    // The margin cells
    {
        // Dimension coordinates of the body cell being incremented
        std::array<size_t, rank> body_coordinates;
        // Decode dimension coordinates of the body cell
        for (int j = rank - 1, w = cell_in; j >= 0; --j) {
            body_coordinates[j] = w % shape[j];
            w /= shape[j];
        }
        // Working coordinates of a margin cell
        std::array<size_t, rank> margin_coordinates;
        for (size_t combo = 1; combo <= margin_combos; ++combo) {
            // The binary bits of combo select the margin dimensions for the combination.
            margin_coordinates = body_coordinates;
            size_t bits = combo;
            for (size_t margin = 0; margin < margin_count; ++margin) {
                // read out the bits in combo
                if (bits & 1) {
                    // low order bit is 1, so replace coordinate from body cell by margin coordinate
                    margin_coordinates[margin_dims[margin]] = shape[margin_dims[margin]] - 1;
                }
                bits >>= 1;
            }
            // Encode the dimension coordinates of the margin cell into flattened index
            size_t margin_cell = margin_coordinates[0];
            for (size_t j = 1; j < rank; ++j) {
                margin_cell *= shape[j];
                margin_cell += margin_coordinates[j];
            }
            assert(margin_cell >= 0 && margin_cell < 2114); // logic guarantee
            cells_to_increment[combo] = margin_cell;
        }
    }

    // Increments and Accumulators:
    //  accumulator 0: sum(delta(interval(duration(years_preschool, 0))))
    {
        const int acc_index = 0; // accumulator index

        // Compute increment
        Time value_out = om_duration_FOR_years_preschool_X_0;
        auto& value_in = om_tabPreSchool_in_om_duration_FOR_years_preschool_X_0;

        double dIncrement;
        dIncrement = (double)value_out - (double)value_in;

        // Push increment to body cell and margin cells
        for (int cell : cells_to_increment) {
            auto& dAccumulator = table->acc[acc_index][cell];
            dAccumulator += dIncrement;
        }
    }
    //  accumulator 1: sum(delta(interval(duration())))
    {
        const int acc_index = 1; // accumulator index

        // Compute increment
        Time value_out = om_duration;
        auto& value_in = om_tabPreSchool_in_om_duration;

        double dIncrement;
        dIncrement = (double)value_out - (double)value_in;

        // Push increment to body cell and margin cells
        for (int cell : cells_to_increment) {
            auto& dAccumulator = table->acc[acc_index][cell];
            dAccumulator += dIncrement;
        }
    }
    //  accumulator 2: sum(delta(interval(duration(years_preschool, 1))))
    {
        const int acc_index = 2; // accumulator index

        // Compute increment
        Time value_out = om_duration_FOR_years_preschool_X_1;
        auto& value_in = om_tabPreSchool_in_om_duration_FOR_years_preschool_X_1;

        double dIncrement;
        dIncrement = (double)value_out - (double)value_in;

        // Push increment to body cell and margin cells
        for (int cell : cells_to_increment) {
            auto& dAccumulator = table->acc[acc_index][cell];
            dAccumulator += dIncrement;
        }
    }
    //  accumulator 3: sum(delta(interval(duration(years_preschool, 2))))
    {
        const int acc_index = 3; // accumulator index

        // Compute increment
        Time value_out = om_duration_FOR_years_preschool_X_2;
        auto& value_in = om_tabPreSchool_in_om_duration_FOR_years_preschool_X_2;

        double dIncrement;
        dIncrement = (double)value_out - (double)value_in;

        // Push increment to body cell and margin cells
        for (int cell : cells_to_increment) {
            auto& dAccumulator = table->acc[acc_index][cell];
            dAccumulator += dIncrement;
        }
    }
}
int Person::om_tabStuntingSexRegMotherYob_current_cell()
{
    assert(thetabStuntingSexRegMotherYob); // unitary table must be instantiated

    // Dimensionality of table (does not include measure dimension)
    const size_t rank = 4;

    // Size of each dimension of table (includes margin if present)
    const std::array<size_t, rank> shape = {3, 4, 6, 151};

    // Dimension coordinates of current cell
    const std::array<size_t, rank> coordinates = {
        size_t(sex), 
        size_t(educ_mother), 
        size_t(region_nat), 
        size_t(sim_year - 2000), 
    };

    // Encode the dimension coordinates of the margin cell into flattened index
    size_t cell = coordinates[0];
    for (size_t j = 1; j < rank; ++j) {
        cell *= shape[j];
        cell += coordinates[j];
    }

    assert(cell >= 0 && cell < 10872); // logic guarantee
    return cell;
}
void Person::om_tabStuntingSexRegMotherYob_init_increment(int pending, big_counter pending_event_counter)
{
    assert(thetabStuntingSexRegMotherYob); // unitary table must be instantiated

    {
        // interval(is_stunted)
        auto & value_in = om_tabStuntingSexRegMotherYob_in_is_stunted;
        bool value_curr = is_stunted;

        value_in = value_curr;
    }
}
void Person::om_tabStuntingSexRegMotherYob_push_increment(int cell_in, int pending, big_counter pending_event_counter)
{
    assert(thetabStuntingSexRegMotherYob); // unitary table must be instantiated

    auto& table = thetabStuntingSexRegMotherYob;

    // Table has margins

    // Dimensionality of table (does not include measure dimension)
    const size_t rank = 4;

    // Size of each dimension of table (includes margin if present)
    const std::array<size_t, rank> shape = {3, 4, 6, 151};

    // Number of dimensions with a margin
    const size_t margin_count = 3;

    // Dimensions with a margin
    const std::array<size_t, margin_count> margin_dims = {0, 1, 2};

    // Number of margin combinations for a cell in the table body
    // e.g. a table with 3 margins has 2^3-1=7 margin cells associated with a body cell
    const size_t margin_combos = (1 << margin_count) - 1;

    // Indexes of table cells to increment (cell in table body and cells in margins)
    std::array<size_t, 1 + margin_combos> cells_to_increment;

    // Populate cells_to_increment

    // The cell in the table body:
    cells_to_increment[0] = cell_in;

    // The margin cells
    {
        // Dimension coordinates of the body cell being incremented
        std::array<size_t, rank> body_coordinates;
        // Decode dimension coordinates of the body cell
        for (int j = rank - 1, w = cell_in; j >= 0; --j) {
            body_coordinates[j] = w % shape[j];
            w /= shape[j];
        }
        // Working coordinates of a margin cell
        std::array<size_t, rank> margin_coordinates;
        for (size_t combo = 1; combo <= margin_combos; ++combo) {
            // The binary bits of combo select the margin dimensions for the combination.
            margin_coordinates = body_coordinates;
            size_t bits = combo;
            for (size_t margin = 0; margin < margin_count; ++margin) {
                // read out the bits in combo
                if (bits & 1) {
                    // low order bit is 1, so replace coordinate from body cell by margin coordinate
                    margin_coordinates[margin_dims[margin]] = shape[margin_dims[margin]] - 1;
                }
                bits >>= 1;
            }
            // Encode the dimension coordinates of the margin cell into flattened index
            size_t margin_cell = margin_coordinates[0];
            for (size_t j = 1; j < rank; ++j) {
                margin_cell *= shape[j];
                margin_cell += margin_coordinates[j];
            }
            assert(margin_cell >= 0 && margin_cell < 10872); // logic guarantee
            cells_to_increment[combo] = margin_cell;
        }
    }

    // Increments and Accumulators:
    //  accumulator 0: sum(value_in(interval(is_stunted)))
    {
        const int acc_index = 0; // accumulator index

        // Compute increment
        auto& value_in = om_tabStuntingSexRegMotherYob_in_is_stunted;

        double dIncrement;
        dIncrement = value_in;

        // Push increment to body cell and margin cells
        for (int cell : cells_to_increment) {
            auto& dAccumulator = table->acc[acc_index][cell];
            dAccumulator += dIncrement;
        }
    }
    //  accumulator 1: unit
    {
        const int acc_index = 1; // accumulator index

        // Compute increment

        double dIncrement;
        dIncrement = 1.0;

        // Push increment to body cell and margin cells
        for (int cell : cells_to_increment) {
            auto& dAccumulator = table->acc[acc_index][cell];
            dAccumulator += dIncrement;
        }
    }
}
int Person::om_tabStuntingSexRegYob_current_cell()
{
    assert(thetabStuntingSexRegYob); // unitary table must be instantiated

    // Dimensionality of table (does not include measure dimension)
    const size_t rank = 2;

    // Size of each dimension of table (includes margin if present)
    const std::array<size_t, rank> shape = {6, 151};

    // Dimension coordinates of current cell
    const std::array<size_t, rank> coordinates = {
        size_t(region_nat), 
        size_t(sim_year - 2000), 
    };

    // Encode the dimension coordinates of the margin cell into flattened index
    size_t cell = coordinates[0];
    for (size_t j = 1; j < rank; ++j) {
        cell *= shape[j];
        cell += coordinates[j];
    }

    assert(cell >= 0 && cell < 906); // logic guarantee
    return cell;
}
void Person::om_tabStuntingSexRegYob_init_increment(int pending, big_counter pending_event_counter)
{
    assert(thetabStuntingSexRegYob); // unitary table must be instantiated

    {
        // interval(is_stunted)
        auto & value_in = om_tabStuntingSexRegYob_in_is_stunted;
        bool value_curr = is_stunted;

        value_in = value_curr;
    }
}
void Person::om_tabStuntingSexRegYob_push_increment(int cell_in, int pending, big_counter pending_event_counter)
{
    assert(thetabStuntingSexRegYob); // unitary table must be instantiated

    auto& table = thetabStuntingSexRegYob;

    // Table has margins

    // Dimensionality of table (does not include measure dimension)
    const size_t rank = 2;

    // Size of each dimension of table (includes margin if present)
    const std::array<size_t, rank> shape = {6, 151};

    // Number of dimensions with a margin
    const size_t margin_count = 1;

    // Dimensions with a margin
    const std::array<size_t, margin_count> margin_dims = {0};

    // Number of margin combinations for a cell in the table body
    // e.g. a table with 3 margins has 2^3-1=7 margin cells associated with a body cell
    const size_t margin_combos = (1 << margin_count) - 1;

    // Indexes of table cells to increment (cell in table body and cells in margins)
    std::array<size_t, 1 + margin_combos> cells_to_increment;

    // Populate cells_to_increment

    // The cell in the table body:
    cells_to_increment[0] = cell_in;

    // The margin cells
    {
        // Dimension coordinates of the body cell being incremented
        std::array<size_t, rank> body_coordinates;
        // Decode dimension coordinates of the body cell
        for (int j = rank - 1, w = cell_in; j >= 0; --j) {
            body_coordinates[j] = w % shape[j];
            w /= shape[j];
        }
        // Working coordinates of a margin cell
        std::array<size_t, rank> margin_coordinates;
        for (size_t combo = 1; combo <= margin_combos; ++combo) {
            // The binary bits of combo select the margin dimensions for the combination.
            margin_coordinates = body_coordinates;
            size_t bits = combo;
            for (size_t margin = 0; margin < margin_count; ++margin) {
                // read out the bits in combo
                if (bits & 1) {
                    // low order bit is 1, so replace coordinate from body cell by margin coordinate
                    margin_coordinates[margin_dims[margin]] = shape[margin_dims[margin]] - 1;
                }
                bits >>= 1;
            }
            // Encode the dimension coordinates of the margin cell into flattened index
            size_t margin_cell = margin_coordinates[0];
            for (size_t j = 1; j < rank; ++j) {
                margin_cell *= shape[j];
                margin_cell += margin_coordinates[j];
            }
            assert(margin_cell >= 0 && margin_cell < 906); // logic guarantee
            cells_to_increment[combo] = margin_cell;
        }
    }

    // Increments and Accumulators:
    //  accumulator 0: sum(value_in(interval(is_stunted)))
    {
        const int acc_index = 0; // accumulator index

        // Compute increment
        auto& value_in = om_tabStuntingSexRegYob_in_is_stunted;

        double dIncrement;
        dIncrement = value_in;

        // Push increment to body cell and margin cells
        for (int cell : cells_to_increment) {
            auto& dAccumulator = table->acc[acc_index][cell];
            dAccumulator += dIncrement;
        }
    }
    //  accumulator 1: unit
    {
        const int acc_index = 1; // accumulator index

        // Compute increment

        double dIncrement;
        dIncrement = 1.0;

        // Push increment to body cell and margin cells
        for (int cell : cells_to_increment) {
            auto& dAccumulator = table->acc[acc_index][cell];
            dAccumulator += dIncrement;
        }
    }
}
void Person::region_birth_update_identity()
{
    #line 59 "../code/MigrationGeneral.mpp"
    region_birth.set(om_aggregate_FOR_geo_birth_X_REGION_INT);
}
#line 18508 "C:/Users/Martin/Dropbox/openM++/models/Dynamis-Pop-3-06-ABC/ompp/src/om_definitions.cpp"
void Person::region_int_update_identity()
{
    #line 57 "../code/MigrationGeneral.mpp"
    region_int.set(om_aggregate_FOR_geo_X_REGION_INT);
}
#line 18514 "C:/Users/Martin/Dropbox/openM++/models/Dynamis-Pop-3-06-ABC/ompp/src/om_definitions.cpp"
void Person::region_nat_update_identity()
{
    #line 58 "../code/MigrationGeneral.mpp"
    region_nat.set(om_aggregate_FOR_region_int_X_REGION_NAT);
}
#line 18520 "C:/Users/Martin/Dropbox/openM++/models/Dynamis-Pop-3-06-ABC/ompp/src/om_definitions.cpp"
void Person::sel_years_update_identity()
{
    #line 39 "../code/_ContextABC.mpp"
    sel_years.set(((calendar_year == 2000) ? TSY_2000 : ((calendar_year == 2010) ? TSY_2010 : ((calendar_year == 2020) ? TSY_2020 : ((calendar_year == 2030) ? TSY_2030 : ((calendar_year == 2040) ? TSY_2040 : ((calendar_year == 2050) ? TSY_2050 : TSY_2060)))))));
}
#line 18526 "C:/Users/Martin/Dropbox/openM++/models/Dynamis-Pop-3-06-ABC/ompp/src/om_definitions.cpp"
void Person::selected_year10_update_identity()
{
    #line 27 "../code/TablesPopulation.mpp"
    selected_year10.set(((calendar_year == MIN(SIM_YEAR_RANGE)) ? SY00 : ((calendar_year == (MIN(SIM_YEAR_RANGE) + 10)) ? SY10 : ((calendar_year == (MIN(SIM_YEAR_RANGE) + 20)) ? SY20 : ((calendar_year == (MIN(SIM_YEAR_RANGE) + 30)) ? SY30 : SY40)))));
}
#line 18532 "C:/Users/Martin/Dropbox/openM++/models/Dynamis-Pop-3-06-ABC/ompp/src/om_definitions.cpp"
void Person::sim_year_update_identity()
{
    #line 24 "../code/TablesPopulation.mpp"
    sim_year.set(COERCE(SIM_YEAR_RANGE, calendar_year));
}
#line 18538 "C:/Users/Martin/Dropbox/openM++/models/Dynamis-Pop-3-06-ABC/ompp/src/om_definitions.cpp"
void Person::spouse_group_update_identity()
{
    #line 86 "../code/FamilyPartnerMatching.mpp"
    spouse_group.set(((has_spouse && (lSpouse->educ_one_fate == EOL_HIGH)) ? SMG_02 : ((has_spouse && (lSpouse->educ_one_fate == EOL_MEDIUM)) ? SMG_01 : SMG_00)));
}
#line 18544 "C:/Users/Martin/Dropbox/openM++/models/Dynamis-Pop-3-06-ABC/ompp/src/om_definitions.cpp"
void Person::survived_early_years_update_identity()
{
    #line 97 "../code/HumanCapitalIndex.mpp"
    survived_early_years.set(((integer_age >= 5) ? true : false));
}
#line 18550 "C:/Users/Martin/Dropbox/openM++/models/Dynamis-Pop-3-06-ABC/ompp/src/om_definitions.cpp"
void Person::tab_out_of_primary_update_identity()
{
    #line 28 "../code/TablesEducation.mpp"
    tab_out_of_primary.set((((educ_one_status != EOS_WAIT) && (educ_one_status != EOS_ATTEND)) && !has_passed_primary));
}
#line 18556 "C:/Users/Martin/Dropbox/openM++/models/Dynamis-Pop-3-06-ABC/ompp/src/om_definitions.cpp"
void Person::tab_sim_yob_update_identity()
{
    #line 19 "../code/TablesEducation.mpp"
    tab_sim_yob.set(COERCE(SIM_YEAR_RANGE, year_of_birth));
}
#line 18562 "C:/Users/Martin/Dropbox/openM++/models/Dynamis-Pop-3-06-ABC/ompp/src/om_definitions.cpp"
void Person::time_in_parity_update_identity()
{
    #line 103 "../code/FertilityDetailed.mpp"
    time_in_parity.set(om_self_scheduling_split_FOR_om_active_spell_duration_FOR_this_parity_spell_X_true_X_DUR_TIME_IN_PARITY);
}
#line 18568 "C:/Users/Martin/Dropbox/openM++/models/Dynamis-Pop-3-06-ABC/ompp/src/om_definitions.cpp"
void Person::union1_group_update_identity()
{
    #line 88 "../code/FamilyFirstUnion.mpp"
    union1_group.set(((educ_one_fate == EOL_LOW) ? U1G_00 : ((educ_one_fate == EOL_MEDIUM) ? U1G_01 : U1G_02)));
}
#line 18574 "C:/Users/Martin/Dropbox/openM++/models/Dynamis-Pop-3-06-ABC/ompp/src/om_definitions.cpp"
void Person::year_of_birth_update_identity()
{
    #line 88 "../code/ActorPerson.mpp"
    year_of_birth.set(COERCE(ALL_YEAR_RANGE, int(time_of_birth)));
}
#line 18580 "C:/Users/Martin/Dropbox/openM++/models/Dynamis-Pop-3-06-ABC/ompp/src/om_definitions.cpp"
void Person::year_of_first_immigration_update_identity()
{
    #line 52 "../code/ImmigrationFromScratch.mpp"
    year_of_first_immigration.set(COERCE(SIM_YEAR_RANGE, int(time_of_first_immigration)));
}
#line 18586 "C:/Users/Martin/Dropbox/openM++/models/Dynamis-Pop-3-06-ABC/ompp/src/om_definitions.cpp"
void Person::years_of_schooling_update_identity()
{
    #line 85 "../code/HumanCapitalIndex.mpp"
    years_of_schooling.set(((years_preschool + educ_one_grade_passed) + educ_two_grade_passed));
}
#line 18592 "C:/Users/Martin/Dropbox/openM++/models/Dynamis-Pop-3-06-ABC/ompp/src/om_definitions.cpp"
const std::string Person::om_name_om_PopPyramidByEduc_incr = "Increment for table PopPyramidByEduc";
const std::string Person::om_name_om_TabChildVaccination_incr = "Increment for table TabChildVaccination";
const std::string Person::om_name_om_TabEduc15ByDistrict_incr = "Increment for table TabEduc15ByDistrict";
const std::string Person::om_name_om_TabEduc15ByDistrictBirth_incr = "Increment for table TabEduc15ByDistrictBirth";
const std::string Person::om_name_om_TabEducFateByGroup_incr = "Increment for table TabEducFateByGroup";
const std::string Person::om_name_om_TabEducFateDistrYob_incr = "Increment for table TabEducFateDistrYob";
const std::string Person::om_name_om_TabHCIDistrict_incr = "Increment for table TabHCIDistrict";
const std::string Person::om_name_om_TabImmunizationChildren_incr = "Increment for table TabImmunizationChildren";
const std::string Person::om_name_om_TabPopProvAgeEducSex_incr = "Increment for table TabPopProvAgeEducSex";
const std::string Person::om_name_om_TabPrenatCare_incr = "Increment for table TabPrenatCare";
const std::string Person::om_name_om_TabPrimSchoolEntries_incr = "Increment for table TabPrimSchoolEntries";
const std::string Person::om_name_om_TabPrimSchoolGraduations_incr = "Increment for table TabPrimSchoolGraduations";
const std::string Person::om_name_om_TabPrimSchoolOutOfSchool9to11_incr = "Increment for table TabPrimSchoolOutOfSchool9to11";
const std::string Person::om_name_om_TabPrimarySchoolPlanning_incr = "Increment for table TabPrimarySchoolPlanning";
const std::string Person::om_name_om_TabSchool2AttainmentsTab_incr = "Increment for table TabSchool2AttainmentsTab";
const std::string Person::om_name_om_TabSchool2TrackTab_incr = "Increment for table TabSchool2TrackTab";
const std::string Person::om_name_om_tabBirthsYearPlace_incr = "Increment for table tabBirthsYearPlace";
const std::string Person::om_name_om_tabEducationFateGeobirYob_incr = "Increment for table tabEducationFateGeobirYob";
const std::string Person::om_name_om_tabHCI_incr = "Increment for table tabHCI";
const std::string Person::om_name_om_tabHavingSpouse_incr = "Increment for table tabHavingSpouse";
const std::string Person::om_name_om_tabMigrationOriginDestination_incr = "Increment for table tabMigrationOriginDestination";
const std::string Person::om_name_om_tabPopulationYearPlace_incr = "Increment for table tabPopulationYearPlace";
const std::string Person::om_name_om_tabPreSchool_incr = "Increment for table tabPreSchool";
const std::string Person::om_name_om_tabStuntingSexRegMotherYob_incr = "Increment for table tabStuntingSexRegMotherYob";
const std::string Person::om_name_om_tabStuntingSexRegYob_incr = "Increment for table tabStuntingSexRegYob";

const std::string Person::om_name_adult_survival = "adult_survival";
const std::string Person::om_name_age = "age";
const std::string Person::om_name_age_last_birth = "age_last_birth";
const std::string Person::om_name_age_mig = "age_mig";
const std::string Person::om_name_age_youngest_child = "age_youngest_child";
const std::string Person::om_name_all_year = "all_year";
const std::string Person::om_name_calendar_year = "calendar_year";
const std::string Person::om_name_case_seed = "case_seed";
const std::string Person::om_name_child_agegr = "child_agegr";
const std::string Person::om_name_child_agegr_part = "child_agegr_part";
const std::string Person::om_name_child_mortality = "child_mortality";
const std::string Person::om_name_child_mortality_group = "child_mortality_group";
const std::string Person::om_name_children_in_household = "children_in_household";
const std::string Person::om_name_creation_type = "creation_type";
const std::string Person::om_name_educ1_group = "educ1_group";
const std::string Person::om_name_educ_mother = "educ_mother";
const std::string Person::om_name_educ_one_entry_age = "educ_one_entry_age";
const std::string Person::om_name_educ_one_fate = "educ_one_fate";
const std::string Person::om_name_educ_one_geo = "educ_one_geo";
const std::string Person::om_name_educ_one_grade = "educ_one_grade";
const std::string Person::om_name_educ_one_grade_attended = "educ_one_grade_attended";
const std::string Person::om_name_educ_one_grade_fate = "educ_one_grade_fate";
const std::string Person::om_name_educ_one_grade_passed = "educ_one_grade_passed";
const std::string Person::om_name_educ_one_group = "educ_one_group";
const std::string Person::om_name_educ_one_level = "educ_one_level";
const std::string Person::om_name_educ_one_required_rooms = "educ_one_required_rooms";
const std::string Person::om_name_educ_one_required_teachers = "educ_one_required_teachers";
const std::string Person::om_name_educ_one_status = "educ_one_status";
const std::string Person::om_name_educ_one_to_process = "educ_one_to_process";
const std::string Person::om_name_educ_two_delay = "educ_two_delay";
const std::string Person::om_name_educ_two_geo = "educ_two_geo";
const std::string Person::om_name_educ_two_grade_attended = "educ_two_grade_attended";
const std::string Person::om_name_educ_two_grade_passed = "educ_two_grade_passed";
const std::string Person::om_name_educ_two_group = "educ_two_group";
const std::string Person::om_name_educ_two_level = "educ_two_level";
const std::string Person::om_name_educ_two_status = "educ_two_status";
const std::string Person::om_name_educ_two_to_process = "educ_two_to_process";
const std::string Person::om_name_entity_id = "entity_id";
const std::string Person::om_name_ethnicity = "ethnicity";
const std::string Person::om_name_ethnicity_short = "ethnicity_short";
const std::string Person::om_name_events = "events";
const std::string Person::om_name_ever_resident = "ever_resident";
const std::string Person::om_name_ever_union = "ever_union";
const std::string Person::om_name_family_role = "family_role";
const std::string Person::om_name_female_spouse_age = "female_spouse_age";
const std::string Person::om_name_fertile_age = "fertile_age";
const std::string Person::om_name_first_move_done = "first_move_done";
const std::string Person::om_name_geo = "geo";
const std::string Person::om_name_geo_birth = "geo_birth";
const std::string Person::om_name_geo_nat = "geo_nat";
const std::string Person::om_name_geo_prev = "geo_prev";
const std::string Person::om_name_geo_want_to_move = "geo_want_to_move";
const std::string Person::om_name_got_prenat_care = "got_prenat_care";
const std::string Person::om_name_has_passed_primary = "has_passed_primary";
const std::string Person::om_name_has_spouse = "has_spouse";
const std::string Person::om_name_in_hci_sample = "in_hci_sample";
const std::string Person::om_name_in_projected_time = "in_projected_time";
const std::string Person::om_name_in_sel_years = "in_sel_years";
const std::string Person::om_name_in_selected_year = "in_selected_year";
const std::string Person::om_name_ind_hci = "ind_hci";
const std::string Person::om_name_integer_age = "integer_age";
const std::string Person::om_name_is_aded0 = "is_aded0";
const std::string Person::om_name_is_aded1 = "is_aded1";
const std::string Person::om_name_is_aded2 = "is_aded2";
const std::string Person::om_name_is_adult = "is_adult";
const std::string Person::om_name_is_alive = "is_alive";
const std::string Person::om_name_is_blocked_from_marriage = "is_blocked_from_marriage";
const std::string Person::om_name_is_child = "is_child";
const std::string Person::om_name_is_educ_one_student = "is_educ_one_student";
const std::string Person::om_name_is_fertile = "is_fertile";
const std::string Person::om_name_is_immunized = "is_immunized";
const std::string Person::om_name_is_mortal = "is_mortal";
const std::string Person::om_name_is_old = "is_old";
const std::string Person::om_name_is_ready_for_birthtables = "is_ready_for_birthtables";
const std::string Person::om_name_is_resident = "is_resident";
const std::string Person::om_name_is_stunted = "is_stunted";
const std::string Person::om_name_lBioFather = "lBioFather";
const std::string Person::om_name_lBioMother = "lBioMother";
const std::string Person::om_name_lCalibrator = "lCalibrator";
const std::string Person::om_name_lHHFather = "lHHFather";
const std::string Person::om_name_lHHMother = "lHHMother";
const std::string Person::om_name_lSpouse = "lSpouse";
const std::string Person::om_name_lStartValues = "lStartValues";
const std::string Person::om_name_lives_with_dependent_child = "lives_with_dependent_child";
const std::string Person::om_name_male_age = "male_age";
const std::string Person::om_name_male_spouse_age = "male_spouse_age";
const std::string Person::om_name_moth_agegr = "moth_agegr";
const std::string Person::om_name_moth_agegr_part = "moth_agegr_part";
const std::string Person::om_name_mother_age_at_birth = "mother_age_at_birth";
const std::string Person::om_name_om_active_spell_duration_FOR_this_parity_spell_X_true = "active_spell_duration(this_parity_spell, true)";
const std::string Person::om_name_om_aggregate_FOR_ethnicity_X_ETHNICITY_SHORT = "aggregate(ethnicity, ETHNICITY_SHORT)";
const std::string Person::om_name_om_aggregate_FOR_geo_X_GEO_NAT = "aggregate(geo, GEO_NAT)";
const std::string Person::om_name_om_aggregate_FOR_geo_X_REGION_INT = "aggregate(geo, REGION_INT)";
const std::string Person::om_name_om_aggregate_FOR_geo_birth_X_GEO_NAT = "aggregate(geo_birth, GEO_NAT)";
const std::string Person::om_name_om_aggregate_FOR_geo_birth_X_REGION_INT = "aggregate(geo_birth, REGION_INT)";
const std::string Person::om_name_om_aggregate_FOR_region_birth_X_REGION_NAT = "aggregate(region_birth, REGION_NAT)";
const std::string Person::om_name_om_aggregate_FOR_region_int_X_REGION_NAT = "aggregate(region_int, REGION_NAT)";
const std::string Person::om_name_om_aia_0 = "om_aia_0";
const std::string Person::om_name_om_aia_1 = "om_aia_1";
const std::string Person::om_name_om_aia_10 = "om_aia_10";
const std::string Person::om_name_om_aia_11 = "om_aia_11";
const std::string Person::om_name_om_aia_12 = "om_aia_12";
const std::string Person::om_name_om_aia_13 = "om_aia_13";
const std::string Person::om_name_om_aia_14 = "om_aia_14";
const std::string Person::om_name_om_aia_15 = "om_aia_15";
const std::string Person::om_name_om_aia_16 = "om_aia_16";
const std::string Person::om_name_om_aia_17 = "om_aia_17";
const std::string Person::om_name_om_aia_18 = "om_aia_18";
const std::string Person::om_name_om_aia_19 = "om_aia_19";
const std::string Person::om_name_om_aia_2 = "om_aia_2";
const std::string Person::om_name_om_aia_20 = "om_aia_20";
const std::string Person::om_name_om_aia_21 = "om_aia_21";
const std::string Person::om_name_om_aia_22 = "om_aia_22";
const std::string Person::om_name_om_aia_23 = "om_aia_23";
const std::string Person::om_name_om_aia_24 = "om_aia_24";
const std::string Person::om_name_om_aia_25 = "om_aia_25";
const std::string Person::om_name_om_aia_26 = "om_aia_26";
const std::string Person::om_name_om_aia_27 = "om_aia_27";
const std::string Person::om_name_om_aia_28 = "om_aia_28";
const std::string Person::om_name_om_aia_29 = "om_aia_29";
const std::string Person::om_name_om_aia_3 = "om_aia_3";
const std::string Person::om_name_om_aia_30 = "om_aia_30";
const std::string Person::om_name_om_aia_31 = "om_aia_31";
const std::string Person::om_name_om_aia_32 = "om_aia_32";
const std::string Person::om_name_om_aia_33 = "om_aia_33";
const std::string Person::om_name_om_aia_34 = "om_aia_34";
const std::string Person::om_name_om_aia_35 = "om_aia_35";
const std::string Person::om_name_om_aia_36 = "om_aia_36";
const std::string Person::om_name_om_aia_37 = "om_aia_37";
const std::string Person::om_name_om_aia_38 = "om_aia_38";
const std::string Person::om_name_om_aia_39 = "om_aia_39";
const std::string Person::om_name_om_aia_4 = "om_aia_4";
const std::string Person::om_name_om_aia_40 = "om_aia_40";
const std::string Person::om_name_om_aia_5 = "om_aia_5";
const std::string Person::om_name_om_aia_6 = "om_aia_6";
const std::string Person::om_name_om_aia_7 = "om_aia_7";
const std::string Person::om_name_om_aia_8 = "om_aia_8";
const std::string Person::om_name_om_aia_9 = "om_aia_9";
const std::string Person::om_name_om_asAllFertilePersonsForFertilityAlignmentByAge_filter = "om_asAllFertilePersonsForFertilityAlignmentByAge_filter";
const std::string Person::om_name_om_asAllFertilePersonsForFertilityAlignment_filter = "om_asAllFertilePersonsForFertilityAlignment_filter";
const std::string Person::om_name_om_asAllPerson_filter = "om_asAllPerson_filter";
const std::string Person::om_name_om_asAvailableMaleByTypeImmiScratch_filter = "om_asAvailableMaleByTypeImmiScratch_filter";
const std::string Person::om_name_om_asAvailableMaleByType_filter = "om_asAvailableMaleByType_filter";
const std::string Person::om_name_om_asAvailableMaleImmiScratch_filter = "om_asAvailableMaleImmiScratch_filter";
const std::string Person::om_name_om_asAvailableMale_filter = "om_asAvailableMale_filter";
const std::string Person::om_name_om_asFemaleInUnionByAgeAndPartnerAgeImmiScratch_filter = "om_asFemaleInUnionByAgeAndPartnerAgeImmiScratch_filter";
const std::string Person::om_name_om_asFemaleInUnionByAgeAndPartnerAge_filter = "om_asFemaleInUnionByAgeAndPartnerAge_filter";
const std::string Person::om_name_om_asPotentialImmigrantMothers_filter = "om_asPotentialImmigrantMothers_filter";
const std::string Person::om_name_om_asPotentialSchoolOneStudentToProcess_filter = "om_asPotentialSchoolOneStudentToProcess_filter";
const std::string Person::om_name_om_asPotentialSchoolOneStudent_filter = "om_asPotentialSchoolOneStudent_filter";
const std::string Person::om_name_om_asPotentialSchoolTwoStudentToProcess_filter = "om_asPotentialSchoolTwoStudentToProcess_filter";
const std::string Person::om_name_om_asPotentialSchoolTwoStudent_filter = "om_asPotentialSchoolTwoStudent_filter";
const std::string Person::om_name_om_asResidentBabies_filter = "om_asResidentBabies_filter";
const std::string Person::om_name_om_asResidentsAge0SexGeo_filter = "om_asResidentsAge0SexGeo_filter";
const std::string Person::om_name_om_asResidentsAge0Sex_filter = "om_asResidentsAge0Sex_filter";
const std::string Person::om_name_om_asSimBornAge0_filter = "om_asSimBornAge0_filter";
const std::string Person::om_name_om_asWantToMove_filter = "om_asWantToMove_filter";
const std::string Person::om_name_om_asWomenNoChildren_filter = "om_asWomenNoChildren_filter";
const std::string Person::om_name_om_asWomenWithChildren_filter = "om_asWomenWithChildren_filter";
const std::string Person::om_name_om_duration = "duration()";
const std::string Person::om_name_om_duration_FOR_educ_one_fate_X_EOL_HIGH = "duration(educ_one_fate, EOL_HIGH)";
const std::string Person::om_name_om_duration_FOR_educ_one_fate_X_EOL_LOW = "duration(educ_one_fate, EOL_LOW)";
const std::string Person::om_name_om_duration_FOR_educ_one_fate_X_EOL_MEDIUM = "duration(educ_one_fate, EOL_MEDIUM)";
const std::string Person::om_name_om_duration_FOR_educ_one_level_X_EOL_HIGH = "duration(educ_one_level, EOL_HIGH)";
const std::string Person::om_name_om_duration_FOR_educ_one_level_X_EOL_LOW = "duration(educ_one_level, EOL_LOW)";
const std::string Person::om_name_om_duration_FOR_educ_one_level_X_EOL_MEDIUM = "duration(educ_one_level, EOL_MEDIUM)";
const std::string Person::om_name_om_duration_FOR_educ_two_level_X_ETL_GRADUATE = "duration(educ_two_level, ETL_GRADUATE)";
const std::string Person::om_name_om_duration_FOR_educ_two_level_X_ETL_INCOMPLETE = "duration(educ_two_level, ETL_INCOMPLETE)";
const std::string Person::om_name_om_duration_FOR_educ_two_level_X_ETL_NEVER = "duration(educ_two_level, ETL_NEVER)";
const std::string Person::om_name_om_duration_FOR_ever_union_X_true = "duration(ever_union, true)";
const std::string Person::om_name_om_duration_FOR_got_prenat_care_X_GPC_YES = "duration(got_prenat_care, GPC_YES)";
const std::string Person::om_name_om_duration_FOR_has_spouse_X_true = "duration(has_spouse, true)";
const std::string Person::om_name_om_duration_FOR_is_aded0_X_true = "duration(is_aded0, true)";
const std::string Person::om_name_om_duration_FOR_is_aded1_X_true = "duration(is_aded1, true)";
const std::string Person::om_name_om_duration_FOR_is_aded2_X_true = "duration(is_aded2, true)";
const std::string Person::om_name_om_duration_FOR_is_child_X_true = "duration(is_child, true)";
const std::string Person::om_name_om_duration_FOR_is_immunized_X_true = "duration(is_immunized, true)";
const std::string Person::om_name_om_duration_FOR_is_old_X_true = "duration(is_old, true)";
const std::string Person::om_name_om_duration_FOR_tab_out_of_primary_X_true = "duration(tab_out_of_primary, true)";
const std::string Person::om_name_om_duration_FOR_years_preschool_X_0 = "duration(years_preschool, 0)";
const std::string Person::om_name_om_duration_FOR_years_preschool_X_1 = "duration(years_preschool, 1)";
const std::string Person::om_name_om_duration_FOR_years_preschool_X_2 = "duration(years_preschool, 2)";
const std::string Person::om_name_om_entrances_FOR_educ_one_grade_attended_X_1 = "entrances(educ_one_grade_attended, 1)";
const std::string Person::om_name_om_entrances_FOR_has_passed_primary_X_true = "entrances(has_passed_primary, true)";
const std::string Person::om_name_om_mlHHFatherChildren_count = "om_mlHHFatherChildren_count";
const std::string Person::om_name_om_mlHHFatherChildren_sum_over_is_alive = "om_mlHHFatherChildren_sum_over_is_alive";
const std::string Person::om_name_om_mlHHMotherChildren_count = "om_mlHHMotherChildren_count";
const std::string Person::om_name_om_mlHHMotherChildren_min_over_integer_age = "om_mlHHMotherChildren_min_over_integer_age";
const std::string Person::om_name_om_mlHHMotherChildren_sum_over_is_alive = "om_mlHHMotherChildren_sum_over_is_alive";
const std::string Person::om_name_om_self_scheduling_split_FOR_age_X_AGE_MIG_PART = "self_scheduling_split(age, AGE_MIG_PART)";
const std::string Person::om_name_om_self_scheduling_split_FOR_om_active_spell_duration_FOR_this_parity_spell_X_true_X_DUR_TIME_IN_PARITY = "self_scheduling_split(active_spell_duration(this_parity_spell, true), DUR_TIME_IN_PARITY)";
const std::string Person::om_name_om_split_FOR_age_last_birth_X_MOTH_AGEGR_PART = "split(age_last_birth, MOTH_AGEGR_PART)";
const std::string Person::om_name_om_split_FOR_age_youngest_child_X_CHILD_AGEGR_PART = "split(age_youngest_child, CHILD_AGEGR_PART)";
const std::string Person::om_name_om_split_FOR_integer_age_X_TAB_AGEC5 = "split(integer_age, TAB_AGEC5)";
const std::string Person::om_name_om_transitions_FOR_integer_age_X_14_X_15 = "transitions(integer_age, 14, 15)";
const std::string Person::om_name_om_transitions_FOR_is_alive_X_false_X_true = "transitions(is_alive, false, true)";
const std::string Person::om_name_om_transitions_FOR_is_alive_X_true_X_false = "transitions(is_alive, true, false)";
const std::string Person::om_name_om_transitions_FOR_survived_early_years_X_false_X_true = "transitions(survived_early_years, false, true)";
const std::string Person::om_name_om_trigger_changes_FOR_calendar_year = "trigger_changes(calendar_year)";
const std::string Person::om_name_om_trigger_changes_FOR_geo = "trigger_changes(geo)";
const std::string Person::om_name_om_trigger_entrances_FOR_is_ready_for_birthtables_X_true = "trigger_entrances(is_ready_for_birthtables, true)";
const std::string Person::om_name_om_value_at_transitions_FOR_is_alive_X_true_X_adult_survival_X_false = "value_at_transitions(is_alive, true, false, adult_survival)";
const std::string Person::om_name_om_value_at_transitions_FOR_is_alive_X_true_X_ind_hci_X_false = "value_at_transitions(is_alive, true, false, ind_hci)";
const std::string Person::om_name_om_value_at_transitions_FOR_is_alive_X_true_X_is_stunted_X_false = "value_at_transitions(is_alive, true, false, is_stunted)";
const std::string Person::om_name_om_value_at_transitions_FOR_is_alive_X_true_X_quality_of_schooling_X_false = "value_at_transitions(is_alive, true, false, quality_of_schooling)";
const std::string Person::om_name_om_value_at_transitions_FOR_is_alive_X_true_X_survived_early_years_X_false = "value_at_transitions(is_alive, true, false, survived_early_years)";
const std::string Person::om_name_om_value_at_transitions_FOR_is_alive_X_true_X_years_of_schooling_X_false = "value_at_transitions(is_alive, true, false, years_of_schooling)";
const std::string Person::om_name_parity = "parity";
const std::string Person::om_name_preschool_is_decided = "preschool_is_decided";
const std::string Person::om_name_quality_adjusted_schooling = "quality_adjusted_schooling";
const std::string Person::om_name_quality_of_schooling = "quality_of_schooling";
const std::string Person::om_name_ready_to_set_alive = "ready_to_set_alive";
const std::string Person::om_name_region_birth = "region_birth";
const std::string Person::om_name_region_int = "region_int";
const std::string Person::om_name_region_nat = "region_nat";
const std::string Person::om_name_sel_years = "sel_years";
const std::string Person::om_name_selected_year10 = "selected_year10";
const std::string Person::om_name_sex = "sex";
const std::string Person::om_name_sim_year = "sim_year";
const std::string Person::om_name_spouse_group = "spouse_group";
const std::string Person::om_name_survived_early_years = "survived_early_years";
const std::string Person::om_name_tab_out_of_primary = "tab_out_of_primary";
const std::string Person::om_name_tab_sim_yob = "tab_sim_yob";
const std::string Person::om_name_this_parity_spell = "this_parity_spell";
const std::string Person::om_name_time = "time";
const std::string Person::om_name_time_first_move = "time_first_move";
const std::string Person::om_name_time_in_parity = "time_in_parity";
const std::string Person::om_name_time_last_move = "time_last_move";
const std::string Person::om_name_time_next_birthday = "time_next_birthday";
const std::string Person::om_name_time_of_birth = "time_of_birth";
const std::string Person::om_name_time_of_first_immigration = "time_of_first_immigration";
const std::string Person::om_name_union1_group = "union1_group";
const std::string Person::om_name_year_of_birth = "year_of_birth";
const std::string Person::om_name_year_of_first_immigration = "year_of_first_immigration";
const std::string Person::om_name_years_of_schooling = "years_of_schooling";
const std::string Person::om_name_years_preschool = "years_preschool";

// The definition of the static member Person
// used to retrieve (zero) values when dereferencing nullptr link attributes.
thread_local Person Person::om_null_agent;
void StartpopValues::age_agent(Time t)
{
    if (time < t) {
        // Age the entity forward to the given time.
        time.set(t);
    }
    else {
        // The entity is already older than the given time.
        // This is normal if another entity is 'catching up' to this entity in its own events.
        // It is a model error if the current event is in this entity,
        // since that implies that an event is trying to make time run backwards for this entity.
        // This condition is detected and handled outside of this function.
    }
}
Time StartpopValues::check_time(Time t)
{
    if (t < time) {
        std::stringstream ss;
        ss << std::setprecision(std::numeric_limits<long double>::digits10 + 1) // maximum precision
           << LT("error : time ") << std::showpoint << t
           << LT(" is earlier than current time ") << (double)time
           << LT(" in entity_id ") << entity_id
           << LT(" in simulation member ") << get_simulation_member()
           << LT(" with combined seed ") << get_combined_seed()
            ;
        throw openm::SimulationException(ss.str().c_str());
    }
    return t;
}
void StartpopValues::is_removeable_update_identity()
{
    #line 28 "../code/ActorStartpopValues.mpp"
    is_removeable.set(lPersonStartpop->is_mortal);
}
#line 18893 "C:/Users/Martin/Dropbox/openM++/models/Dynamis-Pop-3-06-ABC/ompp/src/om_definitions.cpp"
void StartpopValues::om_assign_member_offsets()
{
    age.offset_in_agent = (char *)&(this->age) - (char *)this;
    case_seed.offset_in_agent = (char *)&(this->case_seed) - (char *)this;
    entity_id.offset_in_agent = (char *)&(this->entity_id) - (char *)this;
    events.offset_in_agent = (char *)&(this->events) - (char *)this;
    is_activated.offset_in_agent = (char *)&(this->is_activated) - (char *)this;
    is_removeable.offset_in_agent = (char *)&(this->is_removeable) - (char *)this;
    is_set_first_union_clock.offset_in_agent = (char *)&(this->is_set_first_union_clock) - (char *)this;
    is_set_last_birth_clock.offset_in_agent = (char *)&(this->is_set_last_birth_clock) - (char *)this;
    is_set_residential_move_clock.offset_in_agent = (char *)&(this->is_set_residential_move_clock) - (char *)this;
    lPersonStartpop.offset_in_agent = (char *)&(this->lPersonStartpop) - (char *)this;
    om_FirstMoveEvent_om_event.offset_in_agent = (char *)&(this->om_FirstMoveEvent_om_event) - (char *)this;
    om_FirstUnionImputationEvent_om_event.offset_in_agent = (char *)&(this->om_FirstUnionImputationEvent_om_event) - (char *)this;
    om_LastBirthImputationEvent_om_event.offset_in_agent = (char *)&(this->om_LastBirthImputationEvent_om_event) - (char *)this;
    om_LastMoveEvent_om_event.offset_in_agent = (char *)&(this->om_LastMoveEvent_om_event) - (char *)this;
    om_SetFirstUnionClock_om_event.offset_in_agent = (char *)&(this->om_SetFirstUnionClock_om_event) - (char *)this;
    om_SetLastBirthClock_om_event.offset_in_agent = (char *)&(this->om_SetLastBirthClock_om_event) - (char *)this;
    om_SetResidentialMoveClock_om_event.offset_in_agent = (char *)&(this->om_SetResidentialMoveClock_om_event) - (char *)this;
    om_SuicideEvent_om_event.offset_in_agent = (char *)&(this->om_SuicideEvent_om_event) - (char *)this;
    scheduled_time_first_move.offset_in_agent = (char *)&(this->scheduled_time_first_move) - (char *)this;
    scheduled_time_last_move.offset_in_agent = (char *)&(this->scheduled_time_last_move) - (char *)this;
    time.offset_in_agent = (char *)&(this->time) - (char *)this;
    time_first_union_imputation.offset_in_agent = (char *)&(this->time_first_union_imputation) - (char *)this;
    time_last_birth_imputation.offset_in_agent = (char *)&(this->time_last_birth_imputation) - (char *)this;
}
void StartpopValues::om_check_starting_time()
{
    if (!std::isfinite((double)time)) {
        std::stringstream ss;
        ss << std::setprecision(std::numeric_limits<long double>::digits10 + 1) // maximum precision
           << std::showpoint // show decimal point
           << LT("error : invalid starting time ") << (double)time
           << LT(" in new ") << "StartpopValues"
           << LT(" with entity_id ") << entity_id
           << LT(" at global time ") << (double)BaseEvent::get_global_time()
           << LT(" in simulation member ") << get_simulation_member()
           << LT(" with combined seed ") << get_combined_seed()
            ;
        throw openm::SimulationException(ss.str().c_str());
    }
}
void StartpopValues::om_finalize_entity_sets()
{
}
void StartpopValues::om_finalize_events()
{
    om_FirstMoveEvent_om_event.make_zombie();
    om_FirstUnionImputationEvent_om_event.make_zombie();
    om_LastBirthImputationEvent_om_event.make_zombie();
    om_LastMoveEvent_om_event.make_zombie();
    om_SetFirstUnionClock_om_event.make_zombie();
    om_SetLastBirthClock_om_event.make_zombie();
    om_SetResidentialMoveClock_om_event.make_zombie();
    om_SuicideEvent_om_event.make_zombie();
}
void StartpopValues::om_finalize_links()
{
    lPersonStartpop.set(nullptr);
}
void StartpopValues::om_finalize_multilinks()
{
}
void StartpopValues::om_finalize_tables()
{
}
int StartpopValues::om_get_entity_id()
{
    return entity_id;
}
Time StartpopValues::om_get_time()
{
    return time.get();
}
void StartpopValues::om_initialize_data_members()
{
     // TODO EntityArrayMemberSymbol StartPopValue
    age.initialize( 0 );
    case_seed.initialize( 0.0 );
    entity_id.initialize( 0 );
    events.initialize( 0 );
    #line 22 "../code/ActorStartpopValues.mpp"
    is_activated.initialize( false );
    #line 28 "../code/ActorStartpopValues.mpp"
    is_removeable.initialize( false );
    #line 97 "../code/FamilyFirstUnion.mpp"
    is_set_first_union_clock.initialize( false );
    #line 60 "../code/FertilityGeneral.mpp"
    is_set_last_birth_clock.initialize( false );
    #line 66 "../code/MigrationGeneral.mpp"
    is_set_residential_move_clock.initialize( false );
    #line 14 "../code/ActorStartpopValues.mpp"
    lPersonStartpop.initialize( nullptr );
    #line 72 "../code/MigrationGeneral.mpp"
    om_FirstMoveEvent_om_event.initialize( time_infinite );
    #line 101 "../code/FamilyFirstUnion.mpp"
    om_FirstUnionImputationEvent_om_event.initialize( time_infinite );
    #line 64 "../code/FertilityGeneral.mpp"
    om_LastBirthImputationEvent_om_event.initialize( time_infinite );
    #line 73 "../code/MigrationGeneral.mpp"
    om_LastMoveEvent_om_event.initialize( time_infinite );
    #line 98 "../code/FamilyFirstUnion.mpp"
    om_SetFirstUnionClock_om_event.initialize( time_infinite );
    #line 61 "../code/FertilityGeneral.mpp"
    om_SetLastBirthClock_om_event.initialize( time_infinite );
    #line 67 "../code/MigrationGeneral.mpp"
    om_SetResidentialMoveClock_om_event.initialize( time_infinite );
    #line 29 "../code/ActorStartpopValues.mpp"
    om_SuicideEvent_om_event.initialize( time_infinite );
    #line 70 "../code/MigrationGeneral.mpp"
    scheduled_time_first_move.initialize( time_infinite );
    #line 71 "../code/MigrationGeneral.mpp"
    scheduled_time_last_move.initialize( time_infinite );
    time.initialize( 0 );
    #line 100 "../code/FamilyFirstUnion.mpp"
    time_first_union_imputation.initialize( time_infinite );
    #line 63 "../code/FertilityGeneral.mpp"
    time_last_birth_imputation.initialize( time_infinite );
}
#line 19013 "C:/Users/Martin/Dropbox/openM++/models/Dynamis-Pop-3-06-ABC/ompp/src/om_definitions.cpp"
void StartpopValues::om_initialize_data_members0()
{
     // TODO EntityArrayMemberSymbol StartPopValue
    age.initialize( 0 );
    case_seed.initialize( 0.0 );
    entity_id.initialize( 0 );
    events.initialize( 0 );
    #line 22 "../code/ActorStartpopValues.mpp"
    is_activated.initialize( false );
    #line 28 "../code/ActorStartpopValues.mpp"
    is_removeable.initialize( false );
    #line 97 "../code/FamilyFirstUnion.mpp"
    is_set_first_union_clock.initialize( false );
    #line 60 "../code/FertilityGeneral.mpp"
    is_set_last_birth_clock.initialize( false );
    #line 66 "../code/MigrationGeneral.mpp"
    is_set_residential_move_clock.initialize( false );
    #line 14 "../code/ActorStartpopValues.mpp"
    lPersonStartpop.initialize( nullptr );
    #line 72 "../code/MigrationGeneral.mpp"
    om_FirstMoveEvent_om_event.initialize( time_infinite );
    #line 101 "../code/FamilyFirstUnion.mpp"
    om_FirstUnionImputationEvent_om_event.initialize( time_infinite );
    #line 64 "../code/FertilityGeneral.mpp"
    om_LastBirthImputationEvent_om_event.initialize( time_infinite );
    #line 73 "../code/MigrationGeneral.mpp"
    om_LastMoveEvent_om_event.initialize( time_infinite );
    #line 98 "../code/FamilyFirstUnion.mpp"
    om_SetFirstUnionClock_om_event.initialize( time_infinite );
    #line 61 "../code/FertilityGeneral.mpp"
    om_SetLastBirthClock_om_event.initialize( time_infinite );
    #line 67 "../code/MigrationGeneral.mpp"
    om_SetResidentialMoveClock_om_event.initialize( time_infinite );
    #line 29 "../code/ActorStartpopValues.mpp"
    om_SuicideEvent_om_event.initialize( time_infinite );
    #line 70 "../code/MigrationGeneral.mpp"
    scheduled_time_first_move.initialize( 0 );
    #line 71 "../code/MigrationGeneral.mpp"
    scheduled_time_last_move.initialize( 0 );
    time.initialize( 0 );
    #line 100 "../code/FamilyFirstUnion.mpp"
    time_first_union_imputation.initialize( 0 );
    #line 63 "../code/FertilityGeneral.mpp"
    time_last_birth_imputation.initialize( 0 );
}
#line 19059 "C:/Users/Martin/Dropbox/openM++/models/Dynamis-Pop-3-06-ABC/ompp/src/om_definitions.cpp"
void StartpopValues::om_initialize_derived_attributes()
{
}
void StartpopValues::om_initialize_entity_sets()
{
}
void StartpopValues::om_initialize_events()
{
    om_FirstMoveEvent_om_event.make_dirty();
    om_FirstUnionImputationEvent_om_event.make_dirty();
    om_LastBirthImputationEvent_om_event.make_dirty();
    om_LastMoveEvent_om_event.make_dirty();
    om_SetFirstUnionClock_om_event.make_dirty();
    om_SetLastBirthClock_om_event.make_dirty();
    om_SetResidentialMoveClock_om_event.make_dirty();
    om_SuicideEvent_om_event.make_dirty();
}
void StartpopValues::om_initialize_identity_attributes()
{

    // Code Injection: group=8, injector=is_removeable
    // Initialize 'is_removeable' to correct value based on expression.
    is_removeable_update_identity();
}
void StartpopValues::om_initialize_tables()
{
}
void StartpopValues::om_initialize_time_and_age()
{
    // Calling initialize() to set the values of time and age to time_infinite
    // ensures that their associated side-effects functions will be invoked
    // when set() is called immediately after.  This ensures that identity attributes
    // and derived attributes which depend on time and age have correct values
    // if they are used by model developer code in the Start() function before the
    // entity enters the simulation.
    time.initialize(time_infinite);
    time.set(BaseEvent::get_global_time());
    age.initialize(time_infinite);
    age.set(0);
}
void StartpopValues::om_notify_age()
{
}
void StartpopValues::om_notify_case_seed()
{
}
void StartpopValues::om_notify_entity_id()
{
}
void StartpopValues::om_notify_events()
{
}
void StartpopValues::om_notify_is_activated()
{
}
void StartpopValues::om_notify_is_removeable()
{
}
void StartpopValues::om_notify_is_set_first_union_clock()
{
}
void StartpopValues::om_notify_is_set_last_birth_clock()
{
}
void StartpopValues::om_notify_is_set_residential_move_clock()
{
}
void StartpopValues::om_notify_lPersonStartpop()
{
}
void StartpopValues::om_notify_scheduled_time_first_move()
{
}
void StartpopValues::om_notify_scheduled_time_last_move()
{
}
void StartpopValues::om_notify_time()
{
}
void StartpopValues::om_notify_time_first_union_imputation()
{
}
void StartpopValues::om_notify_time_last_birth_imputation()
{
}
void StartpopValues::om_reset_derived_attributes()
{
}
void StartpopValues::om_set_entity_id()
{
    entity_id.set(get_next_entity_id());
}
void StartpopValues::om_side_effects_age(Time om_old, Time om_new)
{
}
void StartpopValues::om_side_effects_case_seed(double om_old, double om_new)
{
}
void StartpopValues::om_side_effects_entity_id(int om_old, int om_new)
{
}
void StartpopValues::om_side_effects_events(counter om_old, counter om_new)
{
}
void StartpopValues::om_side_effects_is_activated(bool om_old, bool om_new)
{

    // Code Injection: group=10, injector=om_SetFirstUnionClock_om_event
    // Recalculate time to event SetFirstUnionClock
    if (om_active) om_SetFirstUnionClock_om_event.make_dirty();

    // Code Injection: group=10, injector=om_SetLastBirthClock_om_event
    // Recalculate time to event SetLastBirthClock
    if (om_active) om_SetLastBirthClock_om_event.make_dirty();

    // Code Injection: group=10, injector=om_SetResidentialMoveClock_om_event
    // Recalculate time to event SetResidentialMoveClock
    if (om_active) om_SetResidentialMoveClock_om_event.make_dirty();
}
void StartpopValues::om_side_effects_is_removeable(bool om_old, bool om_new)
{

    // Code Injection: group=10, injector=om_SuicideEvent_om_event
    // Recalculate time to event SuicideEvent
    if (om_active) om_SuicideEvent_om_event.make_dirty();
}
void StartpopValues::om_side_effects_is_set_first_union_clock(bool om_old, bool om_new)
{

    // Code Injection: group=10, injector=om_SetFirstUnionClock_om_event
    // Recalculate time to event SetFirstUnionClock
    if (om_active) om_SetFirstUnionClock_om_event.make_dirty();
}
void StartpopValues::om_side_effects_is_set_last_birth_clock(bool om_old, bool om_new)
{

    // Code Injection: group=10, injector=om_SetLastBirthClock_om_event
    // Recalculate time to event SetLastBirthClock
    if (om_active) om_SetLastBirthClock_om_event.make_dirty();
}
void StartpopValues::om_side_effects_is_set_residential_move_clock(bool om_old, bool om_new)
{

    // Code Injection: group=10, injector=om_SetResidentialMoveClock_om_event
    // Recalculate time to event SetResidentialMoveClock
    if (om_active) om_SetResidentialMoveClock_om_event.make_dirty();
}
void StartpopValues::om_side_effects_lPersonStartpop(entity_ptr<Person> om_old, entity_ptr<Person> om_new)
{

    // Code Injection: group=8, injector=is_removeable
    // Maintain identity for 'StartpopValues::is_removeable' when link changed to different agent
    is_removeable_update_identity();
    // Maintain reciprocal single link: lStartValues in Person
    if (om_old.get() != nullptr && om_old->lStartValues.get().get() == this) {
        om_old->lStartValues = nullptr;
    }
    if (om_new.get() != nullptr && om_new->lStartValues.get().get() != this) {
        om_new->lStartValues = this;
    }

}
void StartpopValues::om_side_effects_scheduled_time_first_move(Time om_old, Time om_new)
{

    // Code Injection: group=10, injector=om_FirstMoveEvent_om_event
    // Recalculate time to event FirstMoveEvent
    if (om_active) om_FirstMoveEvent_om_event.make_dirty();
}
void StartpopValues::om_side_effects_scheduled_time_last_move(Time om_old, Time om_new)
{

    // Code Injection: group=10, injector=om_LastMoveEvent_om_event
    // Recalculate time to event LastMoveEvent
    if (om_active) om_LastMoveEvent_om_event.make_dirty();
}
void StartpopValues::om_side_effects_time(Time om_old, Time om_new)
{
    // Amount of time increment
    Time om_delta = om_new - om_old;

    // Code Injection: group=2, injector=age
    if (om_active) {
        // Advance time for the attribute 'age'
        age.set(age.get() + om_delta);
    }
}
void StartpopValues::om_side_effects_time_first_union_imputation(Time om_old, Time om_new)
{

    // Code Injection: group=10, injector=om_FirstUnionImputationEvent_om_event
    // Recalculate time to event FirstUnionImputationEvent
    if (om_active) om_FirstUnionImputationEvent_om_event.make_dirty();
}
void StartpopValues::om_side_effects_time_last_birth_imputation(Time om_old, Time om_new)
{

    // Code Injection: group=10, injector=om_LastBirthImputationEvent_om_event
    // Recalculate time to event LastBirthImputationEvent
    if (om_active) om_LastBirthImputationEvent_om_event.make_dirty();
}

const std::string StartpopValues::om_name_age = "age";
const std::string StartpopValues::om_name_case_seed = "case_seed";
const std::string StartpopValues::om_name_entity_id = "entity_id";
const std::string StartpopValues::om_name_events = "events";
const std::string StartpopValues::om_name_is_activated = "is_activated";
const std::string StartpopValues::om_name_is_removeable = "is_removeable";
const std::string StartpopValues::om_name_is_set_first_union_clock = "is_set_first_union_clock";
const std::string StartpopValues::om_name_is_set_last_birth_clock = "is_set_last_birth_clock";
const std::string StartpopValues::om_name_is_set_residential_move_clock = "is_set_residential_move_clock";
const std::string StartpopValues::om_name_lPersonStartpop = "lPersonStartpop";
const std::string StartpopValues::om_name_scheduled_time_first_move = "scheduled_time_first_move";
const std::string StartpopValues::om_name_scheduled_time_last_move = "scheduled_time_last_move";
const std::string StartpopValues::om_name_time = "time";
const std::string StartpopValues::om_name_time_first_union_imputation = "time_first_union_imputation";
const std::string StartpopValues::om_name_time_last_birth_imputation = "time_last_birth_imputation";

// The definition of the static member StartpopValues
// used to retrieve (zero) values when dereferencing nullptr link attributes.
thread_local StartpopValues StartpopValues::om_null_agent;
/**
 * Free all zombie agents
 */
void BaseAgent::free_all_zombies()
{
    Calibrator::free_zombies();
    Clock::free_zombies();
    Observation::free_zombies();
    Person::free_zombies();
    StartpopValues::free_zombies();
}

void BaseAgent::initialize_simulation_runtime()
{
    agents = new std::list<BaseAgent *>;
    Calibrator::zombies = new std::forward_list<Calibrator *>;
    Calibrator::available = new std::forward_list<Calibrator *>;
    Clock::zombies = new std::forward_list<Clock *>;
    Clock::available = new std::forward_list<Clock *>;
    Observation::zombies = new std::forward_list<Observation *>;
    Observation::available = new std::forward_list<Observation *>;
    Person::zombies = new std::forward_list<Person *>;
    Person::available = new std::forward_list<Person *>;
    StartpopValues::zombies = new std::forward_list<StartpopValues *>;
    StartpopValues::available = new std::forward_list<StartpopValues *>;
}

void BaseAgent::finalize_simulation_runtime()
{
    assert(agents->empty());
    delete agents;
    agents = nullptr;

    assert(Calibrator::zombies->empty());
    delete Calibrator::zombies;
    Calibrator::zombies = nullptr;

    for (auto ent : *Calibrator::available) {
        delete ent;
    }
    delete Calibrator::available;
    Calibrator::available = nullptr;

    assert(Clock::zombies->empty());
    delete Clock::zombies;
    Clock::zombies = nullptr;

    for (auto ent : *Clock::available) {
        delete ent;
    }
    delete Clock::available;
    Clock::available = nullptr;

    assert(Observation::zombies->empty());
    delete Observation::zombies;
    Observation::zombies = nullptr;

    for (auto ent : *Observation::available) {
        delete ent;
    }
    delete Observation::available;
    Observation::available = nullptr;

    assert(Person::zombies->empty());
    delete Person::zombies;
    Person::zombies = nullptr;

    for (auto ent : *Person::available) {
        delete ent;
    }
    delete Person::available;
    Person::available = nullptr;

    assert(StartpopValues::zombies->empty());
    delete StartpopValues::zombies;
    StartpopValues::zombies = nullptr;

    for (auto ent : *StartpopValues::available) {
        delete ent;
    }
    delete StartpopValues::available;
    StartpopValues::available = nullptr;

}

// entity sets
thread_local EntitySet<Person> * asAllFertilePersonsForFertilityAlignment[2];

thread_local EntitySet<Person> * asAllFertilePersonsForFertilityAlignmentByAge[38][2];

thread_local EntitySet<Person> * asAllPerson;

thread_local EntitySet<Person> * asAvailableMale[86][13];

thread_local EntitySet<Person> * asAvailableMaleByType[86][3][13];

thread_local EntitySet<Person> * asAvailableMaleByTypeImmiScratch[86][3][13][151];

thread_local EntitySet<Person> * asAvailableMaleImmiScratch[86][13][151];

thread_local EntitySet<Calibrator> * asCalibrator;

thread_local EntitySet<Clock> * asClock;

thread_local EntitySet<Person> * asFemaleInUnionByAgeAndPartnerAge[51][86];

thread_local EntitySet<Person> * asFemaleInUnionByAgeAndPartnerAgeImmiScratch[51][86][151];

thread_local EntitySet<Observation> * asObservationAll[4];

thread_local EntitySet<Observation> * asObservationByFam[2000001];

thread_local EntitySet<Observation> * asObservationByFamOldest[2000001];

thread_local EntitySet<Observation> * asObservationHeads[4];

thread_local EntitySet<Observation> * asObservationNonHeads[2000001][4];

thread_local EntitySet<Observation> * asObservations;

thread_local EntitySet<Person> * asPotentialImmigrantMothers[101][151][13];

thread_local EntitySet<Person> * asPotentialSchoolOneStudent;

thread_local EntitySet<Person> * asPotentialSchoolOneStudentToProcess;

thread_local EntitySet<Person> * asPotentialSchoolTwoStudent;

thread_local EntitySet<Person> * asPotentialSchoolTwoStudentToProcess;

thread_local EntitySet<Person> * asResidentBabies;

thread_local EntitySet<Person> * asResidentsAge0Sex[2];

thread_local EntitySet<Person> * asResidentsAge0SexGeo[2][13];

thread_local EntitySet<Person> * asSimBornAge0[2][13][3];

thread_local EntitySet<Observation> * asSimulatedObservationHeads[4];

thread_local EntitySet<Person> * asWantToMove[13][13][2][13];

thread_local EntitySet<Person> * asWomenNoChildren[3][51][2];

thread_local EntitySet<Person> * asWomenWithChildren[3][7][6][2];


// definition of event_queue (declaration in Event.h)
thread_local std::set<BaseEvent *, less_deref<BaseEvent *> > *BaseEvent::event_queue = nullptr;

// definition of dirty_events (declaration in Event.h)
thread_local std::set<BaseEvent *, decltype(BaseEvent::dirty_cmp)* > *BaseEvent::dirty_events = nullptr;

// definition of global_event_counter (declaration in Event.h)
thread_local big_counter BaseEvent::global_event_counter;

// definition of global_time (declaration in Event.h)
thread_local Time *BaseEvent::global_time = nullptr;

// definition of active agent list (declaration in Agent.h)
thread_local std::list<BaseAgent *> *BaseAgent::agents = nullptr;

// get event name given event id
const char * event_id_to_name(int event_id) {
    static const char * event_name[] = {
        "BackMigrationEvent",
        "BirthdayEvent",
        "ChildMortalityCalibration",
        "ClockMidyearEvent",
        "ClockYearEndEvent",
        "ClockYearStartEvent",
        "DeathAtMaxLifespanEvent",
        "EmigrationEvent",
        "EndSchoolOneYearEvent",
        "EndSchoolTwoYearEvent",
        "FertilityBaseEvent",
        "FertilityDetailedEvent",
        "FirstImmigrationFromPoolEvent",
        "FirstImmigrationFromScratchEvent",
        "FirstMoveEvent",
        "FirstUnionFormationEvent",
        "FirstUnionImputationEvent",
        "LastBirthImputationEvent",
        "LastMoveEvent",
        "LeavingHomeEvent",
        "MigrationEvent",
        "MortalityBaseEvent",
        "MortalityDetailedEvent",
        "SetAliveEvent",
        "SetFirstUnionClock",
        "SetLastBirthClock",
        "SetPreschoolYearsEvent",
        "SetResidentialMoveClock",
        "StartSchoolOneYearEvent",
        "StartSchoolTwoYearEvent",
        "SuicideEvent",
        "om_ss_event",
        "", // unused - terminating entry
    };
    return event_name[event_id];
}

// Model one-time initialization
void RunOnce(IRunBase * const i_runBase)
{
    theLog->logMsg("Prepare fixed and missing parameters");

}

// Model run initialization
void RunInit(IRunBase * const i_runBase)
{
    theLog->logMsg("Get scenario parameters for process");

    om_param_AgeImmiSearchMother = std::move(read_om_parameter<double>(i_runBase, "AgeImmiSearchMother"));
    om_param_AgeImmigrantsScratch = std::move(read_om_parameter<double>(i_runBase, "AgeImmigrantsScratch", 202));
    om_param_AgeLeavingHome = std::move(read_om_parameter<double>(i_runBase, "AgeLeavingHome"));
    om_param_AgeOfImmigrantMother = std::move(read_om_parameter<double>(i_runBase, "AgeOfImmigrantMother", 38));
    om_param_AgeSpecificFertility = std::move(read_om_parameter<double>(i_runBase, "AgeSpecificFertility", 5738));
    om_param_BackMigrationHazard = std::move(read_om_parameter<double>(i_runBase, "BackMigrationHazard"));
    om_param_BirthTrends = std::move(read_om_parameter<double>(i_runBase, "BirthTrends", 2265));
    om_param_ChildMortalityBaseRisk = std::move(read_om_parameter<double>(i_runBase, "ChildMortalityBaseRisk", 10));
    om_param_ChildMortalityRelativeRisks = std::move(read_om_parameter<double>(i_runBase, "ChildMortalityRelativeRisks", 45));
    om_param_ChildMortalityTrend = std::move(read_om_parameter<double>(i_runBase, "ChildMortalityTrend", 730));
    om_param_ChildVaccinationOdds = std::move(read_om_parameter<double>(i_runBase, "ChildVaccinationOdds", 5436));
    om_param_Educ1FirstCohortRefinedModel = std::move(read_om_parameter<int>(i_runBase, "Educ1FirstCohortRefinedModel"));
    om_param_Educ1GradOdds = std::move(read_om_parameter<double>(i_runBase, "Educ1GradOdds", 6));
    om_param_Educ1Infrastructure = std::move(read_om_parameter<double>(i_runBase, "Educ1Infrastructure", 3624));
    om_param_Educ1Model = std::move(read_om_parameter<char>(i_runBase, "Educ1Model"));
    om_param_Educ1StartOdds = std::move(read_om_parameter<double>(i_runBase, "Educ1StartOdds", 6));
    om_param_Educ2AllowedDelays = std::move(read_om_parameter<int>(i_runBase, "Educ2AllowedDelays"));
    om_param_Educ2DelayedProgressionIntake = std::move(read_om_parameter<double>(i_runBase, "Educ2DelayedProgressionIntake", 906));
    om_param_Educ2DelayedRepetitionIntake = std::move(read_om_parameter<double>(i_runBase, "Educ2DelayedRepetitionIntake", 906));
    om_param_Educ2DirectProgressionIntake = std::move(read_om_parameter<double>(i_runBase, "Educ2DirectProgressionIntake", 906));
    om_param_Educ2DirectRepetitionIntake = std::move(read_om_parameter<double>(i_runBase, "Educ2DirectRepetitionIntake", 906));
    om_param_Educ2PeriodSuccess = std::move(read_om_parameter<double>(i_runBase, "Educ2PeriodSuccess", 906));
    om_param_EducOneDropoutGrade = std::move(read_om_parameter<double>(i_runBase, "EducOneDropoutGrade", 402));
    om_param_EducOneEntryAge = std::move(read_om_parameter<double>(i_runBase, "EducOneEntryAge", 268));
    om_param_EducTrans1 = std::move(read_om_parameter<double>(i_runBase, "EducTrans1", 1638));
    om_param_EducTrans2 = std::move(read_om_parameter<double>(i_runBase, "EducTrans2", 1742));
    om_param_EmigrationDestination = std::move(read_om_parameter<double>(i_runBase, "EmigrationDestination", 1));
    om_param_EmigrationRatesDistrict = std::move(read_om_parameter<double>(i_runBase, "EmigrationRatesDistrict", 312));
    om_param_EndSchoolOneYear = std::move(read_om_parameter<double>(i_runBase, "EndSchoolOneYear"));
    om_param_EthnicTransmission = std::move(read_om_parameter<double>(i_runBase, "EthnicTransmission", 200));
    om_param_EthnicityImmigrantsScratch = std::move(read_om_parameter<double>(i_runBase, "EthnicityImmigrantsScratch", 240));
    om_param_FertilityModel = std::move(read_om_parameter<char>(i_runBase, "FertilityModel"));
    om_param_FirstBirthRates = std::move(read_om_parameter<double>(i_runBase, "FirstBirthRates", 1140));
    om_param_HCICoefficients = std::move(read_om_parameter<double>(i_runBase, "HCICoefficients", 3));
    om_param_HigherOrderBirthsPara = std::move(read_om_parameter<double>(i_runBase, "HigherOrderBirthsPara", 154));
    om_param_ImmiPoolDestination = std::move(read_om_parameter<double>(i_runBase, "ImmiPoolDestination", 5436));
    om_param_ImmiPoolSize = std::move(read_om_parameter<double>(i_runBase, "ImmiPoolSize", 453));
    om_param_ImmiScratchDestination = std::move(read_om_parameter<double>(i_runBase, "ImmiScratchDestination", 312));
    om_param_InUnionProbNoChildren = std::move(read_om_parameter<double>(i_runBase, "InUnionProbNoChildren", 153));
    om_param_InUnionProbWithChildren = std::move(read_om_parameter<double>(i_runBase, "InUnionProbWithChildren", 126));
    om_param_LifeExpectancy = std::move(read_om_parameter<double>(i_runBase, "LifeExpectancy", 302));
    om_param_MicroDataInputFile = std::move(read_om_parameter<std::string>(i_runBase, "MicroDataInputFile"));
    om_param_MigrationDestination = std::move(read_om_parameter<double>(i_runBase, "MigrationDestination", 3744));
    om_param_MigrationProbability = std::move(read_om_parameter<double>(i_runBase, "MigrationProbability", 312));
    om_param_MigrationTryKeepingFamiliesTogether = std::move(read_om_parameter<bool>(i_runBase, "MigrationTryKeepingFamiliesTogether"));
    om_param_ModelBackmigration = std::move(read_om_parameter<bool>(i_runBase, "ModelBackmigration"));
    om_param_ModelEmigration = std::move(read_om_parameter<bool>(i_runBase, "ModelEmigration"));
    om_param_ModelImmigrationFromPools = std::move(read_om_parameter<bool>(i_runBase, "ModelImmigrationFromPools"));
    om_param_ModelImmigrationFromScratch = std::move(read_om_parameter<bool>(i_runBase, "ModelImmigrationFromScratch"));
    om_param_ModelMigration = std::move(read_om_parameter<bool>(i_runBase, "ModelMigration"));
    om_param_MortalityModel = std::move(read_om_parameter<char>(i_runBase, "MortalityModel"));
    om_param_MortalityTable = std::move(read_om_parameter<double>(i_runBase, "MortalityTable", 202));
    om_param_NumberImmigrantsFromScratch = std::move(read_om_parameter<double>(i_runBase, "NumberImmigrantsFromScratch", 302));
    om_param_PartnerAgeDistribution = std::move(read_om_parameter<double>(i_runBase, "PartnerAgeDistribution", 4386));
    om_param_PartnerCharacteristicDistribution = std::move(read_om_parameter<double>(i_runBase, "PartnerCharacteristicDistribution", 9));
    om_param_PreNatalCareOdds = std::move(read_om_parameter<double>(i_runBase, "PreNatalCareOdds", 1661));
    om_param_PreSchoolAttendance = std::move(read_om_parameter<double>(i_runBase, "PreSchoolAttendance", 3020));
    om_param_ProbStayWithMother = std::move(read_om_parameter<double>(i_runBase, "ProbStayWithMother"));
    om_param_ProportionStunting = std::move(read_om_parameter<double>(i_runBase, "ProportionStunting", 30));
    om_param_SchoolOneInterruptionRate = std::move(read_om_parameter<double>(i_runBase, "SchoolOneInterruptionRate", 151));
    om_param_SchoolOneRepetitionRate = std::move(read_om_parameter<double>(i_runBase, "SchoolOneRepetitionRate", 151));
    om_param_SchoolQuality = std::move(read_om_parameter<double>(i_runBase, "SchoolQuality", 10));
    om_param_SexRatio = std::move(read_om_parameter<double>(i_runBase, "SexRatio", 151));
    om_param_SimulationEnd = std::move(read_om_parameter<double>(i_runBase, "SimulationEnd"));
    om_param_SimulationSeed = std::move(read_om_parameter<int>(i_runBase, "SimulationSeed"));
    om_param_StartPopSampleSize = std::move(read_om_parameter<double>(i_runBase, "StartPopSampleSize"));
    om_param_StartSchoolOneYear = std::move(read_om_parameter<double>(i_runBase, "StartSchoolOneYear"));
    om_param_TotalFertilityRate = std::move(read_om_parameter<double>(i_runBase, "TotalFertilityRate", 151));
    om_param_Union1Choice = std::move(read_om_parameter<char>(i_runBase, "Union1Choice"));
    om_param_Union1ParametersCMN = std::move(read_om_parameter<double>(i_runBase, "Union1ParametersCMN", 783));
    om_param_Union1ParametersHazards = std::move(read_om_parameter<double>(i_runBase, "Union1ParametersHazards", 38556));
}

// Model startup method: Initialization for a simulation member
void ModelStartup(IModel * const i_model)
{
    // obtain simulation member to use for log messages
    int simulation_member = i_model->subValueId();

    // Bind scenario parameter references to thread local values (for scenario parameters).
    // Until this is done scenario parameter values are undefined and cannot be used by the model.

    theLog->logFormatted("member=%d Bind scenario parameters", simulation_member);

    #ifdef OM_DEBUG_PARAMETERS

    om_value_AgeImmiSearchMother = om_param_AgeImmiSearchMother[i_model->parameterSubValueIndex("AgeImmiSearchMother")];
    memcpy(om_value_AgeImmigrantsScratch, om_param_AgeImmigrantsScratch[i_model->parameterSubValueIndex("AgeImmigrantsScratch")].get(), 202 * sizeof(double));
    om_cumrate_AgeImmigrantsScratch.initialize((const double *)AgeImmigrantsScratch);
    om_value_AgeLeavingHome = om_param_AgeLeavingHome[i_model->parameterSubValueIndex("AgeLeavingHome")];
    memcpy(om_value_AgeOfImmigrantMother, om_param_AgeOfImmigrantMother[i_model->parameterSubValueIndex("AgeOfImmigrantMother")].get(), 38 * sizeof(double));
    om_cumrate_AgeOfImmigrantMother.initialize((const double *)AgeOfImmigrantMother);
    memcpy(om_value_AgeSpecificFertility, om_param_AgeSpecificFertility[i_model->parameterSubValueIndex("AgeSpecificFertility")].get(), 5738 * sizeof(double));
    om_value_BackMigrationHazard = om_param_BackMigrationHazard[i_model->parameterSubValueIndex("BackMigrationHazard")];
    memcpy(om_value_BirthTrends, om_param_BirthTrends[i_model->parameterSubValueIndex("BirthTrends")].get(), 2265 * sizeof(double));
    memcpy(om_value_ChildMortalityBaseRisk, om_param_ChildMortalityBaseRisk[i_model->parameterSubValueIndex("ChildMortalityBaseRisk")].get(), 10 * sizeof(double));
    memcpy(om_value_ChildMortalityRelativeRisks, om_param_ChildMortalityRelativeRisks[i_model->parameterSubValueIndex("ChildMortalityRelativeRisks")].get(), 45 * sizeof(double));
    memcpy(om_value_ChildMortalityTrend, om_param_ChildMortalityTrend[i_model->parameterSubValueIndex("ChildMortalityTrend")].get(), 730 * sizeof(double));
    memcpy(om_value_ChildVaccinationOdds, om_param_ChildVaccinationOdds[i_model->parameterSubValueIndex("ChildVaccinationOdds")].get(), 5436 * sizeof(double));
    om_value_Educ1FirstCohortRefinedModel = om_param_Educ1FirstCohortRefinedModel[i_model->parameterSubValueIndex("Educ1FirstCohortRefinedModel")];
    memcpy(om_value_Educ1GradOdds, om_param_Educ1GradOdds[i_model->parameterSubValueIndex("Educ1GradOdds")].get(), 6 * sizeof(double));
    memcpy(om_value_Educ1Infrastructure, om_param_Educ1Infrastructure[i_model->parameterSubValueIndex("Educ1Infrastructure")].get(), 3624 * sizeof(double));
    om_value_Educ1Model = om_param_Educ1Model[i_model->parameterSubValueIndex("Educ1Model")];
    memcpy(om_value_Educ1StartOdds, om_param_Educ1StartOdds[i_model->parameterSubValueIndex("Educ1StartOdds")].get(), 6 * sizeof(double));
    om_value_Educ2AllowedDelays = om_param_Educ2AllowedDelays[i_model->parameterSubValueIndex("Educ2AllowedDelays")];
    memcpy(om_value_Educ2DelayedProgressionIntake, om_param_Educ2DelayedProgressionIntake[i_model->parameterSubValueIndex("Educ2DelayedProgressionIntake")].get(), 906 * sizeof(double));
    memcpy(om_value_Educ2DelayedRepetitionIntake, om_param_Educ2DelayedRepetitionIntake[i_model->parameterSubValueIndex("Educ2DelayedRepetitionIntake")].get(), 906 * sizeof(double));
    memcpy(om_value_Educ2DirectProgressionIntake, om_param_Educ2DirectProgressionIntake[i_model->parameterSubValueIndex("Educ2DirectProgressionIntake")].get(), 906 * sizeof(double));
    memcpy(om_value_Educ2DirectRepetitionIntake, om_param_Educ2DirectRepetitionIntake[i_model->parameterSubValueIndex("Educ2DirectRepetitionIntake")].get(), 906 * sizeof(double));
    memcpy(om_value_Educ2PeriodSuccess, om_param_Educ2PeriodSuccess[i_model->parameterSubValueIndex("Educ2PeriodSuccess")].get(), 906 * sizeof(double));
    memcpy(om_value_EducOneDropoutGrade, om_param_EducOneDropoutGrade[i_model->parameterSubValueIndex("EducOneDropoutGrade")].get(), 402 * sizeof(double));
    om_cumrate_EducOneDropoutGrade.initialize((const double *)EducOneDropoutGrade);
    memcpy(om_value_EducOneEntryAge, om_param_EducOneEntryAge[i_model->parameterSubValueIndex("EducOneEntryAge")].get(), 268 * sizeof(double));
    om_cumrate_EducOneEntryAge.initialize((const double *)EducOneEntryAge);
    memcpy(om_value_EducTrans1, om_param_EducTrans1[i_model->parameterSubValueIndex("EducTrans1")].get(), 1638 * sizeof(double));
    memcpy(om_value_EducTrans2, om_param_EducTrans2[i_model->parameterSubValueIndex("EducTrans2")].get(), 1742 * sizeof(double));
    memcpy(om_value_EmigrationDestination, om_param_EmigrationDestination[i_model->parameterSubValueIndex("EmigrationDestination")].get(), 1 * sizeof(double));
    om_cumrate_EmigrationDestination.initialize((const double *)EmigrationDestination);
    memcpy(om_value_EmigrationRatesDistrict, om_param_EmigrationRatesDistrict[i_model->parameterSubValueIndex("EmigrationRatesDistrict")].get(), 312 * sizeof(double));
    om_value_EndSchoolOneYear = om_param_EndSchoolOneYear[i_model->parameterSubValueIndex("EndSchoolOneYear")];
    memcpy(om_value_EthnicTransmission, om_param_EthnicTransmission[i_model->parameterSubValueIndex("EthnicTransmission")].get(), 200 * sizeof(double));
    om_cumrate_EthnicTransmission.initialize((const double *)EthnicTransmission);
    memcpy(om_value_EthnicityImmigrantsScratch, om_param_EthnicityImmigrantsScratch[i_model->parameterSubValueIndex("EthnicityImmigrantsScratch")].get(), 240 * sizeof(double));
    om_cumrate_EthnicityImmigrantsScratch.initialize((const double *)EthnicityImmigrantsScratch);
    om_value_FertilityModel = om_param_FertilityModel[i_model->parameterSubValueIndex("FertilityModel")];
    memcpy(om_value_FirstBirthRates, om_param_FirstBirthRates[i_model->parameterSubValueIndex("FirstBirthRates")].get(), 1140 * sizeof(double));
    memcpy(om_value_HCICoefficients, om_param_HCICoefficients[i_model->parameterSubValueIndex("HCICoefficients")].get(), 3 * sizeof(double));
    memcpy(om_value_HigherOrderBirthsPara, om_param_HigherOrderBirthsPara[i_model->parameterSubValueIndex("HigherOrderBirthsPara")].get(), 154 * sizeof(double));
    memcpy(om_value_ImmiPoolDestination, om_param_ImmiPoolDestination[i_model->parameterSubValueIndex("ImmiPoolDestination")].get(), 5436 * sizeof(double));
    om_cumrate_ImmiPoolDestination.initialize((const double *)ImmiPoolDestination);
    memcpy(om_value_ImmiPoolSize, om_param_ImmiPoolSize[i_model->parameterSubValueIndex("ImmiPoolSize")].get(), 453 * sizeof(double));
    memcpy(om_value_ImmiScratchDestination, om_param_ImmiScratchDestination[i_model->parameterSubValueIndex("ImmiScratchDestination")].get(), 312 * sizeof(double));
    om_cumrate_ImmiScratchDestination.initialize((const double *)ImmiScratchDestination);
    memcpy(om_value_InUnionProbNoChildren, om_param_InUnionProbNoChildren[i_model->parameterSubValueIndex("InUnionProbNoChildren")].get(), 153 * sizeof(double));
    memcpy(om_value_InUnionProbWithChildren, om_param_InUnionProbWithChildren[i_model->parameterSubValueIndex("InUnionProbWithChildren")].get(), 126 * sizeof(double));
    memcpy(om_value_LifeExpectancy, om_param_LifeExpectancy[i_model->parameterSubValueIndex("LifeExpectancy")].get(), 302 * sizeof(double));
    om_value_MicroDataInputFile = om_param_MicroDataInputFile[i_model->parameterSubValueIndex("MicroDataInputFile")];
    memcpy(om_value_MigrationDestination, om_param_MigrationDestination[i_model->parameterSubValueIndex("MigrationDestination")].get(), 3744 * sizeof(double));
    om_cumrate_MigrationDestination.initialize((const double *)MigrationDestination);
    memcpy(om_value_MigrationProbability, om_param_MigrationProbability[i_model->parameterSubValueIndex("MigrationProbability")].get(), 312 * sizeof(double));
    om_value_MigrationTryKeepingFamiliesTogether = om_param_MigrationTryKeepingFamiliesTogether[i_model->parameterSubValueIndex("MigrationTryKeepingFamiliesTogether")];
    om_value_ModelBackmigration = om_param_ModelBackmigration[i_model->parameterSubValueIndex("ModelBackmigration")];
    om_value_ModelEmigration = om_param_ModelEmigration[i_model->parameterSubValueIndex("ModelEmigration")];
    om_value_ModelImmigrationFromPools = om_param_ModelImmigrationFromPools[i_model->parameterSubValueIndex("ModelImmigrationFromPools")];
    om_value_ModelImmigrationFromScratch = om_param_ModelImmigrationFromScratch[i_model->parameterSubValueIndex("ModelImmigrationFromScratch")];
    om_value_ModelMigration = om_param_ModelMigration[i_model->parameterSubValueIndex("ModelMigration")];
    om_value_MortalityModel = om_param_MortalityModel[i_model->parameterSubValueIndex("MortalityModel")];
    memcpy(om_value_MortalityTable, om_param_MortalityTable[i_model->parameterSubValueIndex("MortalityTable")].get(), 202 * sizeof(double));
    memcpy(om_value_NumberImmigrantsFromScratch, om_param_NumberImmigrantsFromScratch[i_model->parameterSubValueIndex("NumberImmigrantsFromScratch")].get(), 302 * sizeof(double));
    memcpy(om_value_PartnerAgeDistribution, om_param_PartnerAgeDistribution[i_model->parameterSubValueIndex("PartnerAgeDistribution")].get(), 4386 * sizeof(double));
    memcpy(om_value_PartnerCharacteristicDistribution, om_param_PartnerCharacteristicDistribution[i_model->parameterSubValueIndex("PartnerCharacteristicDistribution")].get(), 9 * sizeof(double));
    om_cumrate_PartnerCharacteristicDistribution.initialize((const double *)PartnerCharacteristicDistribution);
    memcpy(om_value_PreNatalCareOdds, om_param_PreNatalCareOdds[i_model->parameterSubValueIndex("PreNatalCareOdds")].get(), 1661 * sizeof(double));
    memcpy(om_value_PreSchoolAttendance, om_param_PreSchoolAttendance[i_model->parameterSubValueIndex("PreSchoolAttendance")].get(), 3020 * sizeof(double));
    om_value_ProbStayWithMother = om_param_ProbStayWithMother[i_model->parameterSubValueIndex("ProbStayWithMother")];
    memcpy(om_value_ProportionStunting, om_param_ProportionStunting[i_model->parameterSubValueIndex("ProportionStunting")].get(), 30 * sizeof(double));
    memcpy(om_value_SchoolOneInterruptionRate, om_param_SchoolOneInterruptionRate[i_model->parameterSubValueIndex("SchoolOneInterruptionRate")].get(), 151 * sizeof(double));
    memcpy(om_value_SchoolOneRepetitionRate, om_param_SchoolOneRepetitionRate[i_model->parameterSubValueIndex("SchoolOneRepetitionRate")].get(), 151 * sizeof(double));
    memcpy(om_value_SchoolQuality, om_param_SchoolQuality[i_model->parameterSubValueIndex("SchoolQuality")].get(), 10 * sizeof(double));
    memcpy(om_value_SexRatio, om_param_SexRatio[i_model->parameterSubValueIndex("SexRatio")].get(), 151 * sizeof(double));
    om_value_SimulationEnd = om_param_SimulationEnd[i_model->parameterSubValueIndex("SimulationEnd")];
    om_value_SimulationSeed = om_param_SimulationSeed[i_model->parameterSubValueIndex("SimulationSeed")];
    om_value_StartPopSampleSize = om_param_StartPopSampleSize[i_model->parameterSubValueIndex("StartPopSampleSize")];
    om_value_StartSchoolOneYear = om_param_StartSchoolOneYear[i_model->parameterSubValueIndex("StartSchoolOneYear")];
    memcpy(om_value_TotalFertilityRate, om_param_TotalFertilityRate[i_model->parameterSubValueIndex("TotalFertilityRate")].get(), 151 * sizeof(double));
    om_value_Union1Choice = om_param_Union1Choice[i_model->parameterSubValueIndex("Union1Choice")];
    memcpy(om_value_Union1ParametersCMN, om_param_Union1ParametersCMN[i_model->parameterSubValueIndex("Union1ParametersCMN")].get(), 783 * sizeof(double));
    memcpy(om_value_Union1ParametersHazards, om_param_Union1ParametersHazards[i_model->parameterSubValueIndex("Union1ParametersHazards")].get(), 38556 * sizeof(double));

    #else // OM_DEBUG_PARAMETERS

    om_value_AgeImmiSearchMother = om_param_AgeImmiSearchMother[i_model->parameterSubValueIndex("AgeImmiSearchMother")];
    om_value_AgeImmigrantsScratch = om_param_AgeImmigrantsScratch[i_model->parameterSubValueIndex("AgeImmigrantsScratch")].get();
    om_cumrate_AgeImmigrantsScratch.initialize((const double *)AgeImmigrantsScratch);
    om_value_AgeLeavingHome = om_param_AgeLeavingHome[i_model->parameterSubValueIndex("AgeLeavingHome")];
    om_value_AgeOfImmigrantMother = om_param_AgeOfImmigrantMother[i_model->parameterSubValueIndex("AgeOfImmigrantMother")].get();
    om_cumrate_AgeOfImmigrantMother.initialize((const double *)AgeOfImmigrantMother);
    om_value_AgeSpecificFertility = om_param_AgeSpecificFertility[i_model->parameterSubValueIndex("AgeSpecificFertility")].get();
    om_value_BackMigrationHazard = om_param_BackMigrationHazard[i_model->parameterSubValueIndex("BackMigrationHazard")];
    om_value_BirthTrends = om_param_BirthTrends[i_model->parameterSubValueIndex("BirthTrends")].get();
    om_value_ChildMortalityBaseRisk = om_param_ChildMortalityBaseRisk[i_model->parameterSubValueIndex("ChildMortalityBaseRisk")].get();
    om_value_ChildMortalityRelativeRisks = om_param_ChildMortalityRelativeRisks[i_model->parameterSubValueIndex("ChildMortalityRelativeRisks")].get();
    om_value_ChildMortalityTrend = om_param_ChildMortalityTrend[i_model->parameterSubValueIndex("ChildMortalityTrend")].get();
    om_value_ChildVaccinationOdds = om_param_ChildVaccinationOdds[i_model->parameterSubValueIndex("ChildVaccinationOdds")].get();
    om_value_Educ1FirstCohortRefinedModel = om_param_Educ1FirstCohortRefinedModel[i_model->parameterSubValueIndex("Educ1FirstCohortRefinedModel")];
    om_value_Educ1GradOdds = om_param_Educ1GradOdds[i_model->parameterSubValueIndex("Educ1GradOdds")].get();
    om_value_Educ1Infrastructure = om_param_Educ1Infrastructure[i_model->parameterSubValueIndex("Educ1Infrastructure")].get();
    om_value_Educ1Model = om_param_Educ1Model[i_model->parameterSubValueIndex("Educ1Model")];
    om_value_Educ1StartOdds = om_param_Educ1StartOdds[i_model->parameterSubValueIndex("Educ1StartOdds")].get();
    om_value_Educ2AllowedDelays = om_param_Educ2AllowedDelays[i_model->parameterSubValueIndex("Educ2AllowedDelays")];
    om_value_Educ2DelayedProgressionIntake = om_param_Educ2DelayedProgressionIntake[i_model->parameterSubValueIndex("Educ2DelayedProgressionIntake")].get();
    om_value_Educ2DelayedRepetitionIntake = om_param_Educ2DelayedRepetitionIntake[i_model->parameterSubValueIndex("Educ2DelayedRepetitionIntake")].get();
    om_value_Educ2DirectProgressionIntake = om_param_Educ2DirectProgressionIntake[i_model->parameterSubValueIndex("Educ2DirectProgressionIntake")].get();
    om_value_Educ2DirectRepetitionIntake = om_param_Educ2DirectRepetitionIntake[i_model->parameterSubValueIndex("Educ2DirectRepetitionIntake")].get();
    om_value_Educ2PeriodSuccess = om_param_Educ2PeriodSuccess[i_model->parameterSubValueIndex("Educ2PeriodSuccess")].get();
    om_value_EducOneDropoutGrade = om_param_EducOneDropoutGrade[i_model->parameterSubValueIndex("EducOneDropoutGrade")].get();
    om_cumrate_EducOneDropoutGrade.initialize((const double *)EducOneDropoutGrade);
    om_value_EducOneEntryAge = om_param_EducOneEntryAge[i_model->parameterSubValueIndex("EducOneEntryAge")].get();
    om_cumrate_EducOneEntryAge.initialize((const double *)EducOneEntryAge);
    om_value_EducTrans1 = om_param_EducTrans1[i_model->parameterSubValueIndex("EducTrans1")].get();
    om_value_EducTrans2 = om_param_EducTrans2[i_model->parameterSubValueIndex("EducTrans2")].get();
    om_value_EmigrationDestination = om_param_EmigrationDestination[i_model->parameterSubValueIndex("EmigrationDestination")].get();
    om_cumrate_EmigrationDestination.initialize((const double *)EmigrationDestination);
    om_value_EmigrationRatesDistrict = om_param_EmigrationRatesDistrict[i_model->parameterSubValueIndex("EmigrationRatesDistrict")].get();
    om_value_EndSchoolOneYear = om_param_EndSchoolOneYear[i_model->parameterSubValueIndex("EndSchoolOneYear")];
    om_value_EthnicTransmission = om_param_EthnicTransmission[i_model->parameterSubValueIndex("EthnicTransmission")].get();
    om_cumrate_EthnicTransmission.initialize((const double *)EthnicTransmission);
    om_value_EthnicityImmigrantsScratch = om_param_EthnicityImmigrantsScratch[i_model->parameterSubValueIndex("EthnicityImmigrantsScratch")].get();
    om_cumrate_EthnicityImmigrantsScratch.initialize((const double *)EthnicityImmigrantsScratch);
    om_value_FertilityModel = om_param_FertilityModel[i_model->parameterSubValueIndex("FertilityModel")];
    om_value_FirstBirthRates = om_param_FirstBirthRates[i_model->parameterSubValueIndex("FirstBirthRates")].get();
    om_value_HCICoefficients = om_param_HCICoefficients[i_model->parameterSubValueIndex("HCICoefficients")].get();
    om_value_HigherOrderBirthsPara = om_param_HigherOrderBirthsPara[i_model->parameterSubValueIndex("HigherOrderBirthsPara")].get();
    om_value_ImmiPoolDestination = om_param_ImmiPoolDestination[i_model->parameterSubValueIndex("ImmiPoolDestination")].get();
    om_cumrate_ImmiPoolDestination.initialize((const double *)ImmiPoolDestination);
    om_value_ImmiPoolSize = om_param_ImmiPoolSize[i_model->parameterSubValueIndex("ImmiPoolSize")].get();
    om_value_ImmiScratchDestination = om_param_ImmiScratchDestination[i_model->parameterSubValueIndex("ImmiScratchDestination")].get();
    om_cumrate_ImmiScratchDestination.initialize((const double *)ImmiScratchDestination);
    om_value_InUnionProbNoChildren = om_param_InUnionProbNoChildren[i_model->parameterSubValueIndex("InUnionProbNoChildren")].get();
    om_value_InUnionProbWithChildren = om_param_InUnionProbWithChildren[i_model->parameterSubValueIndex("InUnionProbWithChildren")].get();
    om_value_LifeExpectancy = om_param_LifeExpectancy[i_model->parameterSubValueIndex("LifeExpectancy")].get();
    om_value_MicroDataInputFile = om_param_MicroDataInputFile[i_model->parameterSubValueIndex("MicroDataInputFile")];
    om_value_MigrationDestination = om_param_MigrationDestination[i_model->parameterSubValueIndex("MigrationDestination")].get();
    om_cumrate_MigrationDestination.initialize((const double *)MigrationDestination);
    om_value_MigrationProbability = om_param_MigrationProbability[i_model->parameterSubValueIndex("MigrationProbability")].get();
    om_value_MigrationTryKeepingFamiliesTogether = om_param_MigrationTryKeepingFamiliesTogether[i_model->parameterSubValueIndex("MigrationTryKeepingFamiliesTogether")];
    om_value_ModelBackmigration = om_param_ModelBackmigration[i_model->parameterSubValueIndex("ModelBackmigration")];
    om_value_ModelEmigration = om_param_ModelEmigration[i_model->parameterSubValueIndex("ModelEmigration")];
    om_value_ModelImmigrationFromPools = om_param_ModelImmigrationFromPools[i_model->parameterSubValueIndex("ModelImmigrationFromPools")];
    om_value_ModelImmigrationFromScratch = om_param_ModelImmigrationFromScratch[i_model->parameterSubValueIndex("ModelImmigrationFromScratch")];
    om_value_ModelMigration = om_param_ModelMigration[i_model->parameterSubValueIndex("ModelMigration")];
    om_value_MortalityModel = om_param_MortalityModel[i_model->parameterSubValueIndex("MortalityModel")];
    om_value_MortalityTable = om_param_MortalityTable[i_model->parameterSubValueIndex("MortalityTable")].get();
    om_value_NumberImmigrantsFromScratch = om_param_NumberImmigrantsFromScratch[i_model->parameterSubValueIndex("NumberImmigrantsFromScratch")].get();
    om_value_PartnerAgeDistribution = om_param_PartnerAgeDistribution[i_model->parameterSubValueIndex("PartnerAgeDistribution")].get();
    om_value_PartnerCharacteristicDistribution = om_param_PartnerCharacteristicDistribution[i_model->parameterSubValueIndex("PartnerCharacteristicDistribution")].get();
    om_cumrate_PartnerCharacteristicDistribution.initialize((const double *)PartnerCharacteristicDistribution);
    om_value_PreNatalCareOdds = om_param_PreNatalCareOdds[i_model->parameterSubValueIndex("PreNatalCareOdds")].get();
    om_value_PreSchoolAttendance = om_param_PreSchoolAttendance[i_model->parameterSubValueIndex("PreSchoolAttendance")].get();
    om_value_ProbStayWithMother = om_param_ProbStayWithMother[i_model->parameterSubValueIndex("ProbStayWithMother")];
    om_value_ProportionStunting = om_param_ProportionStunting[i_model->parameterSubValueIndex("ProportionStunting")].get();
    om_value_SchoolOneInterruptionRate = om_param_SchoolOneInterruptionRate[i_model->parameterSubValueIndex("SchoolOneInterruptionRate")].get();
    om_value_SchoolOneRepetitionRate = om_param_SchoolOneRepetitionRate[i_model->parameterSubValueIndex("SchoolOneRepetitionRate")].get();
    om_value_SchoolQuality = om_param_SchoolQuality[i_model->parameterSubValueIndex("SchoolQuality")].get();
    om_value_SexRatio = om_param_SexRatio[i_model->parameterSubValueIndex("SexRatio")].get();
    om_value_SimulationEnd = om_param_SimulationEnd[i_model->parameterSubValueIndex("SimulationEnd")];
    om_value_SimulationSeed = om_param_SimulationSeed[i_model->parameterSubValueIndex("SimulationSeed")];
    om_value_StartPopSampleSize = om_param_StartPopSampleSize[i_model->parameterSubValueIndex("StartPopSampleSize")];
    om_value_StartSchoolOneYear = om_param_StartSchoolOneYear[i_model->parameterSubValueIndex("StartSchoolOneYear")];
    om_value_TotalFertilityRate = om_param_TotalFertilityRate[i_model->parameterSubValueIndex("TotalFertilityRate")].get();
    om_value_Union1Choice = om_param_Union1Choice[i_model->parameterSubValueIndex("Union1Choice")];
    om_value_Union1ParametersCMN = om_param_Union1ParametersCMN[i_model->parameterSubValueIndex("Union1ParametersCMN")].get();
    om_value_Union1ParametersHazards = om_param_Union1ParametersHazards[i_model->parameterSubValueIndex("Union1ParametersHazards")].get();

    #endif // OM_DEBUG_PARAMETERS


    // Zero-initialize derived parameters.

    std::memset(AgeSpecificFertilityRate, 0, 5738 * sizeof(double));
    EndSchoolTwoYear = (double) 0;
    MicroDataInputFileSize = (long) 0;
    std::memset(MortalityTrend, 0, 302 * sizeof(double));
    ScalingFactor = (double) 0;
    StartSchoolTwoYear = (double) 0;
    std::memset(Union1FormationHazard, 0, 38556 * sizeof(double));

    // Parameters are now ready and can be used by the model.

    theLog->logFormatted("member=%d Compute derived parameters", simulation_member);
    int mem_id = i_model->subValueId();
    int mem_count = i_model->subValueCount();
    before_presimulation(mem_id, mem_count); // defined in model framework module
    // Call 5 PreSimulation functions without suffix
    #ifdef _DEBUG
    theLog->logMsg("  call om_PreSimulation_0");
    #endif
    om_PreSimulation_0();
    #ifdef _DEBUG
    theLog->logMsg("  call om_PreSimulation_1");
    #endif
    om_PreSimulation_1();
    #ifdef _DEBUG
    theLog->logMsg("  call om_PreSimulation_2");
    #endif
    om_PreSimulation_2();
    #ifdef _DEBUG
    theLog->logMsg("  call om_PreSimulation_3");
    #endif
    om_PreSimulation_3();
    #ifdef _DEBUG
    theLog->logMsg("  call om_PreSimulation_4");
    #endif
    om_PreSimulation_4();
    // Call 0 PreSimulation functions with suffix
    after_presimulation(); // defined in model framework module

    theLog->logFormatted("member=%d Prepare for simulation", simulation_member);
    // Entity static initialization part 1: Initialize entity attribute offsets & null entity data members
    // Entity - Calibrator
    Calibrator::om_null_agent.om_assign_member_offsets();
    Calibrator::om_null_agent.om_initialize_data_members0();

    // Entity - Clock
    Clock::om_null_agent.om_assign_member_offsets();
    Clock::om_null_agent.om_initialize_data_members0();

    // Entity - Observation
    Observation::om_null_agent.om_assign_member_offsets();
    Observation::om_null_agent.om_initialize_data_members0();

    // Entity - Person
    Person::om_null_agent.om_assign_member_offsets();
    Person::om_null_agent.om_initialize_data_members0();

    // Entity - StartpopValues
    StartpopValues::om_null_agent.om_assign_member_offsets();
    StartpopValues::om_null_agent.om_initialize_data_members0();

    // Entity static initialization part 2: Initialize null entity dependent attributes
    // Entity - Calibrator
    Calibrator::om_null_agent.om_initialize_identity_attributes();
    Calibrator::om_null_agent.om_initialize_derived_attributes();
    Calibrator::om_null_agent.om_reset_derived_attributes();
    // Entity - Clock
    Clock::om_null_agent.om_initialize_identity_attributes();
    Clock::om_null_agent.om_initialize_derived_attributes();
    Clock::om_null_agent.om_reset_derived_attributes();
    // Entity - Observation
    Observation::om_null_agent.om_initialize_identity_attributes();
    Observation::om_null_agent.om_initialize_derived_attributes();
    Observation::om_null_agent.om_reset_derived_attributes();
    // Entity - Person
    Person::om_null_agent.om_initialize_identity_attributes();
    Person::om_null_agent.om_initialize_derived_attributes();
    Person::om_null_agent.om_reset_derived_attributes();
    // Entity - StartpopValues
    StartpopValues::om_null_agent.om_initialize_identity_attributes();
    StartpopValues::om_null_agent.om_initialize_derived_attributes();
    StartpopValues::om_null_agent.om_reset_derived_attributes();

    // Entity table instantiation
    assert(!thePopPyramidByEduc); 
    if (!is_suppressed_compute("PopPyramidByEduc", i_model)) {
        thePopPyramidByEduc = new PopPyramidByEduc({7, 3, 13, 21});
    }
    assert(!theTabChildVaccination); 
    if (!is_suppressed_compute("TabChildVaccination", i_model)) {
        theTabChildVaccination = new TabChildVaccination({151, 6});
    }
    assert(!theTabEduc15ByDistrict); 
    if (!is_suppressed_compute("TabEduc15ByDistrict", i_model)) {
        theTabEduc15ByDistrict = new TabEduc15ByDistrict({13, 3, 151});
    }
    assert(!theTabEduc15ByDistrictBirth); 
    if (!is_suppressed_compute("TabEduc15ByDistrictBirth", i_model)) {
        theTabEduc15ByDistrictBirth = new TabEduc15ByDistrictBirth({14, 3, 151});
    }
    assert(!theTabEducFateByGroup); 
    if (!is_suppressed_compute("TabEducFateByGroup", i_model)) {
        theTabEducFateByGroup = new TabEducFateByGroup({4, 151, 4});
    }
    assert(!theTabEducFateDistrYob); 
    if (!is_suppressed_compute("TabEducFateDistrYob", i_model)) {
        theTabEducFateDistrYob = new TabEducFateDistrYob({6, 252, 4});
    }
    assert(!theTabHCIDistrict); 
    if (!is_suppressed_compute("TabHCIDistrict", i_model)) {
        theTabHCIDistrict = new TabHCIDistrict({3, 13, 151});
    }
    assert(!theTabImmunizationChildren); 
    if (!is_suppressed_compute("TabImmunizationChildren", i_model)) {
        theTabImmunizationChildren = new TabImmunizationChildren({3, 8, 3, 6, 4, 151});
    }
    assert(!theTabPopProvAgeEducSex); 
    if (!is_suppressed_compute("TabPopProvAgeEducSex", i_model)) {
        theTabPopProvAgeEducSex = new TabPopProvAgeEducSex({13, 3, 151});
    }
    assert(!theTabPrenatCare); 
    if (!is_suppressed_compute("TabPrenatCare", i_model)) {
        theTabPrenatCare = new TabPrenatCare({6, 4, 151});
    }
    assert(!theTabPrimSchoolEntries); 
    if (!is_suppressed_compute("TabPrimSchoolEntries", i_model)) {
        theTabPrimSchoolEntries = new TabPrimSchoolEntries({151, 13});
    }
    assert(!theTabPrimSchoolGraduations); 
    if (!is_suppressed_compute("TabPrimSchoolGraduations", i_model)) {
        theTabPrimSchoolGraduations = new TabPrimSchoolGraduations({151, 13});
    }
    assert(!theTabPrimSchoolOutOfSchool9to11); 
    if (!is_suppressed_compute("TabPrimSchoolOutOfSchool9to11", i_model)) {
        theTabPrimSchoolOutOfSchool9to11 = new TabPrimSchoolOutOfSchool9to11({151, 13});
    }
    assert(!theTabPrimarySchoolPlanning); 
    if (!is_suppressed_compute("TabPrimarySchoolPlanning", i_model)) {
        theTabPrimarySchoolPlanning = new TabPrimarySchoolPlanning({13, 151, 7});
    }
    assert(!theTabSchool2AttainmentsTab); 
    if (!is_suppressed_compute("TabSchool2AttainmentsTab", i_model)) {
        theTabSchool2AttainmentsTab = new TabSchool2AttainmentsTab({3, 151});
    }
    assert(!theTabSchool2TrackTab); 
    if (!is_suppressed_compute("TabSchool2TrackTab", i_model)) {
        theTabSchool2TrackTab = new TabSchool2TrackTab({151, 8});
    }
    assert(!thetabBirthsYearPlace); 
    if (!is_suppressed_compute("tabBirthsYearPlace", i_model)) {
        thetabBirthsYearPlace = new tabBirthsYearPlace({14, 151});
    }
    assert(!thetabEducationFateGeobirYob); 
    if (!is_suppressed_compute("tabEducationFateGeobirYob", i_model)) {
        thetabEducationFateGeobirYob = new tabEducationFateGeobirYob({3, 14, 252});
    }
    assert(!thetabHCI); 
    if (!is_suppressed_compute("tabHCI", i_model)) {
        thetabHCI = new tabHCI({3, 6, 151});
    }
    assert(!thetabHavingSpouse); 
    if (!is_suppressed_compute("tabHavingSpouse", i_model)) {
        thetabHavingSpouse = new tabHavingSpouse({3, 101, 151});
    }
    assert(!thetabMigrationOriginDestination); 
    if (!is_suppressed_compute("tabMigrationOriginDestination", i_model)) {
        thetabMigrationOriginDestination = new tabMigrationOriginDestination({5, 14, 13});
    }
    assert(!thetabPopulationYearPlace); 
    if (!is_suppressed_compute("tabPopulationYearPlace", i_model)) {
        thetabPopulationYearPlace = new tabPopulationYearPlace({14, 151});
    }
    assert(!thetabPreSchool); 
    if (!is_suppressed_compute("tabPreSchool", i_model)) {
        thetabPreSchool = new tabPreSchool({14, 151});
    }
    assert(!thetabStuntingSexRegMotherYob); 
    if (!is_suppressed_compute("tabStuntingSexRegMotherYob", i_model)) {
        thetabStuntingSexRegMotherYob = new tabStuntingSexRegMotherYob({3, 4, 6, 151});
    }
    assert(!thetabStuntingSexRegYob); 
    if (!is_suppressed_compute("tabStuntingSexRegYob", i_model)) {
        thetabStuntingSexRegYob = new tabStuntingSexRegYob({6, 151});
    }

    // Derived table instantiation

    // Entity set instantiation
    {
        EntitySet<Person> ** flattened_array = reinterpret_cast<EntitySet<Person> **>(asAllFertilePersonsForFertilityAlignment);
        const size_t cells = 2;
        for (size_t cell = 0; cell < cells; ++cell) {
            assert(!flattened_array[cell]);
            flattened_array[cell] = new EntitySet<Person>;
        }
    }
    {
        EntitySet<Person> ** flattened_array = reinterpret_cast<EntitySet<Person> **>(asAllFertilePersonsForFertilityAlignmentByAge);
        const size_t cells = 76;
        for (size_t cell = 0; cell < cells; ++cell) {
            assert(!flattened_array[cell]);
            flattened_array[cell] = new EntitySet<Person>;
        }
    }
    {
        assert(!asAllPerson);
        asAllPerson = new EntitySet<Person>;
    }
    {
        EntitySet<Person> ** flattened_array = reinterpret_cast<EntitySet<Person> **>(asAvailableMale);
        const size_t cells = 1118;
        for (size_t cell = 0; cell < cells; ++cell) {
            assert(!flattened_array[cell]);
            flattened_array[cell] = new EntitySet<Person>;
        }
    }
    {
        EntitySet<Person> ** flattened_array = reinterpret_cast<EntitySet<Person> **>(asAvailableMaleByType);
        const size_t cells = 3354;
        for (size_t cell = 0; cell < cells; ++cell) {
            assert(!flattened_array[cell]);
            flattened_array[cell] = new EntitySet<Person>;
        }
    }
    {
        EntitySet<Person> ** flattened_array = reinterpret_cast<EntitySet<Person> **>(asAvailableMaleByTypeImmiScratch);
        const size_t cells = 506454;
        for (size_t cell = 0; cell < cells; ++cell) {
            assert(!flattened_array[cell]);
            flattened_array[cell] = new EntitySet<Person>;
        }
    }
    {
        EntitySet<Person> ** flattened_array = reinterpret_cast<EntitySet<Person> **>(asAvailableMaleImmiScratch);
        const size_t cells = 168818;
        for (size_t cell = 0; cell < cells; ++cell) {
            assert(!flattened_array[cell]);
            flattened_array[cell] = new EntitySet<Person>;
        }
    }
    {
        assert(!asCalibrator);
        asCalibrator = new EntitySet<Calibrator>;
    }
    {
        assert(!asClock);
        asClock = new EntitySet<Clock>;
    }
    {
        EntitySet<Person> ** flattened_array = reinterpret_cast<EntitySet<Person> **>(asFemaleInUnionByAgeAndPartnerAge);
        const size_t cells = 4386;
        for (size_t cell = 0; cell < cells; ++cell) {
            assert(!flattened_array[cell]);
            flattened_array[cell] = new EntitySet<Person>;
        }
    }
    {
        EntitySet<Person> ** flattened_array = reinterpret_cast<EntitySet<Person> **>(asFemaleInUnionByAgeAndPartnerAgeImmiScratch);
        const size_t cells = 662286;
        for (size_t cell = 0; cell < cells; ++cell) {
            assert(!flattened_array[cell]);
            flattened_array[cell] = new EntitySet<Person>;
        }
    }
    {
        EntitySet<Observation> ** flattened_array = reinterpret_cast<EntitySet<Observation> **>(asObservationAll);
        const size_t cells = 4;
        for (size_t cell = 0; cell < cells; ++cell) {
            assert(!flattened_array[cell]);
            flattened_array[cell] = new EntitySet<Observation>;
        }
    }
    {
        EntitySet<Observation> ** flattened_array = reinterpret_cast<EntitySet<Observation> **>(asObservationByFam);
        const size_t cells = 2000001;
        for (size_t cell = 0; cell < cells; ++cell) {
            assert(!flattened_array[cell]);
            flattened_array[cell] = new EntitySet<Observation>;
        }
    }
    {
        EntitySet<Observation> ** flattened_array = reinterpret_cast<EntitySet<Observation> **>(asObservationByFamOldest);
        const size_t cells = 2000001;
        for (size_t cell = 0; cell < cells; ++cell) {
            assert(!flattened_array[cell]);
            flattened_array[cell] = new EntitySet<Observation>;
        }
    }
    {
        EntitySet<Observation> ** flattened_array = reinterpret_cast<EntitySet<Observation> **>(asObservationHeads);
        const size_t cells = 4;
        for (size_t cell = 0; cell < cells; ++cell) {
            assert(!flattened_array[cell]);
            flattened_array[cell] = new EntitySet<Observation>;
        }
    }
    {
        EntitySet<Observation> ** flattened_array = reinterpret_cast<EntitySet<Observation> **>(asObservationNonHeads);
        const size_t cells = 8000004;
        for (size_t cell = 0; cell < cells; ++cell) {
            assert(!flattened_array[cell]);
            flattened_array[cell] = new EntitySet<Observation>;
        }
    }
    {
        assert(!asObservations);
        asObservations = new EntitySet<Observation>;
    }
    {
        EntitySet<Person> ** flattened_array = reinterpret_cast<EntitySet<Person> **>(asPotentialImmigrantMothers);
        const size_t cells = 198263;
        for (size_t cell = 0; cell < cells; ++cell) {
            assert(!flattened_array[cell]);
            flattened_array[cell] = new EntitySet<Person>;
        }
    }
    {
        assert(!asPotentialSchoolOneStudent);
        asPotentialSchoolOneStudent = new EntitySet<Person>;
    }
    {
        assert(!asPotentialSchoolOneStudentToProcess);
        asPotentialSchoolOneStudentToProcess = new EntitySet<Person>;
    }
    {
        assert(!asPotentialSchoolTwoStudent);
        asPotentialSchoolTwoStudent = new EntitySet<Person>;
    }
    {
        assert(!asPotentialSchoolTwoStudentToProcess);
        asPotentialSchoolTwoStudentToProcess = new EntitySet<Person>;
    }
    {
        assert(!asResidentBabies);
        asResidentBabies = new EntitySet<Person>;
    }
    {
        EntitySet<Person> ** flattened_array = reinterpret_cast<EntitySet<Person> **>(asResidentsAge0Sex);
        const size_t cells = 2;
        for (size_t cell = 0; cell < cells; ++cell) {
            assert(!flattened_array[cell]);
            flattened_array[cell] = new EntitySet<Person>;
        }
    }
    {
        EntitySet<Person> ** flattened_array = reinterpret_cast<EntitySet<Person> **>(asResidentsAge0SexGeo);
        const size_t cells = 26;
        for (size_t cell = 0; cell < cells; ++cell) {
            assert(!flattened_array[cell]);
            flattened_array[cell] = new EntitySet<Person>;
        }
    }
    {
        EntitySet<Person> ** flattened_array = reinterpret_cast<EntitySet<Person> **>(asSimBornAge0);
        const size_t cells = 78;
        for (size_t cell = 0; cell < cells; ++cell) {
            assert(!flattened_array[cell]);
            flattened_array[cell] = new EntitySet<Person>;
        }
    }
    {
        EntitySet<Observation> ** flattened_array = reinterpret_cast<EntitySet<Observation> **>(asSimulatedObservationHeads);
        const size_t cells = 4;
        for (size_t cell = 0; cell < cells; ++cell) {
            assert(!flattened_array[cell]);
            flattened_array[cell] = new EntitySet<Observation>;
        }
    }
    {
        EntitySet<Person> ** flattened_array = reinterpret_cast<EntitySet<Person> **>(asWantToMove);
        const size_t cells = 4394;
        for (size_t cell = 0; cell < cells; ++cell) {
            assert(!flattened_array[cell]);
            flattened_array[cell] = new EntitySet<Person>;
        }
    }
    {
        EntitySet<Person> ** flattened_array = reinterpret_cast<EntitySet<Person> **>(asWomenNoChildren);
        const size_t cells = 306;
        for (size_t cell = 0; cell < cells; ++cell) {
            assert(!flattened_array[cell]);
            flattened_array[cell] = new EntitySet<Person>;
        }
    }
    {
        EntitySet<Person> ** flattened_array = reinterpret_cast<EntitySet<Person> **>(asWomenWithChildren);
        const size_t cells = 252;
        for (size_t cell = 0; cell < cells; ++cell) {
            assert(!flattened_array[cell]);
            flattened_array[cell] = new EntitySet<Person>;
        }
    }

}

// Model simulation
void RunModel(openm::IModel * const i_model)
{
    // initialize entity tables
    if (thePopPyramidByEduc) thePopPyramidByEduc->initialize_accumulators();
    if (theTabChildVaccination) theTabChildVaccination->initialize_accumulators();
    if (theTabEduc15ByDistrict) theTabEduc15ByDistrict->initialize_accumulators();
    if (theTabEduc15ByDistrictBirth) theTabEduc15ByDistrictBirth->initialize_accumulators();
    if (theTabEducFateByGroup) theTabEducFateByGroup->initialize_accumulators();
    if (theTabEducFateDistrYob) theTabEducFateDistrYob->initialize_accumulators();
    if (theTabHCIDistrict) theTabHCIDistrict->initialize_accumulators();
    if (theTabImmunizationChildren) theTabImmunizationChildren->initialize_accumulators();
    if (theTabPopProvAgeEducSex) theTabPopProvAgeEducSex->initialize_accumulators();
    if (theTabPrenatCare) theTabPrenatCare->initialize_accumulators();
    if (theTabPrimSchoolEntries) theTabPrimSchoolEntries->initialize_accumulators();
    if (theTabPrimSchoolGraduations) theTabPrimSchoolGraduations->initialize_accumulators();
    if (theTabPrimSchoolOutOfSchool9to11) theTabPrimSchoolOutOfSchool9to11->initialize_accumulators();
    if (theTabPrimarySchoolPlanning) theTabPrimarySchoolPlanning->initialize_accumulators();
    if (theTabSchool2AttainmentsTab) theTabSchool2AttainmentsTab->initialize_accumulators();
    if (theTabSchool2TrackTab) theTabSchool2TrackTab->initialize_accumulators();
    if (thetabBirthsYearPlace) thetabBirthsYearPlace->initialize_accumulators();
    if (thetabEducationFateGeobirYob) thetabEducationFateGeobirYob->initialize_accumulators();
    if (thetabHCI) thetabHCI->initialize_accumulators();
    if (thetabHavingSpouse) thetabHavingSpouse->initialize_accumulators();
    if (thetabMigrationOriginDestination) thetabMigrationOriginDestination->initialize_accumulators();
    if (thetabPopulationYearPlace) thetabPopulationYearPlace->initialize_accumulators();
    if (thetabPreSchool) thetabPreSchool->initialize_accumulators();
    if (thetabStuntingSexRegMotherYob) thetabStuntingSexRegMotherYob->initialize_accumulators();
    if (thetabStuntingSexRegYob) thetabStuntingSexRegYob->initialize_accumulators();

    BaseEvent::initialize_simulation_runtime();
    BaseAgent::initialize_simulation_runtime();

    int mem_id = i_model->subValueId();
    int mem_count = i_model->subValueCount();
    RunSimulation(mem_id, mem_count, i_model); // Defined by the model framework, generally in a 'use' module

    BaseEvent::finalize_simulation_runtime();
    BaseAgent::finalize_simulation_runtime();
}

// Model shutdown method: outputs
void ModelShutdown(IModel * const i_model)
{
    // obtain simulation member to use for log messages
    int simulation_member = i_model->subValueId();

    // extract accumulators, and scale them to population size
    if (thePopPyramidByEduc) thePopPyramidByEduc->extract_accumulators();
    if (thePopPyramidByEduc) thePopPyramidByEduc->scale_accumulators();
    if (theTabChildVaccination) theTabChildVaccination->extract_accumulators();
    if (theTabChildVaccination) theTabChildVaccination->scale_accumulators();
    if (theTabEduc15ByDistrict) theTabEduc15ByDistrict->extract_accumulators();
    if (theTabEduc15ByDistrict) theTabEduc15ByDistrict->scale_accumulators();
    if (theTabEduc15ByDistrictBirth) theTabEduc15ByDistrictBirth->extract_accumulators();
    if (theTabEduc15ByDistrictBirth) theTabEduc15ByDistrictBirth->scale_accumulators();
    if (theTabEducFateByGroup) theTabEducFateByGroup->extract_accumulators();
    if (theTabEducFateByGroup) theTabEducFateByGroup->scale_accumulators();
    if (theTabEducFateDistrYob) theTabEducFateDistrYob->extract_accumulators();
    if (theTabEducFateDistrYob) theTabEducFateDistrYob->scale_accumulators();
    if (theTabHCIDistrict) theTabHCIDistrict->extract_accumulators();
    if (theTabHCIDistrict) theTabHCIDistrict->scale_accumulators();
    if (theTabImmunizationChildren) theTabImmunizationChildren->extract_accumulators();
    if (theTabImmunizationChildren) theTabImmunizationChildren->scale_accumulators();
    if (theTabPopProvAgeEducSex) theTabPopProvAgeEducSex->extract_accumulators();
    if (theTabPopProvAgeEducSex) theTabPopProvAgeEducSex->scale_accumulators();
    if (theTabPrenatCare) theTabPrenatCare->extract_accumulators();
    if (theTabPrenatCare) theTabPrenatCare->scale_accumulators();
    if (theTabPrimSchoolEntries) theTabPrimSchoolEntries->extract_accumulators();
    if (theTabPrimSchoolEntries) theTabPrimSchoolEntries->scale_accumulators();
    if (theTabPrimSchoolGraduations) theTabPrimSchoolGraduations->extract_accumulators();
    if (theTabPrimSchoolGraduations) theTabPrimSchoolGraduations->scale_accumulators();
    if (theTabPrimSchoolOutOfSchool9to11) theTabPrimSchoolOutOfSchool9to11->extract_accumulators();
    if (theTabPrimSchoolOutOfSchool9to11) theTabPrimSchoolOutOfSchool9to11->scale_accumulators();
    if (theTabPrimarySchoolPlanning) theTabPrimarySchoolPlanning->extract_accumulators();
    if (theTabPrimarySchoolPlanning) theTabPrimarySchoolPlanning->scale_accumulators();
    if (theTabSchool2AttainmentsTab) theTabSchool2AttainmentsTab->extract_accumulators();
    if (theTabSchool2AttainmentsTab) theTabSchool2AttainmentsTab->scale_accumulators();
    if (theTabSchool2TrackTab) theTabSchool2TrackTab->extract_accumulators();
    if (theTabSchool2TrackTab) theTabSchool2TrackTab->scale_accumulators();
    if (thetabBirthsYearPlace) thetabBirthsYearPlace->extract_accumulators();
    if (thetabBirthsYearPlace) thetabBirthsYearPlace->scale_accumulators();
    if (thetabEducationFateGeobirYob) thetabEducationFateGeobirYob->extract_accumulators();
    if (thetabEducationFateGeobirYob) thetabEducationFateGeobirYob->scale_accumulators();
    if (thetabHCI) thetabHCI->extract_accumulators();
    if (thetabHCI) thetabHCI->scale_accumulators();
    if (thetabHavingSpouse) thetabHavingSpouse->extract_accumulators();
    if (thetabHavingSpouse) thetabHavingSpouse->scale_accumulators();
    if (thetabMigrationOriginDestination) thetabMigrationOriginDestination->extract_accumulators();
    if (thetabMigrationOriginDestination) thetabMigrationOriginDestination->scale_accumulators();
    if (thetabPopulationYearPlace) thetabPopulationYearPlace->extract_accumulators();
    if (thetabPopulationYearPlace) thetabPopulationYearPlace->scale_accumulators();
    if (thetabPreSchool) thetabPreSchool->extract_accumulators();
    if (thetabPreSchool) thetabPreSchool->scale_accumulators();
    if (thetabStuntingSexRegMotherYob) thetabStuntingSexRegMotherYob->extract_accumulators();
    if (thetabStuntingSexRegMotherYob) thetabStuntingSexRegMotherYob->scale_accumulators();
    if (thetabStuntingSexRegYob) thetabStuntingSexRegYob->extract_accumulators();
    if (thetabStuntingSexRegYob) thetabStuntingSexRegYob->scale_accumulators();

    // compute table expressions using accumulators
    if (thePopPyramidByEduc) thePopPyramidByEduc->compute_expressions();
    if (theTabChildVaccination) theTabChildVaccination->compute_expressions();
    if (theTabEduc15ByDistrict) theTabEduc15ByDistrict->compute_expressions();
    if (theTabEduc15ByDistrictBirth) theTabEduc15ByDistrictBirth->compute_expressions();
    if (theTabEducFateByGroup) theTabEducFateByGroup->compute_expressions();
    if (theTabEducFateDistrYob) theTabEducFateDistrYob->compute_expressions();
    if (theTabHCIDistrict) theTabHCIDistrict->compute_expressions();
    if (theTabImmunizationChildren) theTabImmunizationChildren->compute_expressions();
    if (theTabPopProvAgeEducSex) theTabPopProvAgeEducSex->compute_expressions();
    if (theTabPrenatCare) theTabPrenatCare->compute_expressions();
    if (theTabPrimSchoolEntries) theTabPrimSchoolEntries->compute_expressions();
    if (theTabPrimSchoolGraduations) theTabPrimSchoolGraduations->compute_expressions();
    if (theTabPrimSchoolOutOfSchool9to11) theTabPrimSchoolOutOfSchool9to11->compute_expressions();
    if (theTabPrimarySchoolPlanning) theTabPrimarySchoolPlanning->compute_expressions();
    if (theTabSchool2AttainmentsTab) theTabSchool2AttainmentsTab->compute_expressions();
    if (theTabSchool2TrackTab) theTabSchool2TrackTab->compute_expressions();
    if (thetabBirthsYearPlace) thetabBirthsYearPlace->compute_expressions();
    if (thetabEducationFateGeobirYob) thetabEducationFateGeobirYob->compute_expressions();
    if (thetabHCI) thetabHCI->compute_expressions();
    if (thetabHavingSpouse) thetabHavingSpouse->compute_expressions();
    if (thetabMigrationOriginDestination) thetabMigrationOriginDestination->compute_expressions();
    if (thetabPopulationYearPlace) thetabPopulationYearPlace->compute_expressions();
    if (thetabPreSchool) thetabPreSchool->compute_expressions();
    if (thetabStuntingSexRegMotherYob) thetabStuntingSexRegMotherYob->compute_expressions();
    if (thetabStuntingSexRegYob) thetabStuntingSexRegYob->compute_expressions();

    theLog->logFormatted("member=%d Write output tables - start", simulation_member);
    // write entity tables (accumulators) and release accumulators memory
    if (!is_suppressed_write("PopPyramidByEduc", i_model)) i_model->writeOutputTable("PopPyramidByEduc", thePopPyramidByEduc->n_cells, thePopPyramidByEduc->acc_storage);
    if (!is_suppressed_write("TabChildVaccination", i_model)) i_model->writeOutputTable("TabChildVaccination", theTabChildVaccination->n_cells, theTabChildVaccination->acc_storage);
    if (!is_suppressed_write("TabEduc15ByDistrict", i_model)) i_model->writeOutputTable("TabEduc15ByDistrict", theTabEduc15ByDistrict->n_cells, theTabEduc15ByDistrict->acc_storage);
    if (!is_suppressed_write("TabEduc15ByDistrictBirth", i_model)) i_model->writeOutputTable("TabEduc15ByDistrictBirth", theTabEduc15ByDistrictBirth->n_cells, theTabEduc15ByDistrictBirth->acc_storage);
    if (!is_suppressed_write("TabEducFateByGroup", i_model)) i_model->writeOutputTable("TabEducFateByGroup", theTabEducFateByGroup->n_cells, theTabEducFateByGroup->acc_storage);
    if (!is_suppressed_write("TabEducFateDistrYob", i_model)) i_model->writeOutputTable("TabEducFateDistrYob", theTabEducFateDistrYob->n_cells, theTabEducFateDistrYob->acc_storage);
    if (!is_suppressed_write("TabHCIDistrict", i_model)) i_model->writeOutputTable("TabHCIDistrict", theTabHCIDistrict->n_cells, theTabHCIDistrict->acc_storage);
    if (!is_suppressed_write("TabImmunizationChildren", i_model)) i_model->writeOutputTable("TabImmunizationChildren", theTabImmunizationChildren->n_cells, theTabImmunizationChildren->acc_storage);
    if (!is_suppressed_write("TabPopProvAgeEducSex", i_model)) i_model->writeOutputTable("TabPopProvAgeEducSex", theTabPopProvAgeEducSex->n_cells, theTabPopProvAgeEducSex->acc_storage);
    if (!is_suppressed_write("TabPrenatCare", i_model)) i_model->writeOutputTable("TabPrenatCare", theTabPrenatCare->n_cells, theTabPrenatCare->acc_storage);
    if (!is_suppressed_write("TabPrimSchoolEntries", i_model)) i_model->writeOutputTable("TabPrimSchoolEntries", theTabPrimSchoolEntries->n_cells, theTabPrimSchoolEntries->acc_storage);
    if (!is_suppressed_write("TabPrimSchoolGraduations", i_model)) i_model->writeOutputTable("TabPrimSchoolGraduations", theTabPrimSchoolGraduations->n_cells, theTabPrimSchoolGraduations->acc_storage);
    if (!is_suppressed_write("TabPrimSchoolOutOfSchool9to11", i_model)) i_model->writeOutputTable("TabPrimSchoolOutOfSchool9to11", theTabPrimSchoolOutOfSchool9to11->n_cells, theTabPrimSchoolOutOfSchool9to11->acc_storage);
    if (!is_suppressed_write("TabPrimarySchoolPlanning", i_model)) i_model->writeOutputTable("TabPrimarySchoolPlanning", theTabPrimarySchoolPlanning->n_cells, theTabPrimarySchoolPlanning->acc_storage);
    if (!is_suppressed_write("TabSchool2AttainmentsTab", i_model)) i_model->writeOutputTable("TabSchool2AttainmentsTab", theTabSchool2AttainmentsTab->n_cells, theTabSchool2AttainmentsTab->acc_storage);
    if (!is_suppressed_write("TabSchool2TrackTab", i_model)) i_model->writeOutputTable("TabSchool2TrackTab", theTabSchool2TrackTab->n_cells, theTabSchool2TrackTab->acc_storage);
    if (!is_suppressed_write("tabBirthsYearPlace", i_model)) i_model->writeOutputTable("tabBirthsYearPlace", thetabBirthsYearPlace->n_cells, thetabBirthsYearPlace->acc_storage);
    if (!is_suppressed_write("tabEducationFateGeobirYob", i_model)) i_model->writeOutputTable("tabEducationFateGeobirYob", thetabEducationFateGeobirYob->n_cells, thetabEducationFateGeobirYob->acc_storage);
    if (!is_suppressed_write("tabHCI", i_model)) i_model->writeOutputTable("tabHCI", thetabHCI->n_cells, thetabHCI->acc_storage);
    if (!is_suppressed_write("tabHavingSpouse", i_model)) i_model->writeOutputTable("tabHavingSpouse", thetabHavingSpouse->n_cells, thetabHavingSpouse->acc_storage);
    if (!is_suppressed_write("tabMigrationOriginDestination", i_model)) i_model->writeOutputTable("tabMigrationOriginDestination", thetabMigrationOriginDestination->n_cells, thetabMigrationOriginDestination->acc_storage);
    if (!is_suppressed_write("tabPopulationYearPlace", i_model)) i_model->writeOutputTable("tabPopulationYearPlace", thetabPopulationYearPlace->n_cells, thetabPopulationYearPlace->acc_storage);
    if (!is_suppressed_write("tabPreSchool", i_model)) i_model->writeOutputTable("tabPreSchool", thetabPreSchool->n_cells, thetabPreSchool->acc_storage);
    if (!is_suppressed_write("tabStuntingSexRegMotherYob", i_model)) i_model->writeOutputTable("tabStuntingSexRegMotherYob", thetabStuntingSexRegMotherYob->n_cells, thetabStuntingSexRegMotherYob->acc_storage);
    if (!is_suppressed_write("tabStuntingSexRegYob", i_model)) i_model->writeOutputTable("tabStuntingSexRegYob", thetabStuntingSexRegYob->n_cells, thetabStuntingSexRegYob->acc_storage);
    // at this point table->acc[k][j] will cause memory access violation

    // write derived tables (measures) and release measures memory
    // at this point table->measure[k][j] will cause memory access violation

    theLog->logFormatted("member=%d Write output tables - finish", simulation_member);
    // Entity table destruction
    if (thePopPyramidByEduc) {
        delete thePopPyramidByEduc;
        thePopPyramidByEduc = nullptr;
    }
    if (theTabChildVaccination) {
        delete theTabChildVaccination;
        theTabChildVaccination = nullptr;
    }
    if (theTabEduc15ByDistrict) {
        delete theTabEduc15ByDistrict;
        theTabEduc15ByDistrict = nullptr;
    }
    if (theTabEduc15ByDistrictBirth) {
        delete theTabEduc15ByDistrictBirth;
        theTabEduc15ByDistrictBirth = nullptr;
    }
    if (theTabEducFateByGroup) {
        delete theTabEducFateByGroup;
        theTabEducFateByGroup = nullptr;
    }
    if (theTabEducFateDistrYob) {
        delete theTabEducFateDistrYob;
        theTabEducFateDistrYob = nullptr;
    }
    if (theTabHCIDistrict) {
        delete theTabHCIDistrict;
        theTabHCIDistrict = nullptr;
    }
    if (theTabImmunizationChildren) {
        delete theTabImmunizationChildren;
        theTabImmunizationChildren = nullptr;
    }
    if (theTabPopProvAgeEducSex) {
        delete theTabPopProvAgeEducSex;
        theTabPopProvAgeEducSex = nullptr;
    }
    if (theTabPrenatCare) {
        delete theTabPrenatCare;
        theTabPrenatCare = nullptr;
    }
    if (theTabPrimSchoolEntries) {
        delete theTabPrimSchoolEntries;
        theTabPrimSchoolEntries = nullptr;
    }
    if (theTabPrimSchoolGraduations) {
        delete theTabPrimSchoolGraduations;
        theTabPrimSchoolGraduations = nullptr;
    }
    if (theTabPrimSchoolOutOfSchool9to11) {
        delete theTabPrimSchoolOutOfSchool9to11;
        theTabPrimSchoolOutOfSchool9to11 = nullptr;
    }
    if (theTabPrimarySchoolPlanning) {
        delete theTabPrimarySchoolPlanning;
        theTabPrimarySchoolPlanning = nullptr;
    }
    if (theTabSchool2AttainmentsTab) {
        delete theTabSchool2AttainmentsTab;
        theTabSchool2AttainmentsTab = nullptr;
    }
    if (theTabSchool2TrackTab) {
        delete theTabSchool2TrackTab;
        theTabSchool2TrackTab = nullptr;
    }
    if (thetabBirthsYearPlace) {
        delete thetabBirthsYearPlace;
        thetabBirthsYearPlace = nullptr;
    }
    if (thetabEducationFateGeobirYob) {
        delete thetabEducationFateGeobirYob;
        thetabEducationFateGeobirYob = nullptr;
    }
    if (thetabHCI) {
        delete thetabHCI;
        thetabHCI = nullptr;
    }
    if (thetabHavingSpouse) {
        delete thetabHavingSpouse;
        thetabHavingSpouse = nullptr;
    }
    if (thetabMigrationOriginDestination) {
        delete thetabMigrationOriginDestination;
        thetabMigrationOriginDestination = nullptr;
    }
    if (thetabPopulationYearPlace) {
        delete thetabPopulationYearPlace;
        thetabPopulationYearPlace = nullptr;
    }
    if (thetabPreSchool) {
        delete thetabPreSchool;
        thetabPreSchool = nullptr;
    }
    if (thetabStuntingSexRegMotherYob) {
        delete thetabStuntingSexRegMotherYob;
        thetabStuntingSexRegMotherYob = nullptr;
    }
    if (thetabStuntingSexRegYob) {
        delete thetabStuntingSexRegYob;
        thetabStuntingSexRegYob = nullptr;
    }

    // Derived table destruction

    // Entity set destruction
    {
        EntitySet<Person> ** flattened_array = reinterpret_cast<EntitySet<Person> **>(asAllFertilePersonsForFertilityAlignment);
        const size_t cells = 2;
        for (size_t cell = 0; cell < cells; ++cell) {
            assert(flattened_array[cell]);
            delete flattened_array[cell];
            flattened_array[cell] = nullptr;
        }
    }
    {
        EntitySet<Person> ** flattened_array = reinterpret_cast<EntitySet<Person> **>(asAllFertilePersonsForFertilityAlignmentByAge);
        const size_t cells = 76;
        for (size_t cell = 0; cell < cells; ++cell) {
            assert(flattened_array[cell]);
            delete flattened_array[cell];
            flattened_array[cell] = nullptr;
        }
    }
    {
        assert(asAllPerson);
        delete(asAllPerson);
        asAllPerson = nullptr;
    }
    {
        EntitySet<Person> ** flattened_array = reinterpret_cast<EntitySet<Person> **>(asAvailableMale);
        const size_t cells = 1118;
        for (size_t cell = 0; cell < cells; ++cell) {
            assert(flattened_array[cell]);
            delete flattened_array[cell];
            flattened_array[cell] = nullptr;
        }
    }
    {
        EntitySet<Person> ** flattened_array = reinterpret_cast<EntitySet<Person> **>(asAvailableMaleByType);
        const size_t cells = 3354;
        for (size_t cell = 0; cell < cells; ++cell) {
            assert(flattened_array[cell]);
            delete flattened_array[cell];
            flattened_array[cell] = nullptr;
        }
    }
    {
        EntitySet<Person> ** flattened_array = reinterpret_cast<EntitySet<Person> **>(asAvailableMaleByTypeImmiScratch);
        const size_t cells = 506454;
        for (size_t cell = 0; cell < cells; ++cell) {
            assert(flattened_array[cell]);
            delete flattened_array[cell];
            flattened_array[cell] = nullptr;
        }
    }
    {
        EntitySet<Person> ** flattened_array = reinterpret_cast<EntitySet<Person> **>(asAvailableMaleImmiScratch);
        const size_t cells = 168818;
        for (size_t cell = 0; cell < cells; ++cell) {
            assert(flattened_array[cell]);
            delete flattened_array[cell];
            flattened_array[cell] = nullptr;
        }
    }
    {
        assert(asCalibrator);
        delete(asCalibrator);
        asCalibrator = nullptr;
    }
    {
        assert(asClock);
        delete(asClock);
        asClock = nullptr;
    }
    {
        EntitySet<Person> ** flattened_array = reinterpret_cast<EntitySet<Person> **>(asFemaleInUnionByAgeAndPartnerAge);
        const size_t cells = 4386;
        for (size_t cell = 0; cell < cells; ++cell) {
            assert(flattened_array[cell]);
            delete flattened_array[cell];
            flattened_array[cell] = nullptr;
        }
    }
    {
        EntitySet<Person> ** flattened_array = reinterpret_cast<EntitySet<Person> **>(asFemaleInUnionByAgeAndPartnerAgeImmiScratch);
        const size_t cells = 662286;
        for (size_t cell = 0; cell < cells; ++cell) {
            assert(flattened_array[cell]);
            delete flattened_array[cell];
            flattened_array[cell] = nullptr;
        }
    }
    {
        EntitySet<Observation> ** flattened_array = reinterpret_cast<EntitySet<Observation> **>(asObservationAll);
        const size_t cells = 4;
        for (size_t cell = 0; cell < cells; ++cell) {
            assert(flattened_array[cell]);
            delete flattened_array[cell];
            flattened_array[cell] = nullptr;
        }
    }
    {
        EntitySet<Observation> ** flattened_array = reinterpret_cast<EntitySet<Observation> **>(asObservationByFam);
        const size_t cells = 2000001;
        for (size_t cell = 0; cell < cells; ++cell) {
            assert(flattened_array[cell]);
            delete flattened_array[cell];
            flattened_array[cell] = nullptr;
        }
    }
    {
        EntitySet<Observation> ** flattened_array = reinterpret_cast<EntitySet<Observation> **>(asObservationByFamOldest);
        const size_t cells = 2000001;
        for (size_t cell = 0; cell < cells; ++cell) {
            assert(flattened_array[cell]);
            delete flattened_array[cell];
            flattened_array[cell] = nullptr;
        }
    }
    {
        EntitySet<Observation> ** flattened_array = reinterpret_cast<EntitySet<Observation> **>(asObservationHeads);
        const size_t cells = 4;
        for (size_t cell = 0; cell < cells; ++cell) {
            assert(flattened_array[cell]);
            delete flattened_array[cell];
            flattened_array[cell] = nullptr;
        }
    }
    {
        EntitySet<Observation> ** flattened_array = reinterpret_cast<EntitySet<Observation> **>(asObservationNonHeads);
        const size_t cells = 8000004;
        for (size_t cell = 0; cell < cells; ++cell) {
            assert(flattened_array[cell]);
            delete flattened_array[cell];
            flattened_array[cell] = nullptr;
        }
    }
    {
        assert(asObservations);
        delete(asObservations);
        asObservations = nullptr;
    }
    {
        EntitySet<Person> ** flattened_array = reinterpret_cast<EntitySet<Person> **>(asPotentialImmigrantMothers);
        const size_t cells = 198263;
        for (size_t cell = 0; cell < cells; ++cell) {
            assert(flattened_array[cell]);
            delete flattened_array[cell];
            flattened_array[cell] = nullptr;
        }
    }
    {
        assert(asPotentialSchoolOneStudent);
        delete(asPotentialSchoolOneStudent);
        asPotentialSchoolOneStudent = nullptr;
    }
    {
        assert(asPotentialSchoolOneStudentToProcess);
        delete(asPotentialSchoolOneStudentToProcess);
        asPotentialSchoolOneStudentToProcess = nullptr;
    }
    {
        assert(asPotentialSchoolTwoStudent);
        delete(asPotentialSchoolTwoStudent);
        asPotentialSchoolTwoStudent = nullptr;
    }
    {
        assert(asPotentialSchoolTwoStudentToProcess);
        delete(asPotentialSchoolTwoStudentToProcess);
        asPotentialSchoolTwoStudentToProcess = nullptr;
    }
    {
        assert(asResidentBabies);
        delete(asResidentBabies);
        asResidentBabies = nullptr;
    }
    {
        EntitySet<Person> ** flattened_array = reinterpret_cast<EntitySet<Person> **>(asResidentsAge0Sex);
        const size_t cells = 2;
        for (size_t cell = 0; cell < cells; ++cell) {
            assert(flattened_array[cell]);
            delete flattened_array[cell];
            flattened_array[cell] = nullptr;
        }
    }
    {
        EntitySet<Person> ** flattened_array = reinterpret_cast<EntitySet<Person> **>(asResidentsAge0SexGeo);
        const size_t cells = 26;
        for (size_t cell = 0; cell < cells; ++cell) {
            assert(flattened_array[cell]);
            delete flattened_array[cell];
            flattened_array[cell] = nullptr;
        }
    }
    {
        EntitySet<Person> ** flattened_array = reinterpret_cast<EntitySet<Person> **>(asSimBornAge0);
        const size_t cells = 78;
        for (size_t cell = 0; cell < cells; ++cell) {
            assert(flattened_array[cell]);
            delete flattened_array[cell];
            flattened_array[cell] = nullptr;
        }
    }
    {
        EntitySet<Observation> ** flattened_array = reinterpret_cast<EntitySet<Observation> **>(asSimulatedObservationHeads);
        const size_t cells = 4;
        for (size_t cell = 0; cell < cells; ++cell) {
            assert(flattened_array[cell]);
            delete flattened_array[cell];
            flattened_array[cell] = nullptr;
        }
    }
    {
        EntitySet<Person> ** flattened_array = reinterpret_cast<EntitySet<Person> **>(asWantToMove);
        const size_t cells = 4394;
        for (size_t cell = 0; cell < cells; ++cell) {
            assert(flattened_array[cell]);
            delete flattened_array[cell];
            flattened_array[cell] = nullptr;
        }
    }
    {
        EntitySet<Person> ** flattened_array = reinterpret_cast<EntitySet<Person> **>(asWomenNoChildren);
        const size_t cells = 306;
        for (size_t cell = 0; cell < cells; ++cell) {
            assert(flattened_array[cell]);
            delete flattened_array[cell];
            flattened_array[cell] = nullptr;
        }
    }
    {
        EntitySet<Person> ** flattened_array = reinterpret_cast<EntitySet<Person> **>(asWomenWithChildren);
        const size_t cells = 252;
        for (size_t cell = 0; cell < cells; ++cell) {
            assert(flattened_array[cell]);
            delete flattened_array[cell];
            flattened_array[cell] = nullptr;
        }
    }

}

namespace openm
{
    // set entry points to the code generated by openM++ compiler
    static ModelEntryHolder theModelEntry(::RunOnce, ::RunInit, ::ModelStartup, ::RunModel, ::ModelShutdown);
}

namespace openm
{
    // size of parameters list: number of model input parameters
    const size_t PARAMETER_NAME_ARR_LEN = 71;

    // list of model input parameters name, type and size
    const ParameterNameSizeItem parameterNameSizeArr[PARAMETER_NAME_ARR_LEN] =
    {
        {"AgeImmiSearchMother", typeid(double), 1},
        {"AgeImmigrantsScratch", typeid(double), 202},
        {"AgeLeavingHome", typeid(double), 1},
        {"AgeOfImmigrantMother", typeid(double), 38},
        {"AgeSpecificFertility", typeid(double), 5738},
        {"BackMigrationHazard", typeid(double), 1},
        {"BirthTrends", typeid(double), 2265},
        {"ChildMortalityBaseRisk", typeid(double), 10},
        {"ChildMortalityRelativeRisks", typeid(double), 45},
        {"ChildMortalityTrend", typeid(double), 730},
        {"ChildVaccinationOdds", typeid(double), 5436},
        {"Educ1FirstCohortRefinedModel", typeid(int), 1},
        {"Educ1GradOdds", typeid(double), 6},
        {"Educ1Infrastructure", typeid(double), 3624},
        {"Educ1Model", typeid(char), 1},
        {"Educ1StartOdds", typeid(double), 6},
        {"Educ2AllowedDelays", typeid(int), 1},
        {"Educ2DelayedProgressionIntake", typeid(double), 906},
        {"Educ2DelayedRepetitionIntake", typeid(double), 906},
        {"Educ2DirectProgressionIntake", typeid(double), 906},
        {"Educ2DirectRepetitionIntake", typeid(double), 906},
        {"Educ2PeriodSuccess", typeid(double), 906},
        {"EducOneDropoutGrade", typeid(double), 402},
        {"EducOneEntryAge", typeid(double), 268},
        {"EducTrans1", typeid(double), 1638},
        {"EducTrans2", typeid(double), 1742},
        {"EmigrationDestination", typeid(double), 1},
        {"EmigrationRatesDistrict", typeid(double), 312},
        {"EndSchoolOneYear", typeid(double), 1},
        {"EthnicTransmission", typeid(double), 200},
        {"EthnicityImmigrantsScratch", typeid(double), 240},
        {"FertilityModel", typeid(char), 1},
        {"FirstBirthRates", typeid(double), 1140},
        {"HCICoefficients", typeid(double), 3},
        {"HigherOrderBirthsPara", typeid(double), 154},
        {"ImmiPoolDestination", typeid(double), 5436},
        {"ImmiPoolSize", typeid(double), 453},
        {"ImmiScratchDestination", typeid(double), 312},
        {"InUnionProbNoChildren", typeid(double), 153},
        {"InUnionProbWithChildren", typeid(double), 126},
        {"LifeExpectancy", typeid(double), 302},
        {"MicroDataInputFile", typeid(std::string), 1},
        {"MigrationDestination", typeid(double), 3744},
        {"MigrationProbability", typeid(double), 312},
        {"MigrationTryKeepingFamiliesTogether", typeid(bool), 1},
        {"ModelBackmigration", typeid(bool), 1},
        {"ModelEmigration", typeid(bool), 1},
        {"ModelImmigrationFromPools", typeid(bool), 1},
        {"ModelImmigrationFromScratch", typeid(bool), 1},
        {"ModelMigration", typeid(bool), 1},
        {"MortalityModel", typeid(char), 1},
        {"MortalityTable", typeid(double), 202},
        {"NumberImmigrantsFromScratch", typeid(double), 302},
        {"PartnerAgeDistribution", typeid(double), 4386},
        {"PartnerCharacteristicDistribution", typeid(double), 9},
        {"PreNatalCareOdds", typeid(double), 1661},
        {"PreSchoolAttendance", typeid(double), 3020},
        {"ProbStayWithMother", typeid(double), 1},
        {"ProportionStunting", typeid(double), 30},
        {"SchoolOneInterruptionRate", typeid(double), 151},
        {"SchoolOneRepetitionRate", typeid(double), 151},
        {"SchoolQuality", typeid(double), 10},
        {"SexRatio", typeid(double), 151},
        {"SimulationEnd", typeid(double), 1},
        {"SimulationSeed", typeid(int), 1},
        {"StartPopSampleSize", typeid(double), 1},
        {"StartSchoolOneYear", typeid(double), 1},
        {"TotalFertilityRate", typeid(double), 151},
        {"Union1Choice", typeid(char), 1},
        {"Union1ParametersCMN", typeid(double), 783},
        {"Union1ParametersHazards", typeid(double), 38556}
    };
}

// model name
const char * OM_MODEL_NAME = "Dynamis-Pop-3-06-ABC";

// model metadata digest
const char * OM_MODEL_DIGEST = "6eccce191106d267b262a54392186270";
